This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/lib/perplexity-intelligence.ts, src/lib/perplexity-service.ts, src/lib/perplexity-job-search.ts, src/lib/agents/job-discovery-agent.ts, src/lib/agents/agent-orchestrator.ts, src/lib/agents/perplexity-career-agent.ts, src/app/api/jobs/search/route.ts, src/app/api/resume/upload/route.ts, src/lib/scrapers/advanced-scraper.ts, src/lib/web-scraper.ts, src/lib/job-scraper.ts, src/lib/linkedin-job-integration.ts, src/lib/canadian-job-scraper.ts, src/app/job-boards/components/job-boards-dashboard.tsx, src/components/job-card.tsx, src/components/modern/ModernJobCard.tsx, src/components/modern/SearchHeroSection.tsx, src/app/resume-builder/page.tsx, src/components/resume-builder/template-selector.tsx, src/lib/job-deduplication.ts, src/services/job-search-cache.service.ts, src/lib/job-outlook-analyzer.ts, src/lib/validation.ts, src/types/comprehensive.ts, src/types/unified.ts, src/types/index.ts, package.json, next.config.js
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
Career Lever AI - Perplexity & Scraping CORRECTED Pack

Includes: ACTUAL files that exist (not missing ones)
Perplexity Intelligence, Agents, Scrapers, Job Search APIs, Frontend Components

Generated: {{generationDate}}
</user_provided_header>

<directory_structure>
next.config.js
package.json
src/app/api/jobs/search/route.ts
src/app/api/resume/upload/route.ts
src/app/job-boards/components/job-boards-dashboard.tsx
src/app/resume-builder/page.tsx
src/components/job-card.tsx
src/components/modern/ModernJobCard.tsx
src/components/modern/SearchHeroSection.tsx
src/components/resume-builder/template-selector.tsx
src/lib/agents/agent-orchestrator.ts
src/lib/agents/job-discovery-agent.ts
src/lib/agents/perplexity-career-agent.ts
src/lib/canadian-job-scraper.ts
src/lib/job-deduplication.ts
src/lib/job-outlook-analyzer.ts
src/lib/job-scraper.ts
src/lib/linkedin-job-integration.ts
src/lib/perplexity-intelligence.ts
src/lib/perplexity-job-search.ts
src/lib/perplexity-service.ts
src/lib/scrapers/advanced-scraper.ts
src/lib/validation.ts
src/lib/web-scraper.ts
src/services/job-search-cache.service.ts
src/types/comprehensive.ts
src/types/index.ts
src/types/unified.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="next.config.js">
  1: /** @type {import('next').NextConfig} */
  2: const nextConfig = {
  3:     // Enable standalone output for Docker deployment
  4:     output: 'standalone',
  5:     
  6:     // Performance optimizations
  7:     compress: true, // Enable gzip compression
  8:     poweredByHeader: false, // Remove X-Powered-By header
  9:     
 10:     // Enable SWC minification (faster than Terser)
 11:     swcMinify: true,
 12:     
 13:     // Optimize production builds
 14:     productionBrowserSourceMaps: false, // Disable source maps in prod
 15:     
 16:     // React optimizations
 17:     reactStrictMode: true,
 18:     
 19:     i18n: {
 20:         locales: ['en', 'fr'],
 21:         defaultLocale: 'en',
 22:     },
 23:     env: {
 24:         MONGODB_URI: process.env.MONGODB_URI,
 25:         NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
 26:         NEXTAUTH_URL: process.env.NEXTAUTH_URL,
 27:         // OPENAI_API_KEY is deprecated; retaining only if legacy routes remain
 28:         // OPENAI_API_KEY: process.env.OPENAI_API_KEY,
 29:         PERPLEXITY_API_KEY: process.env.PERPLEXITY_API_KEY,
 30:         PERPLEXITY_BASE_URL: process.env.PERPLEXITY_BASE_URL || 'https://api.perplexity.ai',
 31:         PERPLEXITY_MODEL: process.env.PERPLEXITY_MODEL || 'sonar-pro',
 32:         // OpenAI assistant IDs deprecated after Perplexity migration
 33:         NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,
 34:         NEXT_PUBLIC_ENVIRONMENT: process.env.NEXT_PUBLIC_ENVIRONMENT || process.env.RAILWAY_ENVIRONMENT_NAME || 'production',
 35:     },
 36:     async headers() {
 37:         return [{
 38:             source: '/(.*)',
 39:             headers: [
 40:                 { key: 'X-Content-Type-Options', value: 'nosniff' },
 41:                 { key: 'X-Frame-Options', value: 'SAMEORIGIN' },
 42:                 { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin' },
 43:                 { key: 'Permissions-Policy', value: 'geolocation=(), microphone=(), camera=()' },
 44:                 { key: 'Strict-Transport-Security', value: 'max-age=63072000; includeSubDomains; preload' },
 45:                 { key: 'Cross-Origin-Opener-Policy', value: 'same-origin' },
 46:                 { key: 'Cross-Origin-Resource-Policy', value: 'same-origin' },
 47:                 { key: 'X-DNS-Prefetch-Control', value: 'off' },
 48:                 {
 49:                     key: 'Content-Security-Policy',
 50:                     value: [
 51:                         "default-src 'self'",
 52:                         "script-src 'self' 'unsafe-inline' 'unsafe-eval' blob: data: https://cdnjs.cloudflare.com",
 53:                         "worker-src 'self' blob:",
 54:                         "style-src 'self' 'unsafe-inline' https:",
 55:                         "img-src 'self' data: blob:",
 56:                         "font-src 'self' data: https:",
 57:                         "connect-src 'self' https: wss:",
 58:                         "frame-src 'self' https://accounts.google.com",
 59:                         "object-src 'none'",
 60:                         "base-uri 'self'",
 61:                         "form-action 'self' https://accounts.google.com https://*.google.com https://*.googleusercontent.com"
 62:                     ].join('; ')
 63:                 }
 64:             ]
 65:         }]
 66:     },
 67:     images: {
 68:         domains: ['localhost'],
 69:         formats: ['image/avif', 'image/webp'], // Modern image formats
 70:         minimumCacheTTL: 60, // Cache images for 60 seconds
 71:         deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
 72:         imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
 73:     },
 74:     
 75:     // Experimental features for performance
 76:     experimental: {
 77:         // Optimize package imports (tree-shaking)
 78:         optimizePackageImports: [
 79:             '@heroicons/react', 
 80:             'lucide-react',
 81:             '@tanstack/react-query',
 82:             'react-hot-toast',
 83:             'recharts'
 84:         ],
 85:         // Disable CSS optimization to avoid critters dependency issue
 86:         // optimizeCss: true,
 87:     },
 88:     eslint: {
 89:         ignoreDuringBuilds: true,
 90:     },
 91:     typescript: {
 92:         // Allow disabling type-check during build via env to avoid OOM on small builders
 93:         ignoreBuildErrors: process.env.DISABLE_TYPECHECK === 'true',
 94:     },
 95:     webpack: (config, { isServer }) => {
 96:         // Avoid bundling optional 'canvas' dependency required by pdfjs in Node builds
 97:         config.resolve = config.resolve || {}
 98:         config.resolve.alias = config.resolve.alias || {}
 99:         config.resolve.alias['canvas'] = false
100:         if (isServer) {
101:             config.externals = config.externals || []
102:                 // Mark canvas as external in server to prevent resolution errors
103:             config.externals.push({ canvas: 'commonjs canvas' })
104:         }
105:         return config
106:     }
107: }
108: 
109: module.exports = nextConfig
</file>

<file path="src/app/job-boards/components/job-boards-dashboard.tsx">
  1: 'use client'
  2: 
  3: import { useState, useEffect, useCallback } from 'react'
  4: import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
  5: import { Button } from '@/components/ui/button'
  6: import { Badge } from '@/components/ui/badge'
  7: import { Checkbox } from '@/components/ui/checkbox'
  8: import { Alert, AlertDescription } from '@/components/ui/alert'
  9: import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
 10: import { Input } from '@/components/ui/input'
 11: import { Label } from '@/components/ui/label'
 12: import { Progress } from '@/components/ui/progress'
 13: import {
 14:   Send,
 15:   CheckCircle,
 16:   AlertTriangle,
 17:   Zap,
 18:   Target,
 19:   TrendingUp,
 20:   Clock,
 21:   Settings,
 22:   ExternalLink,
 23:   Play,
 24:   Pause,
 25:   RefreshCw,
 26:   Users,
 27:   Building,
 28:   Briefcase,
 29:   FileText,
 30:   Link,
 31:   Globe,
 32:   Loader2
 33: } from 'lucide-react'
 34: import toast from 'react-hot-toast'
 35: import { useSession } from 'next-auth/react'
 36: 
 37: interface JobBoard {
 38:   id: string
 39:   name: string
 40:   automationLevel: 'full' | 'partial' | 'manual'
 41:   loginRequired: boolean
 42:   features: {
 43:     fileUpload: boolean
 44:     coverLetter: boolean
 45:     autoSubmit: boolean
 46:   }
 47:   status: 'connected' | 'disconnected' | 'error'
 48:   lastUsed?: Date
 49:   successRate?: number
 50:   totalApplications?: number
 51: }
 52: 
 53: interface BulkSubmission {
 54:   selectedBoards: string[]
 55:   selectedApplications: string[]
 56:   status: 'idle' | 'running' | 'completed' | 'failed'
 57:   progress: number
 58:   results?: any[]
 59: }
 60: 
 61: interface JobBoardsDashboardProps {
 62:   userId: string
 63: }
 64: 
 65: export function JobBoardsDashboard({ userId }: JobBoardsDashboardProps) {
 66:   const { data: session } = useSession()
 67:   const [jobBoards, setJobBoards] = useState<JobBoard[]>([])
 68:   const [applications, setApplications] = useState<any[]>([])
 69:   const [selectedBoards, setSelectedBoards] = useState<string[]>([])
 70:   const [selectedApplications, setSelectedApplications] = useState<string[]>([])
 71:   const [bulkSubmission, setBulkSubmission] = useState<BulkSubmission>({
 72:     selectedBoards: [],
 73:     selectedApplications: [],
 74:     status: 'idle',
 75:     progress: 0
 76:   })
 77:   const [isLoading, setIsLoading] = useState(true)
 78:   const [autoPilotEnabled, setAutoPilotEnabled] = useState(true)
 79:   const [jobsByBoard, setJobsByBoard] = useState<Record<string, Array<{ title?: string; url?: string; company?: string; location?: string }>>>({})
 80:   const [jobsLoading, setJobsLoading] = useState<Record<string, boolean>>({})
 81:   const [jobsOpen, setJobsOpen] = useState<Record<string, boolean>>({})
 82:   const [autoPilotSettings, setAutoPilotSettings] = useState({
 83:     dailyLimit: 10,
 84:     jobBoards: [],
 85:     keywords: '',
 86:     locations: '',
 87:     salaryRange: { min: 0, max: 0 },
 88:     timeoutMs: 120000
 89:   })
 90:   const [autoPilotResults, setAutoPilotResults] = useState<Array<{ title?: string; url: string; company?: string; location?: string; source?: string }>>([])
 91:   const [autoPilotRunning, setAutoPilotRunning] = useState(false)
 92:   const [progress, setProgress] = useState<{ percent: number; stage: string }>({ percent: 0, stage: 'Idle' })
 93:   const [qualityMode, setQualityMode] = useState<'speed'|'quality'>('speed')
 94:   const [filters, setFilters] = useState<{ workType: 'any'|'remote'|'hybrid'|'onsite'; experienceLevel: 'any'|'entry'|'mid'|'senior'|'executive'; salaryMin?: number; maxResults?: number }>({ workType: 'any', experienceLevel: 'any', salaryMin: undefined, maxResults: 15 })
 95: 
 96:   // Load job boards and applications
 97:   useEffect(() => {
 98:     loadData()
 99:   }, [])
100: 
101:   // When Auto-Pilot is enabled, try to prefill keywords/locations from resume/profile
102:   useEffect(() => {
103:     if (!autoPilotEnabled) return
104:     (async () => {
105:       try {
106:         // Prefill location from profile
107:         const prof = await fetch('/api/profile')
108:         if (prof.ok) {
109:           const pj = await prof.json()
110:           if (pj?.profile?.location) {
111:             setAutoPilotSettings(prev => ({ ...prev, locations: pj.profile.location }))
112:           }
113:         }
114:       } catch {}
115:       try {
116:         // Prefill keywords from resume titles (best-effort)
117:         const res = await fetch('/api/resume/list')
118:         if (res.ok) {
119:           const rj = await res.json()
120:           const txt: string = rj?.resumes?.[0]?.extractedText || ''
121:           if (txt && txt.length > 50) {
122:             const firstLines = txt.split(/\n|\r/).slice(0, 12).join(' ')
123:             const words = firstLines.match(/[A-Za-z][A-Za-z+\-]{2,}/g) || []
124:             const top = Array.from(new Set(words)).slice(0, 8).join(', ')
125:             if (top) setAutoPilotSettings(prev => ({ ...prev, keywords: top }))
126:           }
127:         }
128:       } catch {}
129:     })()
130:   }, [autoPilotEnabled])
131: 
132:   const loadData = async () => {
133:     setIsLoading(true)
134:     try {
135:       // Load available job boards
136:       const boardsResponse = await fetch('/api/job-boards/submit')
137:       const boardsData = await boardsResponse.json()
138: 
139:       // Load user's job applications
140:       const appsResponse = await fetch('/api/applications')
141:       const appsData = await appsResponse.json()
142: 
143:       // Load profile to prefill autopilot
144:       try {
145:         const profRes = await fetch('/api/profile')
146:         if (profRes.ok) {
147:           const pj = await profRes.json()
148:           const p = pj?.profile || {}
149:           setAutoPilotSettings(prev => ({
150:             ...prev,
151:             keywords: (p.skills && Array.isArray(p.skills) ? p.skills.slice(0, 8).join(', ') : prev.keywords),
152:             locations: (typeof p.location === 'string' && p.location) ? p.location : prev.locations,
153:           }))
154:         }
155:       } catch {}
156: 
157:       if (boardsData.success) {
158:         // Load user's job board integrations from database
159:         const integrationsResponse = await fetch('/api/job-boards/integrations')
160:         const integrationsData = await integrationsResponse.json()
161: 
162:         // Enhance job board data with user-specific status
163:         const enhancedBoards = boardsData.jobBoards.map((board: any) => {
164:           const integration = integrationsData.success ?
165:             integrationsData.integrations.find((i: any) => i.boardName === board.id) : null
166: 
167:           return {
168:             ...board,
169:             status: integration ? integration.status : 'disconnected',
170:             lastUsed: integration ? integration.lastApplicationAt : undefined,
171:             successRate: integration ?
172:               Math.round((integration.successfulApplications / Math.max(integration.totalApplications, 1)) * 100) : 0,
173:             totalApplications: integration ? integration.totalApplications : 0
174:           }
175:         })
176:         setJobBoards(enhancedBoards)
177:       }
178: 
179:       if (appsData.applications) {
180:         // Map to fields this UI expects minimally
181:         const mapped = appsData.applications.map((app: any) => ({
182:           _id: app._id,
183:           jobTitle: app.jobTitle,
184:           company: app.companyName, // UI uses company
185:           status: app.applicationStatus, // UI uses status
186:           createdAt: app.createdAt,
187:         }))
188:         setApplications(mapped)
189:       }
190:     } catch (error) {
191:       console.error('Failed to load data:', error)
192:       toast.error('Failed to load job board data')
193:     } finally {
194:       setIsLoading(false)
195:     }
196:   }
197: 
198:   const handleBoardSelection = (boardId: string, checked: boolean) => {
199:     setSelectedBoards(prev =>
200:       checked
201:         ? [...prev, boardId]
202:         : prev.filter(id => id !== boardId)
203:     )
204:   }
205: 
206:   const handleApplicationSelection = (appId: string, checked: boolean) => {
207:     setSelectedApplications(prev =>
208:       checked
209:         ? [...prev, appId]
210:         : prev.filter(id => id !== appId)
211:     )
212:   }
213: 
214:   const handleBulkSubmit = async () => {
215:     if (selectedBoards.length === 0 || selectedApplications.length === 0) {
216:       toast.error('Please select both job boards and applications')
217:       return
218:     }
219: 
220:     setBulkSubmission({
221:       selectedBoards,
222:       selectedApplications,
223:       status: 'running',
224:       progress: 0
225:     })
226: 
227:     try {
228:       const totalOperations = selectedBoards.length * selectedApplications.length
229:       let completedOperations = 0
230: 
231:       const results: any[] = []
232: 
233:       for (const boardId of selectedBoards) {
234:         for (const appId of selectedApplications) {
235:           try {
236:             const response = await fetch('/api/job-boards/submit', {
237:               method: 'POST',
238:               headers: {
239:                 'Content-Type': 'application/json',
240:               },
241:               body: JSON.stringify({
242:                 jobApplicationId: appId,
243:                 jobBoards: [boardId],
244:                 customizations: {}
245:               }),
246:             })
247: 
248:             const result = await response.json()
249:             results.push({ boardId, appId, ...result })
250: 
251:             completedOperations++
252:             setBulkSubmission(prev => ({
253:               ...prev,
254:               progress: (completedOperations / totalOperations) * 100
255:             }))
256: 
257:             // Small delay to avoid rate limiting
258:             await new Promise(resolve => setTimeout(resolve, 1000))
259:           } catch (error) {
260:             console.error(`Failed to submit ${appId} to ${boardId}:`, error)
261:             results.push({
262:               boardId,
263:               appId,
264:               success: false,
265:               error: error instanceof Error ? error.message : 'Unknown error'
266:             })
267: 
268:             completedOperations++
269:             setBulkSubmission(prev => ({
270:               ...prev,
271:               progress: (completedOperations / totalOperations) * 100
272:             }))
273:           }
274:         }
275:       }
276: 
277:       setBulkSubmission(prev => ({
278:         ...prev,
279:         status: 'completed',
280:         results
281:       }))
282: 
283:       const successful = results.filter(r => r.success).length
284:       toast.success(`Successfully submitted to ${successful} out of ${results.length} positions`)
285: 
286:       // Reset selections
287:       setSelectedBoards([])
288:       setSelectedApplications([])
289: 
290:     } catch (error) {
291:       console.error('Bulk submission error:', error)
292:       setBulkSubmission(prev => ({
293:         ...prev,
294:         status: 'failed'
295:       }))
296:       toast.error('Bulk submission failed')
297:     }
298:   }
299: 
300:   const connectToBoard = async (boardId: string) => {
301:     try {
302:       // Initiate OAuth flow
303:       const response = await fetch('/api/job-boards/oauth/authorize', {
304:         method: 'POST',
305:         headers: {
306:           'Content-Type': 'application/json',
307:         },
308:         body: JSON.stringify({ boardName: boardId }),
309:       })
310: 
311:       const data = await response.json()
312: 
313:       if (data.success && data.authUrl) {
314:         // Redirect to OAuth authorization URL
315:         window.location.href = data.authUrl
316:       } else {
317:         throw new Error(data.error || 'Failed to initiate OAuth flow')
318:       }
319:     } catch (error) {
320:       console.error('Failed to connect to job board:', error)
321:       toast.error(`Failed to connect to ${jobBoards.find(b => b.id === boardId)?.name}`)
322:     }
323:   }
324: 
325:   const syncJobs = async (boardId: string) => {
326:     try {
327:       const resp = await fetch('/api/job-boards/jobs/sync', {
328:         method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ boardName: boardId })
329:       })
330:       const json = await resp.json()
331:       if (!resp.ok || !json.success) throw new Error(json.error || 'Sync failed')
332:       toast.success(`Imported ${json.created} new, updated ${json.updated}`)
333:     } catch (e) {
334:       toast.error('Failed to sync jobs')
335:     }
336:   }
337: 
338:   const loadBoardJobs = async (boardId: string) => {
339:     setJobsLoading(prev => ({ ...prev, [boardId]: true }))
340:     try {
341:       const resp = await fetch('/api/job-boards/jobs/list', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ boardName: boardId }) })
342:       const reqId = resp.headers.get('x-request-id') || ''
343:       const json = await resp.json().catch(()=>({}))
344:       if (!resp.ok || !json.success) {
345:         if (resp.status === 401) toast.error('Please re-connect this integration' + (reqId ? ` (Ref: ${reqId})` : ''))
346:         else toast.error((json.error || 'Failed to load jobs') + (reqId ? ` (Ref: ${reqId})` : ''))
347:         return
348:       }
349:       const jobs = (json.jobs || []).map((j: any) => ({ title: j.title || j.position || j.name, url: j.url || j.link, company: j.company || j.companyName, location: j.location }))
350:       setJobsByBoard(prev => ({ ...prev, [boardId]: jobs }))
351:       setJobsOpen(prev => ({ ...prev, [boardId]: true }))
352:     } catch {
353:       toast.error('Failed to load jobs')
354:     } finally {
355:       setJobsLoading(prev => ({ ...prev, [boardId]: false }))
356:     }
357:   }
358: 
359:   const getAutomationBadgeColor = (level: string) => {
360:     switch (level) {
361:       case 'full': return 'bg-green-100 text-green-800'
362:       case 'partial': return 'bg-yellow-100 text-yellow-800'
363:       default: return 'bg-muted text-foreground'
364:     }
365:   }
366: 
367:   const getStatusBadgeColor = (status: string) => {
368:     switch (status) {
369:       case 'connected': return 'bg-green-100 text-green-800'
370:       case 'error': return 'bg-red-100 text-red-800'
371:       default: return 'bg-muted text-foreground'
372:     }
373:   }
374: 
375:   // Stats calculation
376:   const stats = {
377:     totalBoards: jobBoards.length,
378:     connectedBoards: jobBoards.filter(b => b.status === 'connected').length,
379:     totalApplications: applications.length,
380:     successfulApplications: applications.filter(a => a.status === 'offer').length,
381:     automationRate: Math.round((jobBoards.filter(b => b.automationLevel === 'full').length / jobBoards.length) * 100)
382:   }
383: 
384:   if (isLoading) {
385:     return (
386:       <div className="space-y-8">
387:         <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
388:           {[...Array(4)].map((_, i) => (
389:             <Card key={i}>
390:               <CardContent className="p-6">
391:                 <div className="animate-pulse">
392:                   <div className="w-16 h-4 bg-gray-200 rounded mb-2"></div>
393:                   <div className="w-8 h-8 bg-gray-200 rounded"></div>
394:                 </div>
395:               </CardContent>
396:             </Card>
397:           ))}
398:         </div>
399:         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
400:           {[...Array(6)].map((_, i) => (
401:             <Card key={i}>
402:               <CardContent className="p-6">
403:                 <div className="animate-pulse">
404:                   <div className="w-24 h-6 bg-gray-200 rounded mb-4"></div>
405:                   <div className="w-full h-20 bg-gray-200 rounded"></div>
406:                 </div>
407:               </CardContent>
408:             </Card>
409:           ))}
410:         </div>
411:       </div>
412:     )
413:   }
414: 
415:   return (
416:     <div className="space-y-8">
417:       {/* Stats Overview */}
418:       <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
419:         <Card>
420:           <CardContent className="p-6">
421:             <div className="flex items-center justify-between">
422:               <div>
423:                 <p className="text-sm font-medium text-muted-foreground">Connected Boards</p>
424:                 <p className="text-2xl font-bold">{stats.connectedBoards}/{stats.totalBoards}</p>
425:               </div>
426:               <Globe className="h-8 w-8 text-blue-600" />
427:             </div>
428:           </CardContent>
429:         </Card>
430: 
431:         <Card>
432:           <CardContent className="p-6">
433:             <div className="flex items-center justify-between">
434:               <div>
435:                 <p className="text-sm font-medium text-muted-foreground">Applications</p>
436:                 <p className="text-2xl font-bold">{stats.successfulApplications}/{stats.totalApplications}</p>
437:               </div>
438:               <Briefcase className="h-8 w-8 text-green-600" />
439:             </div>
440:           </CardContent>
441:         </Card>
442: 
443:         <Card>
444:           <CardContent className="p-6">
445:             <div className="flex items-center justify-between">
446:               <div>
447:                 <p className="text-sm font-medium text-muted-foreground">Automation Rate</p>
448:                 <p className="text-2xl font-bold">{stats.automationRate}%</p>
449:               </div>
450:               <Zap className="h-8 w-8 text-purple-600" />
451:             </div>
452:           </CardContent>
453:         </Card>
454: 
455:         <Card>
456:           <CardContent className="p-6">
457:             <div className="flex items-center justify-between">
458:               <div>
459:                 <p className="text-sm font-medium text-muted-foreground">Success Rate</p>
460:                 <p className="text-2xl font-bold">
461:                   {stats.totalApplications > 0
462:                     ? Math.round((stats.successfulApplications / stats.totalApplications) * 100)
463:                     : 0}%
464:                 </p>
465:               </div>
466:               <TrendingUp className="h-8 w-8 text-orange-600" />
467:             </div>
468:           </CardContent>
469:         </Card>
470:       </div>
471: 
472:       {/* Auto-Pilot Settings */}
473:       <Card>
474:         <CardHeader>
475:           <CardTitle className="flex items-center gap-2">
476:             <Zap className="h-5 w-5" />
477:             Auto-Pilot Mode
478:           </CardTitle>
479:           <CardDescription>
480:             Automatically find and apply to jobs matching your criteria
481:           </CardDescription>
482:         </CardHeader>
483:         <CardContent>
484:           {/* Autopilot status */}
485:           <div className="mb-3 text-sm text-foreground">
486:             <AutopilotStatus />
487:           </div>
488:           <div className="flex items-center justify-between mb-4">
489:             <div>
490:               <h4 className="font-medium">Enable Auto-Pilot</h4>
491:               <p className="text-sm text-muted-foreground">
492:                 Let Career Lever AI automatically find and apply to relevant positions
493:               </p>
494:             </div>
495:             <Button
496:               variant={autoPilotEnabled ? "default" : "outline"}
497:               onClick={() => setAutoPilotEnabled(!autoPilotEnabled)}
498:             >
499:               {autoPilotEnabled ? <Pause className="w-4 h-4 mr-2" /> : <Play className="w-4 h-4 mr-2" />}
500:               {autoPilotEnabled ? 'Disable' : 'Enable'} Auto-Pilot
501:             </Button>
502:           </div>
503: 
504:           {autoPilotEnabled && (
505:             <div className="grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-background rounded-lg">
506:               <div className="space-y-4">
507:                 <div>
508:                   <Label htmlFor="dailyLimit">Daily Application Limit</Label>
509:                   <Input
510:                     id="dailyLimit"
511:                     type="number"
512:                     value={autoPilotSettings.dailyLimit}
513:                     onChange={(e) => setAutoPilotSettings(prev => ({
514:                       ...prev,
515:                       dailyLimit: parseInt(e.target.value)
516:                     }))}
517:                     min="1"
518:                     max="50"
519:                   />
520:                 </div>
521:                 <div>
522:                   <Label htmlFor="keywords">Keywords</Label>
523:                   <Input
524:                     id="keywords"
525:                     value={autoPilotSettings.keywords}
526:                     onChange={(e) => setAutoPilotSettings(prev => ({
527:                       ...prev,
528:                       keywords: e.target.value
529:                     }))}
530:                     placeholder="e.g., software engineer, react, typescript"
531:                   />
532:                 </div>
533:               </div>
534:               <div className="space-y-4">
535:                 <div>
536:                   <Label htmlFor="locations">Locations</Label>
537:                   <Input
538:                     id="locations"
539:                     value={autoPilotSettings.locations}
540:                     onChange={(e) => setAutoPilotSettings(prev => ({
541:                       ...prev,
542:                       locations: e.target.value
543:                     }))}
544:                     placeholder="e.g., San Francisco, Remote, New York"
545:                   />
546:                 </div>
547:                 <div>
548:                   <Label>Salary Range</Label>
549:                   <div className="flex gap-2">
550:                     <Input
551:                       type="number"
552:                       placeholder="Min"
553:                       value={autoPilotSettings.salaryRange.min}
554:                       onChange={(e) => setAutoPilotSettings(prev => ({
555:                         ...prev,
556:                         salaryRange: { ...prev.salaryRange, min: parseInt(e.target.value) || 0 }
557:                       }))}
558:                     />
559:                     <Input
560:                       type="number"
561:                       placeholder="Max"
562:                       value={autoPilotSettings.salaryRange.max}
563:                       onChange={(e) => setAutoPilotSettings(prev => ({
564:                         ...prev,
565:                         salaryRange: { ...prev.salaryRange, max: parseInt(e.target.value) || 0 }
566:                       }))}
567:                     />
568:                   </div>
569:                 </div>
570:               </div>
571:             </div>
572:           )}
573: 
574:           {autoPilotEnabled && (
575:             <div className="mt-4 flex items-center gap-3">
576:               <Button disabled={autoPilotRunning} onClick={async () => {
577:                 setAutoPilotRunning(true)
578:                 setProgress({ percent: 5, stage: 'Preparing search…' })
579:                 try {
580:                   const controller = new AbortController()
581:                   const userTimeout = Math.max(30000, Math.min(180000, Number(autoPilotSettings.timeoutMs) || 120000))
582:                   const to = setTimeout(()=>controller.abort(), userTimeout)
583:                   // Faux staged progress while waiting (client-side only)
584:                   const start = Date.now()
585:                   const ticker = setInterval(() => {
586:                     const elapsed = Date.now() - start
587:                     const pct = Math.min(95, Math.round((elapsed / userTimeout) * 100))
588:                     const stage = pct < 30 ? 'Searching job boards…' : pct < 60 ? 'Aggregating listings…' : 'Finding contacts…'
589:                     setProgress({ percent: pct, stage })
590:                   }, 500)
591:                   const resp = await fetch('/api/job-boards/autopilot/search', {
592:                     method: 'POST', headers: { 'Content-Type': 'application/json' },
593:                     body: JSON.stringify({ 
594:                       keywords: autoPilotSettings.keywords, 
595:                       locations: autoPilotSettings.locations, 
596:                       radiusKm: 150, days: 30, limit: 20, timeoutMs: userTimeout,
597:                       mode: qualityMode,
598:                       filters
599:                     }),
600:                     signal: controller.signal
601:                   })
602:                   clearTimeout(to)
603:                   clearInterval(ticker)
604:                   const json = await resp.json()
605:                   if (!resp.ok || !json.success) throw new Error(json.error || 'Search failed')
606:                   setAutoPilotResults(json.results || [])
607:                   setProgress({ percent: 100, stage: 'Complete' })
608:                 } catch (e) {
609:                   toast.error(e instanceof Error ? e.message : 'Autopilot search failed')
610:                   setProgress({ percent: 0, stage: 'Idle' })
611:                 } finally {
612:                   setAutoPilotRunning(false)
613:                 }
614:               }}>
615:                 {autoPilotRunning ? (<><Loader2 className="w-4 h-4 mr-2 animate-spin"/> Searching...</>) : (<><Zap className="w-4 h-4 mr-2"/>Run Autopilot Search</>)}
616:               </Button>
617:               {autoPilotResults.length > 0 && (
618:                 <div className="text-sm text-muted-foreground">Found {autoPilotResults.length} public listings</div>
619:               )}
620:             </div>
621:           )}
622: 
623:           {autoPilotResults.length > 0 && (
624:             <div className="mt-4 border-t pt-4">
625:               <div className="text-sm font-medium mb-2">Public Listings</div>
626:               <div className="max-h-64 overflow-y-auto space-y-2">
627:                 {autoPilotResults.slice(0, 100).map((j, idx) => (
628:                   <div key={idx} className="text-xs flex items-center justify-between gap-2">
629:                     <div className="min-w-0">
630:                       <div className="font-medium truncate">{j.title || 'Untitled role'}</div>
631:                       <div className="text-muted-foreground truncate">{[j.company, j.location, j.source].filter(Boolean).join(' • ')}</div>
632:                     </div>
633:                     {j.url && <a href={j.url} target="_blank" rel="noopener noreferrer" className="px-2 py-1 border rounded">Open</a>}
634:                   </div>
635:                 ))}
636:               </div>
637:             </div>
638:           )}
639: 
640:           {/* Progress bar */}
641:           {autoPilotRunning || progress.percent > 0 ? (
642:             <div className="mt-3">
643:               <div className="flex items-center justify-between text-xs text-muted-foreground mb-1">
644:                 <span>{progress.stage}</span>
645:                 <span>{progress.percent}%</span>
646:               </div>
647:               <Progress value={progress.percent} className="w-full" />
648:             </div>
649:           ) : null}
650: 
651:           {/* Filters and Mode */}
652:           <div className="mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
653:             <div>
654:               <Label className="text-xs">Mode</Label>
655:               <Select value={qualityMode} onValueChange={(v)=>setQualityMode(v as any)}>
656:                 <SelectTrigger><SelectValue placeholder="Mode" /></SelectTrigger>
657:                 <SelectContent>
658:                   <SelectItem value="speed">Speed (Search/Sonar)</SelectItem>
659:                   <SelectItem value="quality">Quality (Sonar Pro/V2)</SelectItem>
660:                 </SelectContent>
661:               </Select>
662:             </div>
663:             <div>
664:               <Label className="text-xs">Work Type</Label>
665:               <Select value={filters.workType} onValueChange={(v)=>setFilters(p=>({ ...p, workType: v as any }))}>
666:                 <SelectTrigger><SelectValue placeholder="Any" /></SelectTrigger>
667:                 <SelectContent>
668:                   <SelectItem value="any">Any</SelectItem>
669:                   <SelectItem value="remote">Remote</SelectItem>
670:                   <SelectItem value="hybrid">Hybrid</SelectItem>
671:                   <SelectItem value="onsite">Onsite</SelectItem>
672:                 </SelectContent>
673:               </Select>
674:             </div>
675:             <div>
676:               <Label className="text-xs">Experience</Label>
677:               <Select value={filters.experienceLevel} onValueChange={(v)=>setFilters(p=>({ ...p, experienceLevel: v as any }))}>
678:                 <SelectTrigger><SelectValue placeholder="Any" /></SelectTrigger>
679:                 <SelectContent>
680:                   <SelectItem value="any">Any</SelectItem>
681:                   <SelectItem value="entry">Entry</SelectItem>
682:                   <SelectItem value="mid">Mid</SelectItem>
683:                   <SelectItem value="senior">Senior</SelectItem>
684:                   <SelectItem value="executive">Executive</SelectItem>
685:                 </SelectContent>
686:               </Select>
687:             </div>
688:             <div className="flex items-end gap-2">
689:               <div className="flex-1">
690:                 <Label className="text-xs">Min Salary (USD)</Label>
691:                 <Input type="number" placeholder="e.g., 80000" value={filters.salaryMin || ''} onChange={(e)=>setFilters(p=>({ ...p, salaryMin: e.target.value ? Number(e.target.value) : undefined }))} />
692:               </div>
693:               <div className="w-28">
694:                 <Label className="text-xs">Max Results</Label>
695:                 <Input type="number" value={filters.maxResults || 15} onChange={(e)=>setFilters(p=>({ ...p, maxResults: Math.max(5, Math.min(30, Number(e.target.value)||15)) }))} />
696:               </div>
697:             </div>
698:           </div>
699:         </CardContent>
700:       </Card>
701: 
702:       {/* Job Board integrations have moved to Settings → Integrations; no UI here by design */}
703: 
704:       {/* Bulk Actions */}
705:       <Card>
706:         <CardHeader>
707:           <CardTitle className="flex items-center gap-2">
708:             <Send className="h-5 w-5" />
709:             Bulk Application Submission
710:           </CardTitle>
711:           <CardDescription>
712:             Submit multiple applications to selected job boards at once
713:           </CardDescription>
714:         </CardHeader>
715:         <CardContent>
716:           {/* Application Selection */}
717:           <div className="mb-6">
718:             <h4 className="font-medium mb-3">Select Applications ({selectedApplications.length})</h4>
719:             <div className="grid grid-cols-1 md:grid-cols-2 gap-3 max-h-40 overflow-y-auto">
720:               {applications.slice(0, 10).map((app) => (
721:                 <div key={app._id} className="flex items-center space-x-3 p-3 border rounded-lg">
722:                   <Checkbox
723:                     checked={selectedApplications.includes(app._id)}
724:                     onCheckedChange={(checked) => handleApplicationSelection(app._id, checked as boolean)}
725:                   />
726:                   <div className="flex-1 min-w-0">
727:                     <p className="text-sm font-medium truncate">{app.jobTitle}</p>
728:                     <p className="text-xs text-muted-foreground truncate">{app.company}</p>
729:                   </div>
730:                   <Badge variant={app.status === 'submitted' ? 'default' : 'outline'} className="text-xs">
731:                     {app.status}
732:                   </Badge>
733:                 </div>
734:               ))}
735:             </div>
736:           </div>
737: 
738:           {/* Progress and Actions */}
739:           {bulkSubmission.status === 'running' && (
740:             <div className="mb-6">
741:               <div className="flex justify-between text-sm mb-2">
742:                 <span>Submission Progress</span>
743:                 <span>{Math.round(bulkSubmission.progress)}%</span>
744:               </div>
745:               <Progress value={bulkSubmission.progress} className="h-2 mb-2" />
746:               <p className="text-xs text-muted-foreground">
747:                 Submitting {bulkSubmission.selectedApplications.length} applications to {bulkSubmission.selectedBoards.length} job boards...
748:               </p>
749:             </div>
750:           )}
751: 
752:           <div className="flex gap-4">
753:             <Button
754:               onClick={handleBulkSubmit}
755:               disabled={
756:                 selectedBoards.length === 0 ||
757:                 selectedApplications.length === 0 ||
758:                 bulkSubmission.status === 'running'
759:               }
760:               className="flex-1"
761:             >
762:               {bulkSubmission.status === 'running' ? (
763:                 <>
764:                   <Loader2 className="w-4 h-4 mr-2 animate-spin" />
765:                   Submitting...
766:                 </>
767:               ) : (
768:                 <>
769:                   <Send className="w-4 h-4 mr-2" />
770:                   Submit {selectedApplications.length} Applications
771:                 </>
772:               )}
773:             </Button>
774: 
775:             <Button
776:               variant="outline"
777:               onClick={() => {
778:                 setSelectedBoards([])
779:                 setSelectedApplications([])
780:               }}
781:               disabled={bulkSubmission.status === 'running'}
782:             >
783:               Clear Selection
784:             </Button>
785:           </div>
786: 
787:           {bulkSubmission.status === 'completed' && bulkSubmission.results && (
788:             <Alert className="mt-4">
789:               <CheckCircle className="h-4 w-4" />
790:               <AlertDescription>
791:                 Bulk submission completed! {bulkSubmission.results.filter(r => r.success).length} successful submissions out of {bulkSubmission.results.length} attempts.
792:               </AlertDescription>
793:             </Alert>
794:           )}
795: 
796:           {bulkSubmission.status === 'failed' && (
797:             <Alert className="mt-4">
798:               <AlertTriangle className="h-4 w-4" />
799:               <AlertDescription>
800:                 Bulk submission failed. Please try again or contact support if the issue persists.
801:               </AlertDescription>
802:             </Alert>
803:           )}
804:         </CardContent>
805:       </Card>
806: 
807:       {/* Recent Activity */}
808:       <Card>
809:         <CardHeader>
810:           <CardTitle className="flex items-center gap-2">
811:             <Clock className="h-5 w-5" />
812:             Recent Activity
813:           </CardTitle>
814:           <CardDescription>
815:             Latest application submissions and job board activity
816:           </CardDescription>
817:         </CardHeader>
818:         <CardContent>
819:           <div className="space-y-4">
820:             {applications.slice(0, 5).map((app) => (
821:               <div key={app._id} className="flex items-center justify-between p-3 border rounded-lg">
822:                 <div className="flex items-center gap-3">
823:                   <div className={`w-3 h-3 rounded-full ${
824:                     app.status === 'submitted' ? 'bg-green-500' :
825:                     app.status === 'draft' ? 'bg-yellow-500' : 'bg-gray-500'
826:                   }`} />
827:                   <div>
828:                     <p className="font-medium">{app.jobTitle}</p>
829:                     <p className="text-sm text-muted-foreground">{app.company}</p>
830:                   </div>
831:                 </div>
832:                 <div className="text-right">
833:                   <Badge variant={app.status === 'submitted' ? 'default' : 'outline'}>
834:                     {app.status}
835:                   </Badge>
836:                   <p className="text-xs text-muted-foreground mt-1">
837:                     {new Date(app.createdAt).toLocaleDateString()}
838:                   </p>
839:                 </div>
840:               </div>
841:             ))}
842:           </div>
843:         </CardContent>
844:       </Card>
845:     </div>
846:   )
847: }
848: 
849: function AutopilotStatus() {
850:   const [status, setStatus] = useState<{ lastRunAt?: string; lastFound?: number; nextRunAt?: string } | null>(null)
851:   useEffect(() => {
852:     (async () => {
853:       try {
854:         const res = await fetch('/api/profile')
855:         if (!res.ok) return
856:         const j = await res.json()
857:         const meta = j?.profile?.autopilotMeta || {}
858:         setStatus({
859:           lastRunAt: meta.lastRunAt,
860:           lastFound: meta.lastFound,
861:           nextRunAt: meta.nextRunAt,
862:         })
863:       } catch {}
864:     })()
865:   }, [])
866:   if (!status) return null
867:   return (
868:     <div className="flex items-center gap-4">
869:       <div>Last run: {status.lastRunAt ? new Date(status.lastRunAt).toLocaleString() : '—'}</div>
870:       <div>Found: {typeof status.lastFound === 'number' ? status.lastFound : 0}</div>
871:       <div>Next run: {status.nextRunAt ? new Date(status.nextRunAt).toLocaleString() : '—'}</div>
872:     </div>
873:   )
874: }
</file>

<file path="src/lib/agents/perplexity-career-agent.ts">
  1: /**
  2:  * Perplexity Career Agent
  3:  * 
  4:  * Intelligent agent that uses function calling to reliably gather job/company intelligence
  5:  * This is the "brain" - it decides which tools to use and when
  6:  * 
  7:  * Reliability: 95%+ (vs 80-85% with prompts alone)
  8:  */
  9: 
 10: import { PerplexityService } from '../perplexity-service'
 11: import { CAREER_AGENT_TOOLS } from './agent-tools'
 12: import { AgentToolHandlers, ToolResult } from './agent-handlers'
 13: 
 14: interface AgentMessage {
 15:   role: 'user' | 'assistant' | 'tool'
 16:   content: string
 17:   tool_calls?: any[]
 18:   tool_call_id?: string
 19:   name?: string
 20: }
 21: 
 22: export class PerplexityCareerAgent {
 23:   private apiKey: string
 24:   private conversationHistory: AgentMessage[] = []
 25:   private readonly MAX_ITERATIONS = 15
 26:   private readonly TIMEOUT_MS = 120000 // 2 minutes total
 27: 
 28:   constructor(apiKey: string) {
 29:     if (!apiKey) {
 30:       throw new Error('Perplexity API key is required for agent')
 31:     }
 32:     this.apiKey = apiKey
 33:   }
 34: 
 35:   /**
 36:    * Main agent execution loop
 37:    * The agent will use tools iteratively until it has enough information
 38:    */
 39:   async run(userQuery: string): Promise<{
 40:     success: boolean
 41:     data: any
 42:     iterations: number
 43:     tools_used: string[]
 44:     duration_ms: number
 45:   }> {
 46:     const startTime = Date.now()
 47:     const toolsUsed: string[] = []
 48: 
 49:     console.log(`\n${'='.repeat(60)}`)
 50:     console.log(`[AGENT] Starting: "${userQuery}"`)
 51:     console.log(`${'='.repeat(60)}\n`)
 52: 
 53:     // Initialize conversation
 54:     this.conversationHistory = [{
 55:       role: 'user',
 56:       content: this.buildSystemPrompt() + '\n\n' + userQuery
 57:     }]
 58: 
 59:     let iteration = 0
 60: 
 61:     try {
 62:       while (iteration < this.MAX_ITERATIONS) {
 63:         iteration++
 64: 
 65:         if (Date.now() - startTime > this.TIMEOUT_MS) {
 66:           throw new Error('Agent timeout - exceeded maximum execution time')
 67:         }
 68: 
 69:         console.log(`\n--- ITERATION ${iteration} ---\n`)
 70: 
 71:         // Call Perplexity with tools
 72:         const response = await this.callPerplexityWithTools()
 73: 
 74:         const assistantMessage = response.choices[0].message
 75: 
 76:         // Check if AI wants to use tools
 77:         if (assistantMessage.tool_calls && assistantMessage.tool_calls.length > 0) {
 78:           console.log(`[AGENT] AI calling ${assistantMessage.tool_calls.length} tool(s)`)
 79: 
 80:           // Add assistant message to history
 81:           this.conversationHistory.push({
 82:             role: 'assistant',
 83:             content: assistantMessage.content || '',
 84:             tool_calls: assistantMessage.tool_calls
 85:           })
 86: 
 87:           // Execute all tool calls in parallel
 88:           const toolResults = await Promise.all(
 89:             assistantMessage.tool_calls.map(async (toolCall: any) => {
 90:               const toolName = toolCall.function.name
 91:               const toolArgs = JSON.parse(toolCall.function.arguments)
 92: 
 93:               toolsUsed.push(toolName)
 94: 
 95:               const result = await this.executeToolCall(toolName, toolArgs)
 96: 
 97:               // Add tool result to conversation
 98:               this.conversationHistory.push({
 99:                 role: 'tool',
100:                 content: JSON.stringify(result),
101:                 tool_call_id: toolCall.id,
102:                 name: toolName
103:               })
104: 
105:               return result
106:             })
107:           )
108: 
109:           console.log(`[AGENT] ${toolResults.filter(r => r.success).length}/${toolResults.length} tools succeeded`)
110: 
111:         } else {
112:           // No more tool calls - AI is done
113:           console.log(`\n[AGENT] ✓ Completed in ${iteration} iterations, ${Date.now() - startTime}ms\n`)
114: 
115:           // Parse final answer
116:           const finalData = this.parseFinalAnswer(assistantMessage.content)
117: 
118:           return {
119:             success: true,
120:             data: finalData,
121:             iterations: iteration,
122:             tools_used: [...new Set(toolsUsed)],
123:             duration_ms: Date.now() - startTime
124:           }
125:         }
126:       }
127: 
128:       throw new Error(`Max iterations (${this.MAX_ITERATIONS}) reached`)
129: 
130:     } catch (error) {
131:       console.error(`[AGENT] Error:`, (error as Error).message)
132: 
133:       return {
134:         success: false,
135:         data: { error: (error as Error).message },
136:         iterations: iteration,
137:         tools_used: toolsUsed,
138:         duration_ms: Date.now() - startTime
139:       }
140:     }
141:   }
142: 
143:   /**
144:    * Calls Perplexity API with function calling
145:    */
146:   private async callPerplexityWithTools(): Promise<any> {
147:     const response = await fetch('https://api.perplexity.ai/chat/completions', {
148:       method: 'POST',
149:       headers: {
150:         'Authorization': `Bearer ${this.apiKey}`,
151:         'Content-Type': 'application/json'
152:       },
153:       body: JSON.stringify({
154:         model: 'sonar-pro',
155:         messages: this.conversationHistory,
156:         tools: CAREER_AGENT_TOOLS,
157:         tool_choice: 'auto',
158:         temperature: 0.3,
159:         max_tokens: 4096
160:       })
161:     })
162: 
163:     if (!response.ok) {
164:       const errorText = await response.text()
165:       throw new Error(`Perplexity API error: ${response.statusText} - ${errorText}`)
166:     }
167: 
168:     return await response.json()
169:   }
170: 
171:   /**
172:    * Executes a tool call
173:    */
174:   private async executeToolCall(toolName: string, toolArgs: Record<string, any>): Promise<ToolResult> {
175:     const argsPreview = JSON.stringify(toolArgs).substring(0, 100)
176:     console.log(`[TOOL] Executing: ${toolName}(${argsPreview}...)`)
177: 
178:     try {
179:       switch (toolName) {
180:         case 'search_job_boards':
181:           return await AgentToolHandlers.search_job_boards(
182:             toolArgs.job_title,
183:             toolArgs.location,
184:             toolArgs.max_results
185:           )
186: 
187:         case 'scrape_job_posting':
188:           return await AgentToolHandlers.scrape_job_posting(
189:             toolArgs.url,
190:             toolArgs.company_name
191:           )
192: 
193:         case 'search_linkedin_profiles':
194:           return await AgentToolHandlers.search_linkedin_profiles(
195:             toolArgs.company_name,
196:             toolArgs.role_keywords
197:           )
198: 
199:         case 'verify_company_website':
200:           return await AgentToolHandlers.verify_company_website(
201:             toolArgs.company_name,
202:             toolArgs.website_url
203:           )
204: 
205:         case 'validate_email':
206:           return await AgentToolHandlers.validate_email(
207:             toolArgs.email,
208:             toolArgs.company_domain
209:           )
210: 
211:         case 'get_company_intelligence':
212:           return await AgentToolHandlers.get_company_intelligence(
213:             toolArgs.company_name
214:           )
215: 
216:         default:
217:           return {
218:             success: false,
219:             error: `Unknown tool: ${toolName}`
220:           }
221:       }
222:     } catch (error) {
223:       return {
224:         success: false,
225:         error: (error as Error).message
226:       }
227:     }
228:   }
229: 
230:   /**
231:    * System prompt that guides agent behavior
232:    */
233:   private buildSystemPrompt(): string {
234:     return `You are an intelligent career research agent. Your job: find job opportunities and hiring contacts with 95%+ accuracy.
235: 
236: CRITICAL RULES:
237: 1. ALWAYS use tools to gather information - NEVER make up data
238: 2. When searching jobs, use search_job_boards first, then scrape_job_posting for each promising job
239: 3. When finding contacts, use search_linkedin_profiles, then validate_email for each
240: 4. NEVER include jobs from "Confidential" companies
241: 5. NEVER include personal emails (gmail, yahoo, etc)
242: 6. If a tool fails, try alternate approaches (e.g., verify_company_website if LinkedIn fails)
243: 7. Return structured JSON at the end with all gathered data
244: 
245: WORKFLOW FOR JOBS:
246: 1. search_job_boards(job_title, location) → Get list of job URLs
247: 2. For top 10-20 jobs: scrape_job_posting(url) → Get full descriptions
248: 3. Filter out any Confidential companies
249: 4. Return jobs array with full descriptions
250: 
251: WORKFLOW FOR CONTACTS:
252: 1. search_linkedin_profiles(company, ["recruiter", "talent acquisition", "HR"]) → Get LinkedIn profiles
253: 2. verify_company_website(company) → Get official emails from website
254: 3. For each email: validate_email(email, company_domain) → Verify it's real
255: 4. Return ONLY verified contacts (confidence > 0.8)
256: 5. If NO verified contacts found, return empty array with helpful message
257: 
258: QUALITY STANDARDS:
259: - Job descriptions must be > 150 characters
260: - Contacts must have LinkedIn URL OR verified email
261: - NO inferred/pattern emails unless verified
262: - Explain your reasoning as you work
263: 
264: Always be thorough but efficient. Use tools in parallel when possible.`
265:   }
266: 
267:   /**
268:    * Parses final answer from AI
269:    */
270:   private parseFinalAnswer(content: string): any {
271:     try {
272:       // Try to extract JSON from markdown code blocks
273:       const codeBlockMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/)
274:       if (codeBlockMatch) {
275:         return JSON.parse(codeBlockMatch[1])
276:       }
277: 
278:       // Try to extract raw JSON
279:       const jsonMatch = content.match(/\{[\s\S]*\}/)
280:       if (jsonMatch) {
281:         return JSON.parse(jsonMatch[0])
282:       }
283: 
284:       // Fallback: return raw content
285:       return { result: content }
286:     } catch (error) {
287:       console.warn('[AGENT] Could not parse JSON, returning raw content')
288:       return { result: content }
289:     }
290:   }
291: }
</file>

<file path="src/lib/canadian-job-scraper.ts">
 1: import { PerplexityIntelligenceService } from './perplexity-intelligence'
 2: 
 3: export async function scrapeJobBankCanada(keywords: string, location: string, limit: number = 20) {
 4:   const query = `${keywords} ${location} site:jobbank.gc.ca`
 5:   try {
 6:     console.log('[SCRAPER] Job Bank query:', query)
 7:     const results = await PerplexityIntelligenceService.jobQuickSearch(
 8:       query,
 9:       ['jobbank.gc.ca'],
10:       limit,
11:       'week' // Recent jobs
12:     )
13:     console.log('[SCRAPER] Job Bank results:', results.length)
14:     return results.map(r => ({
15:       ...r,
16:       source: 'Job Bank Canada',
17:       country: 'CA'
18:     }))
19:   } catch (error) {
20:     console.error('[SCRAPER] Job Bank failed:', error)
21:     return []
22:   }
23: }
24: 
25: export async function scrapeIndeedCanada(keywords: string, location: string, limit: number = 20) {
26:   const query = `${keywords} ${location} site:ca.indeed.com`
27:   try {
28:     console.log('[SCRAPER] Indeed query:', query)
29:     const results = await PerplexityIntelligenceService.jobQuickSearch(
30:       query,
31:       ['ca.indeed.com'],
32:       limit,
33:       'week'
34:     )
35:     console.log('[SCRAPER] Indeed results:', results.length)
36:     return results.map(r => ({
37:       ...r,
38:       source: 'Indeed.ca',
39:       country: 'CA'
40:     }))
41:   } catch (error) {
42:     console.error('[SCRAPER] Indeed failed:', error)
43:     return []
44:   }
45: }
46: 
47: export async function scrapeCanadianJobs(keywords: string[], location: string) {
48:   const allKeywords = keywords.join(' ')
49:   const [jobBank, indeed] = await Promise.all([
50:     scrapeJobBankCanada(allKeywords, location),
51:     scrapeIndeedCanada(allKeywords, location)
52:   ])
53:   const combined = [...jobBank, ...indeed]
54:   // Dedupe by title + company
55:   const unique = combined.filter((job, index, self) =>
56:     index === self.findIndex(j => j.title === job.title && j.company === job.company)
57:   )
58:   console.log('[SCRAPER] Total unique Canadian jobs:', unique.length)
59:   return unique.slice(0, 30) // Limit total
60: }
</file>

<file path="src/lib/job-deduplication.ts">
 1: /**
 2:  * Job Deduplication Utilities
 3:  * Fixes ISSUE #1: Infinite loop with 9x duplicate saves
 4:  */
 5: 
 6: export interface Job {
 7:   id?: string
 8:   title: string
 9:   company: string
10:   location: string
11:   url?: string
12:   salary?: string
13:   skills?: string[]
14:   skillMatchPercent?: number
15:   aiScore?: number
16:   [key: string]: unknown
17: }
18: 
19: /**
20:  * Create unique hash for job based on company + title
21:  */
22: function createJobHash(job: Job): string {
23:   const company = job.company.toLowerCase().trim()
24:   const title = job.title.toLowerCase().trim()
25:   return `${company}::${title}`
26: }
27: 
28: /**
29:  * Deduplicate jobs array
30:  * Returns only unique jobs based on company + title
31:  */
32: export function deduplicateJobs(jobs: Job[]): Job[] {
33:   const seen = new Set<string>()
34:   const unique: Job[] = []
35:   let duplicateCount = 0
36: 
37:   for (const job of jobs) {
38:     const hash = createJobHash(job)
39:     
40:     if (seen.has(hash)) {
41:       duplicateCount++
42:       console.log(`[DEDUPE] ❌ Removing duplicate: ${job.title} @ ${job.company}`)
43:       continue
44:     }
45:     
46:     seen.add(hash)
47:     unique.push(job)
48:   }
49: 
50:   console.log(`[DEDUPE] ✅ Removed ${duplicateCount} duplicates, kept ${unique.length} unique jobs`)
51:   
52:   return unique
53: }
54: 
55: /**
56:  * Check if job already exists in array
57:  */
58: export function isDuplicateJob(job: Job, existingJobs: Job[]): boolean {
59:   const hash = createJobHash(job)
60:   return existingJobs.some(existing => createJobHash(existing) === hash)
61: }
62: 
63: /**
64:  * Merge duplicate jobs, keeping the one with more data
65:  */
66: export function mergeJobs(jobs: Job[]): Job[] {
67:   const jobMap = new Map<string, Job>()
68: 
69:   for (const job of jobs) {
70:     const hash = createJobHash(job)
71:     const existing = jobMap.get(hash)
72: 
73:     if (!existing) {
74:       jobMap.set(hash, job)
75:       continue
76:     }
77: 
78:     // Keep job with more fields populated
79:     const existingFields = Object.values(existing).filter(v => v != null).length
80:     const newFields = Object.values(job).filter(v => v != null).length
81: 
82:     if (newFields > existingFields) {
83:       console.log(`[DEDUPE] 🔄 Replacing with more complete version: ${job.title}`)
84:       jobMap.set(hash, job)
85:     }
86:   }
87: 
88:   return Array.from(jobMap.values())
89: }
</file>

<file path="src/lib/job-scraper.ts">
 1: import { PerplexityIntelligenceService } from '@/lib/perplexity-intelligence'
 2: 
 3: export async function scrapeJobBankCanada(keywords: string, location: string) {
 4:   try {
 5:     const q = `site:jobbank.gc.ca ${keywords} ${location}`
 6:     return await PerplexityIntelligenceService.jobQuickSearch(q, ['jobbank.gc.ca'], 15, 'week')
 7:   } catch (error) {
 8:     console.error('Job Bank scraping failed:', error)
 9:     return []
10:   }
11: }
12: 
13: export async function scrapeIndeedCanada(keywords: string, location: string) {
14:   try {
15:     const q = `site:ca.indeed.com ${keywords} ${location}`
16:     return await PerplexityIntelligenceService.jobQuickSearch(q, ['ca.indeed.com'], 15, 'week')
17:   } catch (error) {
18:     console.error('Indeed scraping failed:', error)
19:     return []
20:   }
21: }
</file>

<file path="src/lib/perplexity-job-search.ts">
  1: import { PerplexityIntelligenceService } from './perplexity-intelligence'
  2: 
  3: // Define proper types (exported for reuse)
  4: export interface Job {
  5:   title: string
  6:   company: string
  7:   location: string
  8:   description: string
  9:   url: string
 10:   salary?: string | undefined
 11:   postedDate?: string
 12:   source: string
 13:   workType?: 'Full-time' | 'Part-time' | 'Contract' | 'Remote'
 14:   experienceLevel?: 'entry' | 'mid' | 'senior'
 15:   isCanadian: boolean
 16:   matchScore: number
 17:   jobId: string
 18: }
 19: 
 20: export interface JobSearchOptions {
 21:   experienceLevel?: 'entry' | 'mid' | 'senior'
 22:   remote?: boolean
 23:   salaryMin?: number
 24:   limit?: number
 25: }
 26: 
 27: export interface JobMarketAnalysis {
 28:   demand: 'high' | 'medium' | 'low'
 29:   averageSalary: { min: number; max: number; currency: string }
 30:   topSkills: string[]
 31:   topCompanies: string[]
 32:   growthTrend: 'increasing' | 'stable' | 'declining'
 33:   totalOpenings: number
 34: }
 35: 
 36: export class PerplexityJobSearchService {
 37:   
 38:   private static readonly JOB_BOARDS = [
 39:     { name: 'Job Bank Canada', domain: 'jobbank.gc.ca', isCanadian: true },
 40:     { name: 'Indeed Canada', domain: 'ca.indeed.com', isCanadian: true },
 41:     { name: 'LinkedIn Jobs', domain: 'linkedin.com/jobs', isCanadian: false },
 42:     { name: 'Workopolis', domain: 'workopolis.com', isCanadian: true },
 43:     { name: 'Glassdoor Canada', domain: 'glassdoor.ca', isCanadian: true }
 44:   ] as const
 45:   
 46:   // FIXED: Parallel API calls, dynamic dates, proper types
 47:   static async searchCanadianJobs(
 48:     keywords: string, 
 49:     location: string, 
 50:     options: JobSearchOptions = {}
 51:   ): Promise<Job[]> {
 52:     const startTime = Date.now()
 53:     const { experienceLevel, remote, salaryMin, limit = 25 } = options
 54:     
 55:     // Dynamic date filter (last 30 days)
 56:     const dateFilter = this.getDateFilter(30)
 57:     
 58:     // Build search queries
 59:     const queries = this.JOB_BOARDS.map(board => {
 60:       let query = `site:${board.domain} "${keywords}" "${location}" ${dateFilter}` 
 61:       
 62:       if (experienceLevel) query += ` "${experienceLevel} level"` 
 63:       if (remote) query += ` "remote"` 
 64:       if (salaryMin) query += ` salary:>${salaryMin}` 
 65:       
 66:       return { query, board }
 67:     })
 68:     
 69:     // PARALLEL API CALLS
 70:     const results = await Promise.allSettled(
 71:       queries.map(({ query, board }) => 
 72:         this.fetchJobsFromQuery(query, board.name, Math.ceil(limit / queries.length))
 73:       )
 74:     )
 75:     
 76:     // Collect all successful results
 77:     const allJobs: Job[] = []
 78:     results.forEach((result, index) => {
 79:       if (result.status === 'fulfilled') {
 80:         allJobs.push(...result.value)
 81:         console.log(`[${queries[index].board.name}] Found ${result.value.length} jobs`)
 82:       } else {
 83:         console.error(`[${queries[index].board.name}] Failed:`, result.reason)
 84:       }
 85:     })
 86:     
 87:     const finalJobs = this.deduplicateAndRank(allJobs, limit)
 88:     
 89:     // Performance metrics
 90:     const duration = Date.now() - startTime
 91:     console.log(`[PERPLEXITY_JOB_SEARCH] Completed in ${duration}ms. Found ${allJobs.length} total, returned ${finalJobs.length} after dedup/ranking`)
 92:     
 93:     return finalJobs
 94:   }
 95:   
 96:   // FIXED: Proper job market analysis method
 97:   static async analyzeJobMarket(
 98:     keywords: string, 
 99:     location: string
100:   ): Promise<JobMarketAnalysis | null> {
101:     const query = `
102:       Analyze the job market for "${keywords}" roles in "${location}", Canada:
103:       1. Current demand level (high/medium/low)
104:       2. Average salary range in CAD
105:       3. Top 5 in-demand skills for this role
106:       4. Top 5 companies actively hiring
107:       5. Market growth trend (increasing/stable/declining)
108:       6. Total estimated open positions
109:       
110:       Return as JSON:
111:       {
112:         "demand": "high",
113:         "averageSalary": {"min": 75000, "max": 95000, "currency": "CAD"},
114:         "topSkills": ["skill1", "skill2", ...],
115:         "topCompanies": ["company1", "company2", ...],
116:         "growthTrend": "increasing",
117:         "totalOpenings": 150
118:       }
119:     `
120:     
121:     try {
122:       // FIXED: Use correct method from PerplexityIntelligenceService
123:       const response = await PerplexityIntelligenceService.customQuery({
124:         systemPrompt: 'You are a labor market analyst. Return only valid JSON with no markdown.',
125:         userPrompt: query,
126:         temperature: 0.2,
127:         maxTokens: 2000
128:       })
129:       
130:       // Parse JSON response
131:       let content = typeof response === 'string' ? response : (response as any).content || JSON.stringify(response)
132:       
133:       // Remove markdown code blocks
134:       content = content.replace(/```(?:json)?\s*/g, '')
135:       
136:       const jsonMatch = content.match(/\{[\s\S]*\}/)
137:       if (jsonMatch) {
138:         return JSON.parse(jsonMatch[0])
139:       }
140:     } catch (error) {
141:       console.error('Job market analysis failed:', error)
142:     }
143:     
144:     return null
145:   }
146:   
147:   // FIXED: Proper job details extraction
148:   static async getJobDetails(jobUrl: string): Promise<Partial<Job> | null> {
149:     const query = `
150:       Extract complete job details from ${jobUrl}:
151:       - Title
152:       - Company name
153:       - Location
154:       - Salary/compensation
155:       - Required experience
156:       - Key responsibilities (top 5)
157:       - Required skills
158:       - Benefits
159:       - Application deadline
160:       
161:       Return as JSON.
162:     `
163:     
164:     try {
165:       const hostname = new URL(jobUrl).hostname
166:       const results = await PerplexityIntelligenceService.jobQuickSearch(
167:         query,
168:         [hostname],
169:         1,
170:         'day'
171:       )
172:       
173:       if (results && results.length > 0) {
174:         return this.parseJobDetails(results[0], jobUrl)
175:       }
176:     } catch (error) {
177:       console.error('Job details extraction failed:', error)
178:     }
179:     
180:     return null
181:   }
182:   
183:   // HELPER: Fetch jobs from single query
184:   // FIXED: Handle unknown result structure
185:   private static async fetchJobsFromQuery(
186:     query: string, 
187:     source: string, 
188:     limit: number
189:   ): Promise<Job[]> {
190:     try {
191:       const results = await PerplexityIntelligenceService.jobQuickSearch(
192:         query,
193:         [], // Auto-detect domains
194:         limit,
195:         'week'
196:       )
197:       
198:       if (!results || !Array.isArray(results)) {
199:         console.warn(`Invalid results from query: ${query}`)
200:         return []
201:       }
202:       
203:       return results.map((result: any) => ({
204:         title: result.title || result.name || 'Unknown Title',
205:         company: this.extractCompany(result.snippet || result.description || ''),
206:         location: this.extractLocation(result.snippet || result.description || ''),
207:         description: result.snippet || result.description || '',
208:         url: result.url || result.link || '',
209:         salary: this.extractSalary(`${result.title || ''} ${result.snippet || ''}`) || undefined,
210:         postedDate: result.postedDate || result.date || result.published,
211:         source,
212:         isCanadian: this.isCanadianJobSite(result.url || result.link || ''),
213:         matchScore: 0, // Will be calculated in deduplicateAndRank
214:         jobId: this.generateJobId(result.url || result.link || '')
215:       }))
216:     } catch (error) {
217:       console.error(`Query failed: ${query}`, error)
218:       return []
219:     }
220:   }
221:   
222:   // FIXED: Deterministic ranking, no random scores
223:   private static deduplicateAndRank(jobs: Job[], limit: number): Job[] {
224:     if (jobs.length === 0) {
225:       console.warn('[PERPLEXITY_JOB_SEARCH] No jobs to process')
226:       return []
227:     }
228:     
229:     // Deduplicate by URL
230:     const uniqueJobs = new Map<string, Job>()
231:     jobs.forEach(job => {
232:       if (!uniqueJobs.has(job.url)) {
233:         uniqueJobs.set(job.url, {
234:           ...job,
235:           matchScore: this.calculateMatchScore(job)
236:         })
237:       }
238:     })
239:     
240:     // Sort by: Canadian first, then match score, then date
241:     const sortedJobs = Array.from(uniqueJobs.values()).sort((a, b) => {
242:       if (a.isCanadian && !b.isCanadian) return -1
243:       if (b.isCanadian && !a.isCanadian) return 1
244:       if (Math.abs(a.matchScore - b.matchScore) > 5) {
245:         return b.matchScore - a.matchScore
246:       }
247:       // Tie-breaker: most recent
248:       if (a.postedDate && b.postedDate) {
249:         return new Date(b.postedDate).getTime() - new Date(a.postedDate).getTime()
250:       }
251:       return 0
252:     })
253:     
254:     return sortedJobs.slice(0, limit)
255:   }
256:   
257:   // FIXED: Deterministic scoring based on actual relevance
258:   private static calculateMatchScore(job: Job): number {
259:     let score = 50 // Base score
260:     
261:     const content = `${job.title} ${job.description} ${job.location}`.toLowerCase()
262:     
263:     // Recency (up to +30 points)
264:     if (job.postedDate) {
265:       const daysAgo = this.getDaysAgo(job.postedDate)
266:       if (daysAgo <= 1) score += 30
267:       else if (daysAgo <= 3) score += 25
268:       else if (daysAgo <= 7) score += 20
269:       else if (daysAgo <= 14) score += 10
270:     }
271:     
272:     // Job type (+15 points for full-time)
273:     if (/\b(?:full.?time|permanent|career)\b/i.test(content)) score += 15
274:     
275:     // Canadian location (+10 points)
276:     if (/\b(?:canada|canadian|toronto|vancouver|montreal|calgary|ottawa)\b/i.test(content)) {
277:       score += 10
278:     }
279:     
280:     // Salary transparency (+10 points)
281:     if (job.salary) score += 10
282:     
283:     // Description quality (+5 points for detailed descriptions)
284:     if (job.description && job.description.length > 200) score += 5
285:     
286:     return Math.min(100, score)
287:   }
288:   
289:   // HELPER: Shared salary extraction (no duplication)
290:   private static extractSalary(text: string): string | null {
291:     const salaryRegex = /\$[\d,]+(?:\s*-\s*\$?[\d,]+)?(?:\s*(?:per|\/)\s*(?:hour|year|annum))?/i
292:     const match = text.match(salaryRegex)
293:     return match ? match[0] : null
294:   }
295:   
296:   // HELPER: Dynamic date filter
297:   private static getDateFilter(days: number): string {
298:     const date = new Date()
299:     date.setDate(date.getDate() - days)
300:     return `after:${date.toISOString().split('T')[0]}` 
301:   }
302:   
303:   // FIXED: Handle invalid dates
304:   private static getDaysAgo(dateString: string): number {
305:     const posted = new Date(dateString)
306:     
307:     if (isNaN(posted.getTime())) {
308:       console.warn(`Invalid date: ${dateString}`)
309:       return 999 // Return high number to deprioritize
310:     }
311:     
312:     const now = new Date()
313:     const diffMs = now.getTime() - posted.getTime()
314:     return Math.floor(diffMs / (1000 * 60 * 60 * 24))
315:   }
316:   
317:   // HELPER: Check if Canadian job site
318:   private static isCanadianJobSite(url: string): boolean {
319:     return /jobbank\.gc\.ca|indeed\.ca|workopolis\.com|glassdoor\.ca/i.test(url)
320:   }
321:   
322:   // FIXED: Universal hash function (no crypto/Buffer dependency)
323:   private static generateJobId(url: string): string {
324:     let hash = 0
325:     for (let i = 0; i < url.length; i++) {
326:       const char = url.charCodeAt(i)
327:       hash = ((hash << 5) - hash) + char
328:       hash = hash & hash // Convert to 32bit integer
329:     }
330:     return `job-${Math.abs(hash).toString(36).padStart(16, '0').substring(0, 16)}`
331:   }
332:   
333:   // HELPER: Parse job details from Perplexity response
334:   private static parseJobDetails(result: any, url: string): Partial<Job> {
335:     const text = `${result.title || ''} ${result.snippet || ''}` 
336:     
337:     return {
338:       title: result.title || 'Unknown Title',
339:       company: this.extractCompany(text),
340:       location: this.extractLocation(text),
341:       salary: this.extractSalary(text) || undefined,
342:       description: result.snippet || '',
343:       url: url,
344:       source: this.extractSourceName(url)
345:     }
346:   }
347:   
348:   // HELPER: Extract company name
349:   private static extractCompany(text: string): string {
350:     const patterns = [
351:       /at\s+([A-Z][a-zA-Z\s&]+?)(?:\s+is\s+|\s+seeks\s+|\.|,)/,
352:       /([A-Z][a-zA-Z\s&]+?)\s+is\s+(?:hiring|seeking|looking)/
353:     ]
354:     
355:     for (const pattern of patterns) {
356:       const match = text.match(pattern)
357:       if (match) return match[1].trim()
358:     }
359:     
360:     return 'Unknown Company'
361:   }
362:   
363:   // HELPER: Extract location
364:   private static extractLocation(text: string): string {
365:     const locationPattern = /(?:in|at|located)\s+([A-Z][a-zA-Z\s,]+?(?:,\s*[A-Z]{2})?)\b/
366:     const match = text.match(locationPattern)
367:     return match ? match[1].trim() : 'Location Not Specified'
368:   }
369:   
370:   // HELPER: Extract source name from URL
371:   private static extractSourceName(url: string): string {
372:     try {
373:       const hostname = new URL(url).hostname.replace('www.', '')
374:       const board = this.JOB_BOARDS.find(b => hostname.includes(b.domain))
375:       return board ? board.name : hostname
376:     } catch (error) {
377:       console.error(`Failed to parse URL: ${url}`, error)
378:       return url
379:     }
380:   }
381: }
</file>

<file path="src/lib/perplexity-service.ts">
  1: export class PerplexityService {
  2:   private readonly apiKey: string
  3:   private readonly baseURL = (process.env.PERPLEXITY_BASE_URL || 'https://api.perplexity.ai') + '/chat/completions'
  4:   private readonly defaultModel = process.env.PERPLEXITY_MODEL || 'sonar-pro'
  5:   private static memoryCache: Map<string, { expiresAt: number; value: { content: string; usage?: unknown; cost: number } }> = new Map()
  6:   private static inflightRequests: Map<string, Promise<{ content: string; usage?: unknown; cost: number }>> = new Map()
  7:   private static defaultTtlMs = Number(process.env.PPX_CACHE_TTL_MS || 24*60*60*1000)
  8:   private readonly debug: boolean = process.env.NODE_ENV === 'development' || process.env.PPX_DEBUG === 'true'
  9: 
 10:   constructor(apiKey?: string) {
 11:     const key = apiKey || process.env.PERPLEXITY_API_KEY
 12:     // Do not throw during construction to avoid build-time failures.
 13:     // Validate at request-time in makeRequest instead.
 14:     this.apiKey = key || ''
 15:     if (this.debug) {
 16:       console.log('🔧 PerplexityService Debug Info:')
 17:       console.log('   API Key:', this.apiKey ? `${this.apiKey.slice(0, 8)}...` : '❌ MISSING')
 18:       console.log('   Base URL:', this.baseURL)
 19:       console.log('   Default Model:', this.defaultModel)
 20:     }
 21:   }
 22: 
 23:   async makeRequest(
 24:     systemPrompt: string,
 25:     userPrompt: string,
 26:     options: { maxTokens?: number; temperature?: number; model?: string } = {}
 27:   ): Promise<{ content: string; usage?: unknown; cost: number }> {
 28:     if (this.debug) {
 29:       console.log('🚀 Perplexity Request:')
 30:       console.log('   System:', systemPrompt.slice(0, 100) + '...')
 31:       console.log('   User:', userPrompt.slice(0, 100) + '...')
 32:       console.log('   Model:', options.model || this.defaultModel)
 33:     }
 34:     if (!this.apiKey) {
 35:       throw new Error('PERPLEXITY_API_KEY missing')
 36:     }
 37:     const key = this.makeCacheKey(systemPrompt, userPrompt, options)
 38:     const cached = PerplexityService.memoryCache.get(key)
 39:     if (cached && cached.expiresAt > Date.now()) {
 40:       if (this.debug) console.log('💾 Cache hit for request')
 41:       return cached.value
 42:     }
 43: 
 44:     const inflight = PerplexityService.inflightRequests.get(key)
 45:     if (inflight) {
 46:       if (this.debug) console.log('🔁 Awaiting existing in-flight request')
 47:       return inflight
 48:     }
 49: 
 50:     const payload = {
 51:       model: options.model || this.defaultModel,
 52:       messages: [
 53:         { role: 'system', content: systemPrompt },
 54:         { role: 'user', content: userPrompt },
 55:       ],
 56:       max_tokens: Math.min(options.maxTokens || 2000, 8000),
 57:       temperature: Math.max(0, Math.min(2, options.temperature ?? 0.2)),
 58:     }
 59:     if (this.debug) {
 60:       try { console.log('📤 Request payload:', JSON.stringify(payload).slice(0, 400) + '…') } catch {}
 61:     }
 62: 
 63:     // timeout implemented below via AbortController
 64: 
 65:     const requestPromise = (async () => {
 66:       const maxRetries = 3
 67:       let lastErr: unknown
 68:       for (let attempt = 0; attempt < maxRetries; attempt++) {
 69:         try {
 70:           if (this.debug) console.log(`🔄 Attempt ${attempt + 1}/${maxRetries}`)
 71:           const controller = new AbortController()
 72:           const timer = setTimeout(() => controller.abort(), 600000)
 73:           const res: Response = await fetch(this.baseURL, {
 74:             method: 'POST',
 75:             headers: {
 76:               Authorization: `Bearer ${this.apiKey}`,
 77:               'Content-Type': 'application/json',
 78:               'User-Agent': 'CareerLever/1.0'
 79:             },
 80:             body: JSON.stringify(payload),
 81:             signal: controller.signal
 82:           })
 83:           clearTimeout(timer)
 84:           if (this.debug) {
 85:             console.log(`📡 Response status: ${res.status} ${res.statusText}`)
 86:             try {
 87:               const headersObject: Record<string, string> = {}
 88:               res.headers.forEach((value, key) => {
 89:                 headersObject[key] = value
 90:               })
 91:               console.log('📡 Response headers:', headersObject)
 92:             } catch {}
 93:           }
 94:           if (res.status === 429) {
 95:             const retryAfter = res.headers.get('retry-after')
 96:             const backoff = retryAfter ? parseInt(retryAfter) * 1000 : 400 * Math.pow(2, attempt)
 97:             if (this.debug) console.log(`⏳ Rate limited, waiting ${backoff}ms`)
 98:             await new Promise(r=>setTimeout(r, backoff))
 99:             continue
100:           }
101:           if (!res.ok) {
102:             const errorText = await res.text().catch(()=>'')
103:             const error = this.handleApiError(res.status, res.statusText, errorText)
104:             if (this.debug) {
105:               console.error('❌ API Error:', error.message)
106:               if (errorText) console.error('❌ Raw response:', errorText.slice(0, 500))
107:             }
108:             throw error
109:           }
110:           const data: { choices?: Array<{ message?: { content?: string } }>; usage?: unknown } = await res.json()
111:           if (!data?.choices?.[0]?.message?.content) {
112:             const err = new Error(`Invalid response structure: ${JSON.stringify(data).slice(0, 400)}`)
113:             if (this.debug) console.error('❌ Invalid response:', err.message)
114:             throw err
115:           }
116:           const value: { content: string; usage?: unknown; cost: number } = {
117:             content: data.choices[0].message.content,
118:             usage: data?.usage,
119:             cost: this.calculateCost(data?.usage),
120:           }
121:           if (this.debug) {
122:             console.log('✅ Success! Content length:', value.content.length)
123:             if (value.usage) console.log('📊 Usage:', value.usage)
124:             console.log('💰 Cost:', value.cost)
125:           }
126:           PerplexityService.memoryCache.set(key, { expiresAt: Date.now() + PerplexityService.defaultTtlMs, value })
127:           return value
128:         } catch (e: unknown) {
129:           lastErr = e
130:           const msg = (e as Error)?.message || String(e)
131:           if (this.debug) console.error(`❌ Attempt ${attempt + 1} failed:`, msg)
132:           if (msg.includes('401') || msg.includes('403')) break
133:           if (attempt === maxRetries - 1) break
134:           const backoff = 400 * Math.pow(2, attempt)
135:           if (this.debug) console.log(`⏳ Retrying in ${backoff}ms...`)
136:           await new Promise(r=>setTimeout(r, backoff))
137:         }
138:       }
139:       throw lastErr || new Error('Perplexity request failed')
140:     })()
141: 
142:     PerplexityService.inflightRequests.set(key, requestPromise)
143:     try {
144:       return await requestPromise
145:     } finally {
146:       PerplexityService.inflightRequests.delete(key)
147:     }
148:   }
149: 
150:   // Convenience wrapper: choose sonar vs sonar-pro
151:   async chat(userPrompt: string, options: { model?: 'sonar' | 'sonar-pro'; maxTokens?: number; temperature?: number } = {}) {
152:     const system = options.model === 'sonar' ? 'You are a fast search assistant.' : 'You are an analytical research assistant.'
153:     return this.makeRequest(system, userPrompt, { model: options.model || this.defaultModel, maxTokens: options.maxTokens, temperature: options.temperature })
154:   }
155: 
156:   private calculateCost(usage: unknown): number {
157:     if (!usage) return 0
158:     const u = usage as Record<string, unknown>
159:     const promptTokens = Number((u as Record<string, unknown>).prompt_tokens as number ?? 0)
160:     const completionTokens = Number((u as Record<string, unknown>).completion_tokens as number ?? 0)
161:     const inputCost = (promptTokens / 1_000_000) * 3
162:     const outputCost = (completionTokens / 1_000_000) * 15
163:     return inputCost + outputCost
164:   }
165: 
166:   private makeCacheKey(system: string, user: string, options: unknown): string {
167:     // dynamic import is not allowed in sync context; fall back to require typed as unknown
168:     // eslint-disable-next-line @typescript-eslint/no-var-requires
169:     const cryptoMod: typeof import('crypto') = require('crypto')
170:     const h = cryptoMod.createHash('sha256').update(system + '\n' + user + '\n' + JSON.stringify(options || {})).digest('hex')
171:     return `ppx:${h}`
172:   }
173: 
174:   // Health & validation
175:   async healthCheck(): Promise<{ status: 'healthy'|'degraded'|'unhealthy'; details: { apiKey: boolean; connectivity: boolean; model: string; cacheSize: number; responseTime?: number; error?: string } }> {
176:     const details = { apiKey: !!this.apiKey, connectivity: false, model: this.defaultModel, cacheSize: PerplexityService.memoryCache.size }
177:     if (!this.apiKey) return { status: 'unhealthy', details: { ...details, error: 'Missing API key' } }
178:     try {
179:       const started = Date.now()
180:       const res = await this.makeRequest('You are a health check assistant.', 'Respond with exactly: "OK"', { maxTokens: 10, temperature: 0 })
181:       const rt = Date.now() - started
182:       const ok = res.content.trim().toLowerCase().includes('ok')
183:       return { status: ok && rt < 5000 ? 'healthy' : 'degraded', details: { ...details, connectivity: true, responseTime: rt } }
184:     } catch (e: unknown) {
185:       const msg = (e as Error)?.message || 'health failed'
186:       return { status: 'unhealthy', details: { ...details, error: msg } }
187:     }
188:   }
189: 
190:   validateApiKey(): boolean {
191:     if (!this.apiKey) { console.error('❌ PERPLEXITY_API_KEY is missing'); return false }
192:     if (!this.apiKey.startsWith('pplx-')) { console.error('❌ Invalid API key format - should start with "pplx-"'); return false }
193:     if (this.apiKey.length < 20) { console.error('❌ API key seems too short'); return false }
194:     return true
195:   }
196: 
197:   static getCacheStats() {
198:     const stats = { totalEntries: this.memoryCache.size, entriesByAge: { fresh: 0, stale: 0 }, totalSize: 0 }
199:     const now = Date.now()
200:     this.memoryCache.forEach((entry) => {
201:       const age = now - (entry.expiresAt - this.defaultTtlMs)
202:       if (age < this.defaultTtlMs / 2) stats.entriesByAge.fresh++
203:       else stats.entriesByAge.stale++
204:       try { stats.totalSize += JSON.stringify(entry.value).length } catch {}
205:     })
206:     return stats
207:   }
208: 
209:   static clearCache(): number { const size = this.memoryCache.size; this.memoryCache.clear(); return size }
210: 
211:   async testRequest(): Promise<void> {
212:     console.log('🧪 Testing Perplexity API connection...')
213:     const result = await this.makeRequest('You are a test assistant.', 'Say "Connection successful" if you can read this.', { maxTokens: 50, temperature: 0 })
214:     console.log('✅ Test successful!')
215:     console.log('📝 Response:', (result.content || '').slice(0, 400))
216:     console.log('💰 Cost:', result.cost)
217:   }
218: 
219:   private handleApiError(status: number, statusText: string, body: string): Error {
220:     switch (status) {
221:       case 401: return new Error('Invalid API key - check your PERPLEXITY_API_KEY')
222:       case 403: return new Error('API access forbidden - check your account status')
223:       case 429: return new Error('Rate limit exceeded - please wait before making more requests')
224:       case 500: return new Error('Perplexity server error - please try again later')
225:       case 503: return new Error('Perplexity service unavailable - please try again later')
226:       default: return new Error(`Perplexity API error: ${status} ${statusText} - ${body}`)
227:     }
228:   }
229: }
</file>

<file path="src/lib/validation.ts">
 1: import DOMPurify from 'isomorphic-dompurify'
 2: 
 3: export class InputValidator {
 4:   static sanitizeText(input: string, maxLength = 10000): string {
 5:     return DOMPurify.sanitize(input.trim().substring(0, maxLength), {
 6:       ALLOWED_TAGS: [],
 7:       ALLOWED_ATTR: []
 8:     })
 9:   }
10: 
11:   static sanitizeHTML(input: string): string {
12:     return DOMPurify.sanitize(input, {
13:       ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
14:       ALLOWED_ATTR: []
15:     })
16:   }
17: 
18:   static validateEmail(email: string): boolean {
19:     const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
20:     return emailRegex.test(email) && email.length <= 255
21:   }
22: 
23:   static validateURL(url: string): boolean {
24:     try {
25:       const parsedUrl = new URL(url)
26:       return ['http:', 'https:'].includes(parsedUrl.protocol)
27:     } catch {
28:       return false
29:     }
30:   }
31: 
32:   static validateFileUpload(file: File): { valid: boolean; error?: string } {
33:     const maxSize = 10 * 1024 * 1024 // 10MB
34:     const allowedTypes = ['application/pdf', 'text/plain', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']
35: 
36:     if (file.size > maxSize) {
37:       return { valid: false, error: 'File size exceeds 10MB limit' }
38:     }
39: 
40:     if (!allowedTypes.includes(file.type)) {
41:       return { valid: false, error: 'Invalid file type' }
42:     }
43: 
44:     return { valid: true }
45:   }
46: }
</file>

<file path="src/lib/web-scraper.ts">
   1: import puppeteer, { Browser } from 'puppeteer-core'
   2: import chromium from '@sparticuz/chromium'
   3: import { CompanyData } from '@/types';
   4: 
   5: export interface ScrapedCompanyData {
   6:   companyName: string;
   7:   website?: string;
   8:   industry?: string;
   9:   size?: string;
  10:   description?: string;
  11:   culture?: string[];
  12:   benefits?: string[];
  13:   recentNews?: Array<{
  14:     title: string;
  15:     url: string;
  16:     publishedAt: Date;
  17:     summary: string;
  18:   }>;
  19:   glassdoorRating?: number;
  20:   glassdoorReviews?: number;
  21:   linkedinData?: {
  22:     companyPage: string;
  23:     employeeCount?: number;
  24:     followers?: number;
  25:     recentPosts?: Array<{
  26:       content: string;
  27:       postedAt: Date;
  28:       engagement: number;
  29:     }>;
  30:   };
  31:   socialMedia?: {
  32:     twitter?: {
  33:       handle: string;
  34:       followers: number;
  35:       recentTweets: Array<{
  36:         text: string;
  37:         createdAt: Date;
  38:         likes: number;
  39:         retweets: number;
  40:       }>;
  41:     };
  42:     facebook?: {
  43:       pageUrl: string;
  44:       followers: number;
  45:       recentPosts: Array<{
  46:         content: string;
  47:         postedAt: Date;
  48:         reactions: number;
  49:       }>;
  50:     };
  51:     instagram?: {
  52:       handle: string;
  53:       followers: number;
  54:       recentPosts: Array<{
  55:         caption: string;
  56:         postedAt: Date;
  57:         likes: number;
  58:         comments: number;
  59:       }>;
  60:     };
  61:   };
  62:   sources?: string[];
  63: }
  64: 
  65: export class WebScraperService {
  66:   private browser: Browser | null = null;
  67:   private currentMode: 'disabled' | 'direct' | 'proxy' = 'direct';
  68:   private userAgents: string[] = [
  69:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  70:     'Mozilla/5.0 (Macintosh; Intel Mac OS X 13_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15',
  71:     'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36',
  72:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:118.0) Gecko/20100101 Firefox/118.0',
  73:   ];
  74:   // Simple in-memory cache for OSINT requests
  75:   private osintCache: Map<string, { expiresAt: number; value: any }> = new Map();
  76:   private osintCacheTtlMs: number = Number(process.env.OSINT_CACHE_TTL_MS || 15 * 60 * 1000);
  77:   // Optional Redis client
  78:   private redis: any = null;
  79: 
  80:   async initialize(): Promise<void> {
  81:     if (this.browser) return
  82:     // Allow disabling browser-based scraping entirely in restricted environments
  83:     if (process.env.SCRAPE_DISABLE_BROWSER === '1') {
  84:       this.browser = null
  85:       this.currentMode = 'disabled'
  86:       return
  87:     }
  88:     const executablePath = await chromium.executablePath()
  89:     // Optional proxy rotation: read one proxy from PROXY_URLS
  90:     let proxyArg: string | undefined
  91:     try {
  92:       const proxies = (process.env.PROXY_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
  93:       if (proxies.length) {
  94:         const pick = proxies[Math.floor(Math.random() * proxies.length)]
  95:         // Only accept well-formed proxy URLs
  96:         if (/^(https?:|socks5:\/\/)/i.test(pick)) {
  97:           proxyArg = `--proxy-server=${pick}`
  98:         }
  99:       }
 100:     } catch {}
 101:     // Optional Redis (cache)
 102:     if (!this.redis && process.env.REDIS_URL) {
 103:       try {
 104:         const { createClient } = require('redis')
 105:         this.redis = createClient({ url: process.env.REDIS_URL })
 106:         this.redis.on('error', () => {})
 107:         this.redis.connect().catch(()=>{})
 108:       } catch {}
 109:     }
 110:     const launchArgs = [...chromium.args]
 111:     if (proxyArg) {
 112:       launchArgs.push(proxyArg)
 113:     } else {
 114:       // Some hosts set proxy env vars by default; ensure direct connection
 115:       launchArgs.push('--no-proxy-server')
 116:       launchArgs.push('--proxy-bypass-list=*')
 117:       // Explicitly force direct connection (no quotes around direct://)
 118:       launchArgs.push('--proxy-server=direct://')
 119:     }
 120:     // Ensure no proxy is used if none configured; fix ERR_NO_SUPPORTED_PROXIES
 121:     process.env.HTTP_PROXY = ''
 122:     process.env.http_proxy = ''
 123:     process.env.HTTPS_PROXY = ''
 124:     process.env.https_proxy = ''
 125:     process.env.ALL_PROXY = ''
 126:     process.env.all_proxy = ''
 127:     // Bypass any residual system proxy
 128:     process.env.NO_PROXY = '*'
 129:     process.env.no_proxy = '*'
 130:     // Extra container-friendly flags
 131:     launchArgs.push('--no-sandbox')
 132:     launchArgs.push('--disable-setuid-sandbox')
 133:     launchArgs.push('--disable-dev-shm-usage')
 134:     this.browser = await puppeteer.launch({
 135:       args: launchArgs,
 136:       executablePath,
 137:       headless: true,
 138:     })
 139:     this.currentMode = proxyArg ? 'proxy' : 'direct'
 140:     // Quick connectivity self-test; if a proxy was configured and failed, relaunch direct
 141:     if (proxyArg) {
 142:       try {
 143:         const page = await this.browser.newPage()
 144:         await page.goto('https://example.com', { waitUntil: 'domcontentloaded', timeout: 8000 })
 145:         await page.close()
 146:       } catch (e) {
 147:         const msg = (e as any)?.message || ''
 148:         if (/ERR_NO_SUPPORTED_PROXIES|ERR_TUNNEL_CONNECTION_FAILED|net::ERR/i.test(String(msg))) {
 149:           try { await this.browser.close() } catch {}
 150:           const directArgs = [...chromium.args, '--no-proxy-server', '--proxy-bypass-list=*', '--proxy-server=direct://', '--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
 151:           this.browser = await puppeteer.launch({ args: directArgs, executablePath, headless: true })
 152:           this.currentMode = 'direct'
 153:         }
 154:       }
 155:     }
 156:   }
 157: 
 158:   private async configurePage(page: any) {
 159:     page.setDefaultNavigationTimeout(45000)
 160:     page.setDefaultTimeout(45000)
 161:     const ua = this.userAgents[Math.floor(Math.random() * this.userAgents.length)]
 162:     await page.setUserAgent(ua)
 163:     await page.setViewport({ width: 1366, height: 768 })
 164:     await page.setExtraHTTPHeaders({ 'Accept-Language': 'en-US,en;q=0.9' })
 165:     // If Railway proxies require auth from PROXY_URLS, apply basic auth
 166:     try {
 167:       const proxies = (process.env.PROXY_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
 168:       const pick = proxies[0]
 169:       if (pick) {
 170:         const u = new URL(pick)
 171:         if (u.username && u.password) {
 172:           await page.authenticate({ username: decodeURIComponent(u.username), password: decodeURIComponent(u.password) })
 173:         }
 174:       }
 175:     } catch {}
 176:     await page.setRequestInterception(true)
 177:     page.on('request', (req: any) => {
 178:       const type = req.resourceType()
 179:       // Allow CSS (for layout) but block images/media/fonts
 180:       if (type === 'image' || type === 'media' || type === 'font') { req.abort().catch(()=>{}) }
 181:       else { req.continue().catch(()=>{}) }
 182:     })
 183:   }
 184: 
 185:   private async sleep(ms: number) { return new Promise(r => setTimeout(r, ms)) }
 186: 
 187:   private async withRetry<T>(fn: () => Promise<T>, attempts = 4, baseDelay = 600): Promise<T> {
 188:     let lastErr: any
 189:     for (let i = 0; i < attempts; i++) {
 190:       try { return await fn() } catch (e) { lastErr = e; await this.sleep(baseDelay * Math.pow(2, i) + Math.random()*200) }
 191:     }
 192:     throw lastErr
 193:   }
 194: 
 195:   private isProxyError(error: any): boolean {
 196:     const msg = (error?.message || '').toString()
 197:     return /ERR_NO_SUPPORTED_PROXIES/i.test(msg)
 198:   }
 199: 
 200:   getMode(): 'disabled' | 'direct' | 'proxy' {
 201:     return this.currentMode
 202:   }
 203: 
 204:   async healthCheck(): Promise<{ ok: boolean; mode: 'disabled' | 'direct' | 'proxy'; error?: string }> {
 205:     try {
 206:       await this.initialize()
 207:       if (!this.browser) {
 208:         return { ok: false, mode: this.currentMode, error: 'browser_unavailable' }
 209:       }
 210:       const page = await this.browser.newPage()
 211:       try {
 212:         await this.configurePage(page)
 213:         await page.goto('https://example.com', { waitUntil: 'domcontentloaded', timeout: 8000 })
 214:         return { ok: true, mode: this.currentMode }
 215:       } finally {
 216:         try { await page.close() } catch {}
 217:       }
 218:     } catch (e: any) {
 219:       return { ok: false, mode: this.currentMode, error: String(e?.message || e) }
 220:     }
 221:   }
 222: 
 223:   private async gotoWithRetry(page: any, url: string, waitUntil: 'domcontentloaded'|'networkidle2' = 'domcontentloaded', timeout = 45000) {
 224:     return this.withRetry(async () => {
 225:       return page.goto(url, { waitUntil, timeout })
 226:     }, 3, 700)
 227:   }
 228: 
 229:   // Generic Google search helper returning title, url, and snippet
 230:   async googleSearch(query: string, limit: number = 10): Promise<Array<{ title: string; url: string; snippet: string }>> {
 231:     // Cache lookup
 232:     const cacheKey = `g:${query}:${limit}`
 233:     const now = Date.now()
 234:     const cached = this.osintCache.get(cacheKey)
 235:     if (cached && cached.expiresAt > now) return cached.value
 236:     if (this.redis) {
 237:       try {
 238:         const raw = await this.redis.get(`osint:${cacheKey}`)
 239:         if (raw) {
 240:           const parsed = JSON.parse(raw)
 241:           this.osintCache.set(cacheKey, { expiresAt: now + this.osintCacheTtlMs, value: parsed })
 242:           return parsed
 243:         }
 244:       } catch {}
 245:     }
 246:     // Primary path: headless Google via Puppeteer
 247:     try {
 248:       if (!this.browser) await this.initialize();
 249:       const page = await this.browser!.newPage();
 250:       try {
 251:         await this.configurePage(page)
 252:         const qs = `https://www.google.com/search?q=${encodeURIComponent(query)}&hl=en`;
 253:         await this.gotoWithRetry(page, qs, 'domcontentloaded', 45000)
 254:         // Accept consent if shown, best-effort
 255:         try { await page.evaluate(() => {
 256:           const btn = Array.from(document.querySelectorAll('button, input[type="submit"]')).find(el => /agree|accept|consent/i.test(el.textContent || '')) as HTMLButtonElement | undefined
 257:           btn?.click()
 258:         }) } catch {}
 259:         await this.sleep(900 + Math.random()*600)
 260:         const results = await page.evaluate((max: number) => {
 261:           const out: Array<{ title: string; url: string; snippet: string }> = []
 262:           const blocks = document.querySelectorAll('div.g, div[data-header-feature], div[data-snf]');
 263:           for (const block of Array.from(blocks)) {
 264:             const a = block.querySelector('a[href^="http"]') as HTMLAnchorElement | null
 265:             const h3 = block.querySelector('h3') as HTMLElement | null
 266:             const sn = block.querySelector('div[data-content-feature] div, .VwiC3b, .IsZvec') as HTMLElement | null
 267:             const url = a?.href || ''
 268:             const title = h3?.textContent?.trim() || ''
 269:             const snippet = sn?.textContent?.trim() || ''
 270:             if (url && title) out.push({ title, url, snippet })
 271:             if (out.length >= max) break
 272:           }
 273:           return out
 274:         }, Math.max(1, Math.min(limit, 50)))
 275:         // De-duplicate and filter tracking
 276:         const seen = new Set<string>()
 277:         const cleaned = results.filter(r => {
 278:           try {
 279:             const u = new URL(r.url)
 280:             const key = `${u.hostname}${u.pathname}`
 281:             if (seen.has(key)) return false
 282:             seen.add(key)
 283:             return true
 284:           } catch { return false }
 285:         })
 286:         // Set cache
 287:         this.osintCache.set(cacheKey, { expiresAt: now + this.osintCacheTtlMs, value: cleaned })
 288:         if (this.redis) {
 289:           try { await this.redis.setEx(`osint:${cacheKey}`, Math.floor(this.osintCacheTtlMs/1000), JSON.stringify(cleaned)) } catch {}
 290:         }
 291:         return cleaned
 292:       } finally {
 293:         try { await page.close() } catch {}
 294:       }
 295:     } catch (e) {
 296:       // Fallback: DuckDuckGo HTML (no JS) to avoid proxy/consent issues
 297:       try {
 298:         const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`
 299:         const res = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (compatible; CareerLeverAI/1.0)' } as any })
 300:         if (!res.ok) return []
 301:         const html = await res.text()
 302:         const items: Array<{ title: string; url: string; snippet: string }> = []
 303:         const re = /<a[^>]+class="result__a"[^>]+href="([^"]+)"[^>]*>(.*?)<\/a>[\s\S]*?<a[^>]+class="result__snippet"[^>]*>([\s\S]*?)<\/a>/gi
 304:         let m: RegExpExecArray | null
 305:         const strip = (s: string) => s.replace(/<[^>]+>/g, '').replace(/&[^;]+;/g, ' ').trim()
 306:         while ((m = re.exec(html)) && items.length < Math.max(1, Math.min(limit, 50))) {
 307:           const href = m[1]
 308:           const title = strip(m[2])
 309:           const snippet = strip(m[3])
 310:           if (href && title) items.push({ title, url: href, snippet })
 311:         }
 312:         const seen = new Set<string>()
 313:         const cleaned = items.filter(r => {
 314:           try { const u = new URL(r.url); const key = `${u.hostname}${u.pathname}`; if (seen.has(key)) return false; seen.add(key); return true } catch { return false }
 315:         })
 316:         this.osintCache.set(cacheKey, { expiresAt: now + this.osintCacheTtlMs, value: cleaned })
 317:         if (this.redis) { try { await this.redis.setEx(`osint:${cacheKey}`, Math.floor(this.osintCacheTtlMs/1000), JSON.stringify(cleaned)) } catch {} }
 318:         return cleaned
 319:       } catch {
 320:         return []
 321:       }
 322:     }
 323:   }
 324: 
 325:   // Build advanced Google queries for job discovery across ATS/job boards
 326:   buildJobSearchQueries(options: {
 327:     jobTitle: string;
 328:     location?: string;
 329:     after?: string; // YYYY-MM-DD
 330:     remote?: boolean;
 331:     excludeSenior?: boolean;
 332:     salaryBands?: string[]; // like ["$60,000","$80,000"]
 333:     atsDomains?: string[]; // ['greenhouse.io','jobs.lever.co','workday.com','jobvite.com']
 334:   }): string[] {
 335:     const after = options.after || ''
 336:     const jt = options.jobTitle
 337:     const loc = options.location || ''
 338:     const remote = options.remote ? '"remote"' : ''
 339:     const exclude = options.excludeSenior ? '-"senior" -"staff" -"principal"' : ''
 340:     const parts: string[] = []
 341:     const ats = (options.atsDomains && options.atsDomains.length ? options.atsDomains : ['greenhouse.io','jobs.lever.co','workday.com','jobvite.com']).slice(0,6)
 342:     for (const d of ats) {
 343:       const q = `site:${d} "${jt}" ${loc ? '"'+loc+'"' : ''} ${remote} ${exclude} ${after ? 'after:'+after : ''}`.trim()
 344:       parts.push(q)
 345:     }
 346:     // broad query
 347:     const broad = `"${jt}" ${loc ? '"'+loc+'"' : ''} ${remote} ${exclude} ${after ? 'after:'+after : ''}`.trim()
 348:     parts.push(broad)
 349:     // major job boards
 350:     const boards = ['indeed.com','linkedin.com/jobs','ziprecruiter.com','jobbank.gc.ca','workopolis.com','glassdoor.com/Job']
 351:     for (const b of boards) {
 352:       const q = `site:${b} "${jt}" ${loc ? '"'+loc+'"' : ''} ${remote} ${exclude} ${after ? 'after:'+after : ''}`.trim()
 353:       parts.push(q)
 354:     }
 355:     // generic careers pages
 356:     parts.push(`inurl:careers "${jt}" ${loc ? '"'+loc+'"' : ''} ${remote} ${exclude} ${after ? 'after:'+after : ''}`.trim())
 357:     // salary based queries
 358:     if (options.salaryBands && options.salaryBands.length) {
 359:       const salaryExpr = options.salaryBands.slice(0,3).map(s => `"${s}"`).join(' OR ')
 360:       parts.push(`${salaryExpr} "${jt}" ${loc ? '"'+loc+'"' : ''} filetype:pdf`)
 361:     }
 362:     return parts
 363:   }
 364: 
 365:   // Run Google queries and aggregate unique job posting links, preferring ATS domains
 366:   async searchJobsByGoogle(options: {
 367:     jobTitle: string;
 368:     location?: string;
 369:     after?: string;
 370:     remote?: boolean;
 371:     excludeSenior?: boolean;
 372:     salaryBands?: string[];
 373:     limit?: number;
 374:     radiusKm?: number;
 375:   }): Promise<Array<{ title?: string; url: string; snippet?: string; source: string }>> {
 376:     let queries: string[] = []
 377:     const radiusKm = typeof options.radiusKm === 'number' ? Math.max(1, Math.min(500, options.radiusKm)) : undefined
 378:     if (options.location && radiusKm) {
 379:       try {
 380:         const geo = await this.geocodeLocation(options.location)
 381:         let placeNames: string[] = [ options.location ]
 382:         if (geo) {
 383:           const nearby = await this.getNearbyLocalities(geo.lat, geo.lng, radiusKm, 10)
 384:           const names = nearby.map(p => p.name).filter(Boolean)
 385:           placeNames = Array.from(new Set([options.location, ...names]))
 386:         }
 387:         for (const name of placeNames) {
 388:           const qs = this.buildJobSearchQueries({
 389:             jobTitle: options.jobTitle,
 390:             location: name,
 391:             after: options.after,
 392:             remote: options.remote,
 393:             excludeSenior: options.excludeSenior,
 394:             salaryBands: options.salaryBands,
 395:           })
 396:           queries.push(...qs)
 397:         }
 398:       } catch {
 399:         queries = this.buildJobSearchQueries({
 400:           jobTitle: options.jobTitle,
 401:           location: options.location,
 402:           after: options.after,
 403:           remote: options.remote,
 404:           excludeSenior: options.excludeSenior,
 405:           salaryBands: options.salaryBands,
 406:         })
 407:       }
 408:     } else {
 409:       queries = this.buildJobSearchQueries({
 410:         jobTitle: options.jobTitle,
 411:         location: options.location,
 412:         after: options.after,
 413:         remote: options.remote,
 414:         excludeSenior: options.excludeSenior,
 415:         salaryBands: options.salaryBands,
 416:       })
 417:     }
 418:     const preferredHosts = ['greenhouse.io','jobs.lever.co','workday.com','jobvite.com','boards.greenhouse.io','myworkdayjobs.com','smartrecruiters.com']
 419:     const results: Array<{ title?: string; url: string; snippet?: string; source: string }> = []
 420:     const seen = new Set<string>()
 421:     for (const q of queries) {
 422:       const res = await this.withRetry(() => this.googleSearch(q, 12), 2, 700)
 423:       for (const r of res) {
 424:         try {
 425:           const u = new URL(r.url)
 426:           const host = u.hostname.replace('www.','')
 427:           const key = `${host}${u.pathname}`
 428:           if (seen.has(key)) continue
 429:           seen.add(key)
 430:           results.push({ title: r.title, url: r.url, snippet: r.snippet, source: host })
 431:         } catch { /* ignore */ }
 432:       }
 433:       // small delay to avoid being blocked
 434:       await this.sleep(800 + Math.random()*400)
 435:       if (results.length >= (options.limit || 30)) break
 436:     }
 437:     // Sort: prefer ATS hosts first
 438:     results.sort((a, b) => {
 439:       const aPref = preferredHosts.some(h => (a.source||'').includes(h)) ? 0 : 1
 440:       const bPref = preferredHosts.some(h => (b.source||'').includes(h)) ? 0 : 1
 441:       return aPref - bPref
 442:     })
 443:     return results.slice(0, options.limit || 30)
 444:   }
 445: 
 446:   // Build Google intel queries and gather categorized signals when direct sites are unavailable
 447:   async searchCompanyIntelByGoogle(companyName: string, opts?: { after?: string }): Promise<{
 448:     financial: Array<{ title: string; url: string; snippet: string }>;
 449:     culture: Array<{ title: string; url: string; snippet: string }>;
 450:     news: Array<{ title: string; url: string; snippet: string }>;
 451:     leadership: Array<{ title: string; url: string; snippet: string }>;
 452:     growth: Array<{ title: string; url: string; snippet: string }>;
 453:     benefits: Array<{ title: string; url: string; snippet: string }>;
 454:     crunchbase?: Array<{ title: string; url: string; snippet: string }>;
 455:     pitchbook?: Array<{ title: string; url: string; snippet: string }>;
 456:   }> {
 457:     const after = opts?.after || ''
 458:     const qFinancial = `"${companyName}" ("funding" OR "investment" OR "revenue") ${after ? 'after:'+after : ''}`
 459:     const qCulture = `site:glassdoor.com "${companyName}" ("culture" OR "management" OR "benefits")`
 460:     const qNews = `"${companyName}" ("press release" OR "announcement") ${after ? 'after:'+after : ''}`
 461:     const qLeadership = `"${companyName}" ("CEO" OR "founder" OR "executive" OR "leadership team") ${after ? 'after:'+after : ''}`
 462:     const qGrowth = `"${companyName}" ("hiring" OR "expansion" OR "new office" OR "acquired" OR "partnership") ${after ? 'after:'+after : ''}`
 463:     const qBenefits = `"${companyName}" ("salary" OR "compensation" OR "benefits" OR "PTO")`
 464: 
 465:     const [financial, culture, news, leadership, growth, benefits] = await Promise.all([
 466:       this.googleSearch(qFinancial, 8),
 467:       this.googleSearch(qCulture, 8),
 468:       this.googleSearch(qNews, 8),
 469:       this.googleSearch(qLeadership, 8),
 470:       this.googleSearch(qGrowth, 8),
 471:       this.googleSearch(qBenefits, 8),
 472:     ])
 473: 
 474:     const crunchbase = await this.googleSearch(`site:crunchbase.com "${companyName}"`, 4)
 475:     const pitchbook = await this.googleSearch(`site:pitchbook.com "${companyName}"`, 4)
 476: 
 477:     return { financial, culture, news, leadership, growth, benefits, crunchbase, pitchbook }
 478:   }
 479: 
 480:   // Twitter/X mentions via Google
 481:   async searchTwitterMentions(companyName: string, limit: number = 8): Promise<Array<{ title: string; url: string; snippet: string }>> {
 482:     const q = `"${companyName}" (site:twitter.com OR site:x.com)`
 483:     return this.googleSearch(q, limit)
 484:   }
 485: 
 486:   // Indeed company page/reviews via Google
 487:   async searchIndeedCompany(companyName: string, limit: number = 8): Promise<Array<{ title: string; url: string; snippet: string }>> {
 488:     const q = `site:indeed.com/cmp "${companyName}" (review OR salaries OR interviews)`
 489:     return this.googleSearch(q, limit)
 490:   }
 491: 
 492:   // Reddit employee/interview mentions via Google
 493:   async searchRedditMentions(companyName: string, limit: number = 8): Promise<Array<{ title: string; url: string; snippet: string }>> {
 494:     const q = `site:reddit.com "${companyName}" ("working at" OR interview OR employee)`
 495:     return this.googleSearch(q, limit)
 496:   }
 497: 
 498:   // Financials OSINT: funding, revenue, valuation, investors via Google
 499:   async searchFinancials(companyName: string): Promise<{
 500:     funding: Array<{ title: string; url: string; snippet: string }>;
 501:     revenue: Array<{ title: string; url: string; snippet: string }>;
 502:     valuation: Array<{ title: string; url: string; snippet: string }>;
 503:     investors: Array<{ title: string; url: string; snippet: string }>;
 504:   }> {
 505:     const qFunding = `"${companyName}" (funding OR investment OR "Series A" OR "Series B" OR "Series C") after:2018-01-01`
 506:     const qRevenue = `"${companyName}" (revenue OR ARR OR MRR) filetype:pdf OR site:crunchbase.com`
 507:     const qValuation = `"${companyName}" valuation OR "valued at"`
 508:     const qInvestors = `"${companyName}" investors OR backers OR "led by"`
 509:     const [funding, revenue, valuation, investors] = await Promise.all([
 510:       this.googleSearch(qFunding, 10),
 511:       this.googleSearch(qRevenue, 10),
 512:       this.googleSearch(qValuation, 10),
 513:       this.googleSearch(qInvestors, 10),
 514:     ])
 515:     return { funding, revenue, valuation, investors }
 516:   }
 517: 
 518:   // Geocode a location string to lat/lng using Mapbox (if configured) or OpenStreetMap Nominatim
 519:   async geocodeLocation(location: string): Promise<{ lat: number; lng: number; displayName: string } | null> {
 520:     const q = location.trim()
 521:     if (!q) return null
 522:     const mapboxToken = process.env.MAPBOX_ACCESS_TOKEN
 523:     try {
 524:       if (mapboxToken) {
 525:         const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json?limit=1&access_token=${mapboxToken}`
 526:         const res = await fetch(url, { headers: { 'Accept': 'application/json' } as any })
 527:         if (res.ok) {
 528:           const json: any = await res.json()
 529:           const f = json.features?.[0]
 530:           if (f?.center && Array.isArray(f.center)) {
 531:             return { lat: f.center[1], lng: f.center[0], displayName: f.place_name || q }
 532:           }
 533:         }
 534:       }
 535:     } catch {}
 536:     try {
 537:       const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=1`
 538:       const res = await fetch(url, { headers: { 'Accept': 'application/json', 'User-Agent': 'CareerLeverAI/1.0 (contact: support@careerlever.ai)' } as any })
 539:       if (res.ok) {
 540:         const arr: any[] = await res.json() as any
 541:         const it: any = arr?.[0]
 542:         if (it?.lat && it?.lon) {
 543:           return { lat: parseFloat(it.lat), lng: parseFloat(it.lon), displayName: it.display_name || q }
 544:         }
 545:       }
 546:     } catch {}
 547:     return null
 548:   }
 549: 
 550:   // Fetch nearby locality names within radius using Overpass API (best-effort)
 551:   async getNearbyLocalities(lat: number, lng: number, radiusKm: number, maxPlaces: number = 10): Promise<Array<{ name: string; country?: string }>> {
 552:     const radiusMeters = Math.round(radiusKm * 1000)
 553:     const body = `[out:json][timeout:25];\n(\n  node["place"~"city|town|village"](around:${radiusMeters},${lat},${lng});\n);\nout body ${Math.max(5, maxPlaces)};`;
 554:     try {
 555:       const res = await fetch('https://overpass-api.de/api/interpreter', {
 556:         method: 'POST',
 557:         headers: { 'Content-Type': 'text/plain', 'User-Agent': 'CareerLeverAI/1.0 (contact: support@careerlever.ai)' } as any,
 558:         body
 559:       })
 560:       if (!res.ok) throw new Error('overpass error')
 561:       const json: any = await res.json()
 562:       const names: string[] = []
 563:       for (const el of (json.elements || [])) {
 564:         const name = el?.tags?.name
 565:         if (name && !names.includes(name)) names.push(name)
 566:         if (names.length >= maxPlaces) break
 567:       }
 568:       return names.map(n => ({ name: n }))
 569:     } catch {
 570:       return []
 571:     }
 572:   }
 573: 
 574:   // Compute travel duration (minutes) between two text locations using Mapbox Directions
 575:   async getTravelDurationMins(origin: string, destination: string, profile: 'driving'|'walking'|'cycling' = 'driving'): Promise<number | null> {
 576:     try {
 577:       const o = await this.geocodeLocation(origin)
 578:       const d = await this.geocodeLocation(destination)
 579:       const token = process.env.MAPBOX_ACCESS_TOKEN
 580:       if (!o || !d || !token) return null
 581:       const url = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${o.lng},${o.lat};${d.lng},${d.lat}?annotations=duration&overview=false&access_token=${token}`
 582:       const res = await fetch(url)
 583:       if (!res.ok) return null
 584:       const json: any = await res.json()
 585:       const secs = json?.routes?.[0]?.duration
 586:       if (typeof secs !== 'number') return null
 587:       return Math.round(secs / 60)
 588:     } catch {
 589:       return null
 590:     }
 591:   }
 592: 
 593:   // Scrape a single job detail page from a public URL (best-effort)
 594:   async scrapeJobDetailFromUrl(jobUrl: string): Promise<{
 595:     title?: string;
 596:     companyName?: string;
 597:     location?: string;
 598:     description?: string;
 599:     source: string;
 600:     jobUrl: string;
 601:   }> {
 602:     if (!this.browser) await this.initialize();
 603:     if (!this.browser) return { source: new URL(jobUrl).hostname, jobUrl }
 604:     const page = await this.browser!.newPage();
 605:     try {
 606:       await this.configurePage(page)
 607:       await this.gotoWithRetry(page, jobUrl, 'domcontentloaded', 45000)
 608:       await this.sleep(800 + Math.random()*600)
 609: 
 610:       const host = new URL(jobUrl).hostname.replace('www.', '');
 611:       const data = await page.evaluate((host) => {
 612:         const getText = (sel: string[]) => {
 613:           for (const s of sel) {
 614:             const el = document.querySelector(s) as HTMLElement | null;
 615:             if (el && el.textContent && el.textContent.trim().length > 3) return el.textContent.trim();
 616:           }
 617:           return undefined;
 618:         };
 619:         const getHtml = (sel: string[]) => {
 620:           for (const s of sel) {
 621:             const el = document.querySelector(s) as HTMLElement | null;
 622:             if (el && el.innerText && el.innerText.trim().length > 10) return el.innerText.trim();
 623:           }
 624:           return undefined;
 625:         };
 626: 
 627:         let title = getText(['h1', 'h1[data-testid="jobTitle"]', 'h1.jobsearch-JobInfoHeader-title', 'h1.job-title']);
 628:         let companyName = getText(['.companyName', '[data-company-name="true"]', '.icl-u-lg-mr--sm.icl-u-xs-mr--xs', 'a[data-tn-element="companyName"]', 'a[data-company-name]']);
 629:         if (!companyName) companyName = getText(['[data-testid="companyName"]', 'div[data-company-name]']);
 630:         let location = getText(['.jobsearch-JobInfoHeader-subtitle div:last-child', 'div[data-testid="inlineHeader-companyLocation"]', '.location', '[data-testid="jobLocation"]']);
 631:         let description = getHtml(['#jobDescriptionText', 'div#jobDescriptionText', 'div.jobsearch-jobDescriptionText', 'section#jobDescription', 'div.job-description', 'article']);
 632: 
 633:         return { title, companyName, location, description };
 634:       }, host);
 635: 
 636:       return {
 637:         title: data.title,
 638:         companyName: data.companyName,
 639:         location: data.location,
 640:         description: data.description,
 641:         source: host,
 642:         jobUrl,
 643:       };
 644:     } catch (e) {
 645:       // swallow proxy errors and return minimal data
 646:       return { source: new URL(jobUrl).hostname, jobUrl };
 647:     } finally {
 648:       await page.close();
 649:     }
 650:   }
 651: 
 652:   // Scrape public search results page (Indeed/ZipRecruiter/Job Bank/Google Jobs page) best-effort
 653:   async scrapeJobsFromSearchUrl(searchUrl: string, limit: number = 20): Promise<Array<{
 654:     title?: string;
 655:     companyName?: string;
 656:     location?: string;
 657:     snippet?: string;
 658:     jobUrl: string;
 659:     source: string;
 660:   }>> {
 661:     if (!this.browser) await this.initialize();
 662:     if (!this.browser) return []
 663:     const page = await this.browser!.newPage();
 664:     const results: any[] = [];
 665:     try {
 666:       await this.configurePage(page)
 667:       await page.goto(searchUrl, { waitUntil: 'domcontentloaded', timeout: 45000 });
 668:       await this.sleep(800 + Math.random()*700)
 669:       const host = new URL(searchUrl).hostname.replace('www.', '');
 670: 
 671:       if (/indeed\.com|indeed\.ca/i.test(host)) {
 672:         const items = await page.evaluate(() => {
 673:           const out: any[] = [];
 674:           document.querySelectorAll('a.tapItem, a[data-jk], a[href*="/rc/clk"], a[href*="/pagead/"]').forEach((a) => {
 675:             const el = a as HTMLAnchorElement;
 676:             const card = el.closest('[data-testid="jobsearch-SerpJobCard"]') || el.closest('div.jobsearch-SerpJobCard') || el;
 677:             const title = (card.querySelector('h2.jobTitle, h2 a, h1') as HTMLElement | null)?.innerText?.trim();
 678:             const company = (card.querySelector('.companyName') as HTMLElement | null)?.innerText?.trim();
 679:             const location = (card.querySelector('.companyLocation') as HTMLElement | null)?.innerText?.trim();
 680:             const snippet = (card.querySelector('.job-snippet') as HTMLElement | null)?.innerText?.trim();
 681:             const href = el.href;
 682:             if (href) out.push({ title, companyName: company, location, snippet, jobUrl: href });
 683:           });
 684:           return out;
 685:         });
 686:         for (const it of items) {
 687:           results.push({ ...it, source: host });
 688:           if (results.length >= limit) break;
 689:         }
 690:       } else if (/ziprecruiter\.com/i.test(host)) {
 691:         const items = await page.evaluate(() => {
 692:           const out: any[] = [];
 693:           document.querySelectorAll('a[href*="/jobs/"], a[href*="/jobs-search"] h2 a').forEach((a) => {
 694:             const link = (a as HTMLAnchorElement).href;
 695:             const card = (a as HTMLElement).closest('article, .job_result, .job_card, .job_content') || (a as HTMLElement);
 696:             const title = (card.querySelector('h2, h3') as HTMLElement | null)?.innerText?.trim();
 697:             const company = (card.querySelector('.job_org, .company, .t_org_link') as HTMLElement | null)?.innerText?.trim();
 698:             const location = (card.querySelector('.location, .job_loc') as HTMLElement | null)?.innerText?.trim();
 699:             const snippet = (card.querySelector('p, .job_snippet') as HTMLElement | null)?.innerText?.trim();
 700:             if (link) out.push({ title, companyName: company, location, snippet, jobUrl: link });
 701:           });
 702:           return out;
 703:         });
 704:         for (const it of items) {
 705:           results.push({ ...it, source: host });
 706:           if (results.length >= limit) break;
 707:         }
 708:       } else if (/jobbank\.gc\.ca/i.test(host)) {
 709:         const items = await page.evaluate(() => {
 710:           const out: any[] = [];
 711:           document.querySelectorAll('a[href*="/jobsearch/jobposting/"]').forEach((a) => {
 712:             const link = (a as HTMLAnchorElement).href;
 713:             const card = (a as HTMLElement).closest('li, article, .resultJobItem') || (a as HTMLElement);
 714:             const title = (card.querySelector('h3, h4, a') as HTMLElement | null)?.innerText?.trim();
 715:             const company = (card.querySelector('.business, .resultJobItem__company') as HTMLElement | null)?.innerText?.trim();
 716:             const location = (card.querySelector('.location, .resultJobItem__infoItem--location') as HTMLElement | null)?.innerText?.trim();
 717:             const snippet = (card.querySelector('p, .resultJobItem__short') as HTMLElement | null)?.innerText?.trim();
 718:             if (link) out.push({ title, companyName: company, location, snippet, jobUrl: link });
 719:           });
 720:           return out;
 721:         });
 722:         for (const it of items) {
 723:           results.push({ ...it, source: host });
 724:           if (results.length >= limit) break;
 725:         }
 726:       } else if (/google\./i.test(host)) {
 727:         const items = await page.evaluate(() => {
 728:           const out: any[] = [];
 729:           document.querySelectorAll('a[href^="http"]').forEach((a) => {
 730:             const href = (a as HTMLAnchorElement).href;
 731:             const text = (a as HTMLAnchorElement).innerText || '';
 732:             if (/indeed|ziprecruiter|jobbank\.gc\.ca|workopolis|glassdoor/i.test(href) && text && text.length > 5) {
 733:               out.push({ title: text.split('\n')[0], companyName: undefined, location: undefined, snippet: undefined, jobUrl: href });
 734:             }
 735:           });
 736:           return out;
 737:         });
 738:         for (const it of items) {
 739:           results.push({ ...it, source: host });
 740:           if (results.length >= limit) break;
 741:         }
 742:       }
 743:     } catch (e) {
 744:       // ignore
 745:     } finally {
 746:       await page.close();
 747:     }
 748:     // De-dupe by URL
 749:     const seen = new Set<string>();
 750:     const deduped = results.filter(r => {
 751:       const key = r.jobUrl.split('#')[0];
 752:       if (seen.has(key)) return false;
 753:       seen.add(key); return true;
 754:     });
 755:     return deduped.slice(0, limit);
 756:   }
 757: 
 758:   async close(): Promise<void> {
 759:     if (this.browser) {
 760:       await this.browser.close();
 761:       this.browser = null;
 762:     }
 763:   }
 764: 
 765:   async scrapeCompanyData(companyName: string, website?: string): Promise<ScrapedCompanyData> {
 766:     if (!this.browser) {
 767:       await this.initialize();
 768:     }
 769: 
 770:     const data: ScrapedCompanyData = {
 771:       companyName,
 772:       website,
 773:     };
 774: 
 775:     try {
 776:       const sources: string[] = []
 777:       const addSource = (s: string) => { if (!sources.includes(s)) sources.push(s) }
 778:       // Try to discover official website if missing
 779:       if (!website) {
 780:         try {
 781:           const found = await this.discoverOfficialWebsite(companyName)
 782:           if (found) website = found
 783:         } catch {}
 784:       }
 785:       // Scrape multiple sources in parallel
 786:       const [glassdoorData, linkedinData, websiteData, newsData, instaData, fbData, gRev] = await Promise.allSettled([
 787:         this.scrapeGlassdoorData(companyName),
 788:         this.scrapeLinkedInData(companyName),
 789:         website ? this.scrapeCompanyWebsite(website) : Promise.resolve(null),
 790:         this.scrapeNewsData(companyName),
 791:         this.scrapeInstagramPublic(companyName),
 792:         this.scrapeFacebookPublic(companyName),
 793:         this.scrapeGoogleReviewsSummary(companyName)
 794:       ]);
 795:       // Contact info (best effort) if website known
 796:       let contactInfo: { emails: string[]; phones: string[]; addresses: string[] } | null = null
 797:       try {
 798:         if (website) contactInfo = await this.scrapeContactInfoFromWebsite(website)
 799:       } catch {}
 800: 
 801:       // Merge the data
 802:       if (glassdoorData.status === 'fulfilled' && glassdoorData.value) {
 803:         data.glassdoorRating = glassdoorData.value.rating;
 804:         data.glassdoorReviews = glassdoorData.value.reviews;
 805:         data.culture = glassdoorData.value.culture;
 806:         data.benefits = glassdoorData.value.benefits;
 807:         addSource('glassdoor')
 808:       }
 809: 
 810:       if (linkedinData.status === 'fulfilled' && linkedinData.value) {
 811:         data.linkedinData = linkedinData.value;
 812:         if (!data.industry && linkedinData.value.industry) {
 813:           data.industry = linkedinData.value.industry;
 814:         }
 815:         if (!data.size && linkedinData.value.size) {
 816:           data.size = linkedinData.value.size;
 817:         }
 818:         addSource('linkedin')
 819:       }
 820: 
 821:       if (websiteData.status === 'fulfilled' && websiteData.value) {
 822:         data.description = websiteData.value.description;
 823:         if (!data.industry && websiteData.value.industry) {
 824:           data.industry = websiteData.value.industry;
 825:         }
 826:         addSource('website')
 827:       }
 828:       if (contactInfo && (contactInfo.emails.length || contactInfo.phones.length || contactInfo.addresses.length)) {
 829:         ;(data as any).contactInfo = contactInfo
 830:         addSource('website-contact')
 831:       }
 832: 
 833:       if (newsData.status === 'fulfilled' && newsData.value) {
 834:         data.recentNews = newsData.value;
 835:         addSource('google-news')
 836:       }
 837: 
 838:       if (instaData.status === 'fulfilled' && instaData.value) {
 839:         data.socialMedia = data.socialMedia || {}
 840:         data.socialMedia.instagram = instaData.value as any
 841:         addSource('instagram')
 842:       }
 843: 
 844:       if (fbData.status === 'fulfilled' && fbData.value) {
 845:         data.socialMedia = data.socialMedia || {}
 846:         data.socialMedia.facebook = fbData.value as any
 847:         addSource('facebook')
 848:       }
 849: 
 850:       if (gRev.status === 'fulfilled' && gRev.value) {
 851:         ;(data as any).googleReviewsRating = (gRev.value as any).rating
 852:         ;(data as any).googleReviewsCount = (gRev.value as any).count
 853:         addSource('google-reviews')
 854:       }
 855: 
 856:       // Generate fallback data if we don't have enough info
 857:       if (!data.culture || data.culture.length === 0) {
 858:         data.culture = this.generateFallbackCulture(companyName);
 859:       }
 860: 
 861:       if (!data.benefits || data.benefits.length === 0) {
 862:         data.benefits = this.generateFallbackBenefits();
 863:       }
 864: 
 865:       if (!data.description) {
 866:         data.description = this.generateFallbackDescription(companyName);
 867:       }
 868: 
 869:       data.sources = sources
 870:     } catch (error) {
 871:       console.error('Error scraping company data:', error);
 872:       // Return basic data with fallbacks
 873:       return {
 874:         companyName,
 875:         website,
 876:         culture: this.generateFallbackCulture(companyName),
 877:         benefits: this.generateFallbackBenefits(),
 878:         description: this.generateFallbackDescription(companyName),
 879:       };
 880:     }
 881: 
 882:     return data;
 883:   }
 884: 
 885:   private async discoverOfficialWebsite(companyName: string): Promise<string | null> {
 886:     if (!this.browser) return null
 887:     const page = await this.browser.newPage()
 888:     try {
 889:       await this.configurePage(page)
 890:       const q = `https://www.google.com/search?q=${encodeURIComponent(companyName)}`
 891:       await page.goto(q, { waitUntil: 'domcontentloaded', timeout: 30000 })
 892:       await this.sleep(800 + Math.random()*700)
 893:       const url = await page.$$eval('a[href^="http"]', els => {
 894:         const badHosts = ['linkedin.com','facebook.com','instagram.com','glassdoor.com','crunchbase.com','wikipedia.org','news.google.com','youtube.com','twitter.com','x.com']
 895:         const candidates = els.map(a => (a as HTMLAnchorElement).href).filter(h => {
 896:           try {
 897:             const u = new URL(h)
 898:             return !badHosts.some(b => u.hostname.includes(b))
 899:           } catch { return false }
 900:         })
 901:         return candidates[0] || ''
 902:       })
 903:       if (!url) return null
 904:       try { const u = new URL(url); return `${u.protocol}//${u.hostname}` } catch { return null }
 905:     } catch { return null } finally { await page.close() }
 906:   }
 907: 
 908:   async scrapeContactInfoFromWebsite(website: string): Promise<{ emails: string[]; phones: string[]; addresses: string[] }> {
 909:     if (!this.browser) await this.initialize();
 910:     const results = { emails: [] as string[], phones: [] as string[], addresses: [] as string[] };
 911:     const candidates = [website, `${website.replace(/\/?$/, '/') }contact`, `${website.replace(/\/?$/, '/') }about`];
 912:     const page = await this.browser!.newPage();
 913:     try {
 914:       page.setDefaultNavigationTimeout(45000)
 915:       page.setDefaultTimeout(45000)
 916:       for (const url of candidates) {
 917:         try {
 918:           await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
 919:           await new Promise(r => setTimeout(r, 1000));
 920:           const html = await page.content();
 921:           // Emails from mailto and plain text
 922:           const mailtos = await page.$$eval('a[href^="mailto:"]', els => els.map(a => (a as HTMLAnchorElement).getAttribute('href') || ''));
 923:           const mailtoClean = mailtos.map(h => h.replace(/^mailto:/i, '').trim()).filter(Boolean);
 924:           const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
 925:           const textEmails = (html.match(emailRegex) || []).map(e => e.trim());
 926:           const phoneRegex = /(\+?\d[\s-]?)?(\(?\d{3}\)?[\s-]?)?\d{3}[\s-]?\d{4}/g;
 927:           const phones = (html.match(phoneRegex) || []).map(p => p.trim());
 928:           // Address heuristic: lines with street/ave/blvd/suite
 929:           const addressRegex = /(\d+\s+[^\n,]+(?:Street|St\.|Avenue|Ave\.|Road|Rd\.|Boulevard|Blvd\.|Lane|Ln\.|Suite|Ste\.)[^\n<]{0,80})/gi;
 930:           const addresses = (html.match(addressRegex) || []).map(a => a.trim());
 931:           results.emails.push(...mailtoClean, ...textEmails);
 932:           results.phones.push(...phones);
 933:           results.addresses.push(...addresses);
 934:         } catch {
 935:           continue;
 936:         }
 937:       }
 938:     } finally {
 939:       await page.close();
 940:     }
 941:     // Deduplicate
 942:     results.emails = Array.from(new Set(results.emails));
 943:     results.phones = Array.from(new Set(results.phones));
 944:     results.addresses = Array.from(new Set(results.addresses));
 945:     return results;
 946:   }
 947: 
 948:   async searchHiringContacts(companyName: string, roleHints: string[] = [], locationHint?: string): Promise<Array<{ name: string; title: string; profileUrl?: string; source: string }>> {
 949:     if (!this.browser) await this.initialize();
 950:     if (!this.browser) return []
 951:     const page = await this.browser!.newPage();
 952:     const people: Array<{ name: string; title: string; profileUrl?: string; source: string }> = [];
 953:     try {
 954:       const query = `${companyName} ${roleHints.join(' OR ')} site:linkedin.com/in ${locationHint || ''}`.trim();
 955:       const url = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
 956:       await page.goto(url, { waitUntil: 'networkidle2', timeout: 15000 });
 957:       await new Promise(r => setTimeout(r, 2000));
 958:       const results = await page.evaluate(() => {
 959:         const items: Array<{ title: string; href: string; snippet: string }> = [];
 960:         const nodes = document.querySelectorAll('a[href^="http"]');
 961:         nodes.forEach((a) => {
 962:           const href = (a as HTMLAnchorElement).href;
 963:           const h3 = a.querySelector('h3');
 964:           const title = h3?.textContent || '';
 965:           const parent = a.closest('div') as HTMLElement | null;
 966:           const snippet = parent?.querySelector('span, div')?.textContent || '';
 967:           if (title && href && /linkedin\.com\/in\//i.test(href)) {
 968:             items.push({ title: title.trim(), href, snippet: snippet.trim() });
 969:           }
 970:         });
 971:         return items.slice(0, 10);
 972:       });
 973:       for (const r of results) {
 974:         // Heuristic to split name and title: "Name - Title - Company" or "Name | Title"
 975:         const parts = r.title.split(/[-|–]\s*/);
 976:         const name = parts[0]?.trim() || r.title;
 977:         const title = parts.slice(1).join(' - ').trim() || r.snippet;
 978:         if (name) people.push({ name, title, profileUrl: r.href, source: 'google-linkedin' });
 979:       }
 980:     } catch {
 981:       // ignore
 982:     } finally {
 983:       await page.close();
 984:     }
 985:     return people;
 986:   }
 987: 
 988:   async scrapeGlassdoorReviewsSummary(companyName: string): Promise<{ pros: string[]; cons: string[] } | null> {
 989:     if (!this.browser) await this.initialize();
 990:     const page = await this.browser!.newPage();
 991:     try {
 992:       page.setDefaultNavigationTimeout(45000)
 993:       page.setDefaultTimeout(45000)
 994:       const searchUrl = `https://www.glassdoor.com/Reviews/${companyName.replace(/\s+/g, '-')}-reviews-SRCH_KE0,${companyName.length}.htm`;
 995:       await this.gotoWithRetry(page, searchUrl, 'domcontentloaded', 30000)
 996:       await new Promise(r => setTimeout(r, 2000));
 997:       const data = await page.evaluate(() => {
 998:         const textContent = document.body.innerText || '';
 999:         const pros: string[] = [];
1000:         const cons: string[] = [];
1001:         // Simple heuristic: look for lines following "Pros" or "Cons"
1002:         const lines = textContent.split('\n').map(l => l.trim()).filter(Boolean);
1003:         for (let i = 0; i < lines.length; i++) {
1004:           if (/^pros\b/i.test(lines[i]) && lines[i+1]) pros.push(lines[i+1].slice(0, 200));
1005:           if (/^cons\b/i.test(lines[i]) && lines[i+1]) cons.push(lines[i+1].slice(0, 200));
1006:         }
1007:         return { pros: Array.from(new Set(pros)).slice(0, 5), cons: Array.from(new Set(cons)).slice(0, 5) };
1008:       });
1009:       return data;
1010:     } catch (e) {
1011:       console.error('Glassdoor summary error:', e);
1012:       return null;
1013:     } finally {
1014:       await page.close();
1015:     }
1016:   }
1017: 
1018:   computeSentimentFromProsCons(pros: string[] = [], cons: string[] = []): number {
1019:     const p = pros.length, c = cons.length
1020:     if (p + c === 0) return 50
1021:     return Math.max(0, Math.min(100, Math.round((p / (p + c)) * 100)))
1022:   }
1023: 
1024:   private async scrapeGlassdoorData(companyName: string): Promise<{
1025:     rating?: number;
1026:     reviews?: number;
1027:     culture?: string[];
1028:     benefits?: string[];
1029:   } | null> {
1030:     if (!this.browser) return null;
1031: 
1032:     const page = await this.browser.newPage();
1033: 
1034:     try {
1035:       page.setDefaultNavigationTimeout(45000)
1036:       page.setDefaultTimeout(45000)
1037:       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
1038:       await page.setViewport({ width: 1366, height: 768 });
1039: 
1040:       const searchUrl = `https://www.glassdoor.com/Reviews/${companyName.replace(/\s+/g, '-')}-reviews-SRCH_KE0,${companyName.length}.htm`;
1041: 
1042:       await this.gotoWithRetry(page, searchUrl, 'domcontentloaded', 30000)
1043: 
1044:       // Wait for content to load
1045:       await new Promise(r => setTimeout(r, 2000));
1046: 
1047:       const data = await page.evaluate(() => {
1048:         const result: any = {};
1049: 
1050:         // Get overall rating
1051:         const ratingElement = document.querySelector('[data-test="rating-info"] .css-1cw89uz');
1052:         if (ratingElement) {
1053:           const ratingText = ratingElement.textContent?.trim();
1054:           if (ratingText) {
1055:             const rating = parseFloat(ratingText);
1056:             if (!isNaN(rating) && rating >= 1 && rating <= 5) {
1057:               result.rating = rating;
1058:             }
1059:           }
1060:         }
1061: 
1062:         // Get number of reviews
1063:         const reviewsElement = document.querySelector('[data-test="rating-info"] .css-1cw89uz + span');
1064:         if (reviewsElement) {
1065:           const reviewsText = reviewsElement.textContent?.trim();
1066:           if (reviewsText) {
1067:             const reviewsMatch = reviewsText.match(/([\d,]+)\s*reviews?/i);
1068:             if (reviewsMatch) {
1069:               result.reviews = parseInt(reviewsMatch[1].replace(/,/g, ''));
1070:             }
1071:           }
1072:         }
1073: 
1074:         // Get company culture insights
1075:         const cultureElements = document.querySelectorAll('.css-1cw89uz');
1076:         const culture: string[] = [];
1077:         cultureElements.forEach(el => {
1078:           const text = el.textContent?.trim();
1079:           if (text && text.length > 10 && text.length < 100) {
1080:             culture.push(text);
1081:           }
1082:         });
1083:         if (culture.length > 0) {
1084:           result.culture = culture.slice(0, 5);
1085:         }
1086: 
1087:         // Get benefits if available
1088:         const benefitElements = document.querySelectorAll('[data-test*="benefit"], .benefit, .perk');
1089:         const benefits: string[] = [];
1090:         benefitElements.forEach(el => {
1091:           const text = el.textContent?.trim();
1092:           if (text && text.length > 3 && text.length < 50) {
1093:             benefits.push(text);
1094:           }
1095:         });
1096:         if (benefits.length > 0) {
1097:           result.benefits = benefits.slice(0, 8);
1098:         }
1099: 
1100:         return result;
1101:       });
1102: 
1103:       return data;
1104:     } catch (error) {
1105:       console.error('Glassdoor scraping error:', error);
1106:       return null;
1107:     } finally {
1108:       await page.close();
1109:     }
1110:   }
1111: 
1112:   private async scrapeLinkedInData(companyName: string): Promise<{
1113:     companyPage: string;
1114:     employeeCount?: number;
1115:     followers?: number;
1116:     industry?: string;
1117:     size?: string;
1118:     recentPosts?: Array<{
1119:       content: string;
1120:       postedAt: Date;
1121:       engagement: number;
1122:     }>;
1123:   } | null> {
1124:     if (!this.browser) return null;
1125: 
1126:     const page = await this.browser.newPage();
1127: 
1128:     try {
1129:       page.setDefaultNavigationTimeout(45000)
1130:       page.setDefaultTimeout(45000)
1131:       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
1132:       await page.setViewport({ width: 1366, height: 768 });
1133: 
1134:       // Prefer company vanity, but allow a Google fallback if page lacks data
1135:       const vanity = companyName.toLowerCase().replace(/\s+/g, '')
1136:       const searchUrl = `https://www.linkedin.com/company/${vanity}`;
1137: 
1138:       await page.goto(searchUrl, {
1139:         waitUntil: 'domcontentloaded',
1140:         timeout: 30000
1141:       });
1142: 
1143:       // Wait for content to load
1144:       await new Promise(r => setTimeout(r, 3000));
1145: 
1146:       let data = await page.evaluate(() => {
1147:         const result: any = {
1148:           companyPage: window.location.href
1149:         };
1150: 
1151:         // Get follower count
1152:         const followerSelectors = [
1153:           '.org-top-card-summary-info-list__info-item',
1154:           '[data-test-id="company-followers-count"]',
1155:           '.org-top-card-summary__follower-count'
1156:         ];
1157: 
1158:         for (const selector of followerSelectors) {
1159:           const element = document.querySelector(selector);
1160:           if (element) {
1161:             const text = element.textContent?.trim();
1162:             if (text) {
1163:               const followerMatch = text.match(/([\d,]+)\s*(?:followers?|people)/i);
1164:               if (followerMatch) {
1165:                 result.followers = parseInt(followerMatch[1].replace(/,/g, ''));
1166:                 break;
1167:               }
1168:             }
1169:           }
1170:         }
1171: 
1172:         // Get employee count
1173:         const employeeSelectors = [
1174:           '.org-about-company-module__company-size',
1175:           '[data-test-id="company-employees-count"]',
1176:           '.org-about-company-module__company-staff-count-range'
1177:         ];
1178: 
1179:         for (const selector of employeeSelectors) {
1180:           const element = document.querySelector(selector);
1181:           if (element) {
1182:             const text = element.textContent?.trim();
1183:             if (text) {
1184:               const employeeMatch = text.match(/([\d,]+)(?:\s*-\s*([\d,]+))?\s*employees?/i);
1185:               if (employeeMatch) {
1186:                 result.employeeCount = employeeMatch[2]
1187:                   ? (parseInt(employeeMatch[1].replace(/,/g, '')) + parseInt(employeeMatch[2].replace(/,/g, ''))) / 2
1188:                   : parseInt(employeeMatch[1].replace(/,/g, ''));
1189:                 break;
1190:               }
1191:             }
1192:           }
1193:         }
1194: 
1195:         // Get industry and size info
1196:         const infoElements = document.querySelectorAll('.org-page-details__definition-text, .org-about-company-module__company-size');
1197:         infoElements.forEach(el => {
1198:           const text = el.textContent?.trim();
1199:           if (text) {
1200:             // Try to identify industry
1201:             if (!result.industry && text.length > 3 && text.length < 30) {
1202:               result.industry = text;
1203:             }
1204:             // Try to identify company size
1205:             if (!result.size && text.match(/\d+/)) {
1206:               result.size = text;
1207:             }
1208:           }
1209:         });
1210: 
1211:         return result;
1212:       });
1213:       if (!data || (!data.followers && !data.employeeCount)) {
1214:         try {
1215:           const q = `https://www.google.com/search?q=${encodeURIComponent(companyName + ' site:linkedin.com/company')}`
1216:           await this.gotoWithRetry(page, q, 'domcontentloaded', 30000)
1217:           await new Promise(r=>setTimeout(r,1500))
1218:           const link = await page.$$eval('a[href^="http"]', els => {
1219:             const cand = els.map(a => (a as HTMLAnchorElement).href)
1220:             const good = cand.find(h => /linkedin\.com\/company\//i.test(h))
1221:             return good || ''
1222:           })
1223:           if (link) {
1224:             await this.gotoWithRetry(page, link, 'domcontentloaded', 30000)
1225:             await new Promise(r=>setTimeout(r,1200))
1226:             const data2 = await page.evaluate(() => {
1227:               const out: any = { companyPage: window.location.href }
1228:               const followersEl = document.querySelector('.org-top-card-summary__follower-count, .org-top-card-summary-info-list__info-item')
1229:               const t = followersEl?.textContent || ''
1230:               const m = t.match(/([\d,]+)\s*(followers|people)/i)
1231:               if (m) out.followers = parseInt(m[1].replace(/,/g, ''))
1232:               return out
1233:             })
1234:             data = { ...data, ...data2 }
1235:           }
1236:         } catch {}
1237:       }
1238: 
1239:       return data;
1240:     } catch (error) {
1241:       console.error('LinkedIn scraping error:', error);
1242:       return null;
1243:     } finally {
1244:       await page.close();
1245:     }
1246:   }
1247: 
1248:   private async scrapeInstagramPublic(companyName: string): Promise<{
1249:     handle: string;
1250:     followers: number;
1251:     recentPosts: Array<{ caption: string; postedAt: Date; likes: number; comments: number }>;
1252:   } | null> {
1253:     if (!this.browser) return null;
1254:     const page = await this.browser.newPage();
1255:     try {
1256:       page.setDefaultNavigationTimeout(45000)
1257:       page.setDefaultTimeout(45000)
1258:       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
1259:       const q = `https://www.google.com/search?q=${encodeURIComponent(companyName + ' site:instagram.com')}`
1260:       await this.gotoWithRetry(page, q, 'domcontentloaded', 30000)
1261:       await new Promise(r=>setTimeout(r,1000))
1262:       const igUrl = await page.$$eval('a[href^="http"]', els => {
1263:         const urls = els.map(a => (a as HTMLAnchorElement).href)
1264:         const candidate = urls.find(h => /instagram\.com\//i.test(h)) || ''
1265:         return candidate
1266:       })
1267:       if (!igUrl) return null
1268:       await this.gotoWithRetry(page, igUrl, 'domcontentloaded', 30000)
1269:       await new Promise(r=>setTimeout(r,1200))
1270:       const result = await page.evaluate(() => {
1271:         function parseCount(s: string): number {
1272:           const m = s.trim().toLowerCase().replace(/,/g,'');
1273:           if (/k$/.test(m)) return Math.round(parseFloat(m) * 1000)
1274:           if (/m$/.test(m)) return Math.round(parseFloat(m) * 1000000)
1275:           const n = parseFloat(m)
1276:           return isNaN(n) ? 0 : Math.round(n)
1277:         }
1278:         const handle = window.location.pathname.split('/').filter(Boolean)[0] || ''
1279:         const meta = document.querySelector('meta[property="og:description"]') as HTMLMetaElement | null
1280:         let followers = 0
1281:         if (meta?.content) {
1282:           const m = meta.content.match(/([\d.,]+\s*[kKmM]?)\s+Followers?/)
1283:           if (m) followers = parseCount(m[1])
1284:         }
1285:         const captions: string[] = []
1286:         document.querySelectorAll('article img[alt]').forEach(img => {
1287:           const alt = (img as HTMLImageElement).alt
1288:           if (alt && alt.length > 5) captions.push(alt.substring(0, 200))
1289:         })
1290:         const recentPosts = captions.slice(0,6).map(c => ({ caption: c, postedAt: new Date(), likes: 0, comments: 0 }))
1291:         return { handle, followers, recentPosts }
1292:       })
1293:       return result
1294:     } catch (e) {
1295:       return null
1296:     } finally {
1297:       await page.close()
1298:     }
1299:   }
1300: 
1301:   private async scrapeFacebookPublic(companyName: string): Promise<{
1302:     pageUrl: string;
1303:     followers: number;
1304:     recentPosts: Array<{ content: string; postedAt: Date; reactions: number }>;
1305:   } | null> {
1306:     if (!this.browser) return null;
1307:     const page = await this.browser.newPage();
1308:     try {
1309:       page.setDefaultNavigationTimeout(45000)
1310:       page.setDefaultTimeout(45000)
1311:       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
1312:       const q = `https://www.google.com/search?q=${encodeURIComponent(companyName + ' site:facebook.com')}`
1313:       await this.gotoWithRetry(page, q, 'domcontentloaded', 30000)
1314:       await new Promise(r=>setTimeout(r,1000))
1315:       const fbUrl = await page.$$eval('a[href^="http"]', els => {
1316:         const urls = els.map(a => (a as HTMLAnchorElement).href)
1317:         const candidate = urls.find(h => /facebook\.com\//i.test(h)) || ''
1318:         return candidate
1319:       })
1320:       if (!fbUrl) return null
1321:       await this.gotoWithRetry(page, fbUrl, 'domcontentloaded', 30000)
1322:       await new Promise(r=>setTimeout(r,1500))
1323:       const result = await page.evaluate(() => {
1324:         const pageUrl = window.location.href
1325:         const text = document.body.innerText || ''
1326:         let followers = 0
1327:         const m = text.match(/([\d.,]+)\s+followers/i)
1328:         if (m) followers = parseInt(m[1].replace(/,/g,''))
1329:         const posts: Array<{ content: string; postedAt: Date; reactions: number }> = []
1330:         const articles = Array.from(document.querySelectorAll('div[role="article"]'))
1331:         for (const a of articles.slice(0,5)) {
1332:           const content = (a.textContent || '').trim().replace(/\s+/g,' ').substring(0, 300)
1333:           if (content.length > 20) posts.push({ content, postedAt: new Date(), reactions: 0 })
1334:         }
1335:         return { pageUrl, followers, recentPosts: posts }
1336:       })
1337:       return result
1338:     } catch (e) {
1339:       return null
1340:     } finally {
1341:       await page.close()
1342:     }
1343:   }
1344: 
1345:   private async scrapeGoogleReviewsSummary(companyName: string): Promise<{ rating?: number; count?: number } | null> {
1346:     if (!this.browser) return null;
1347:     const page = await this.browser.newPage();
1348:     try {
1349:       page.setDefaultNavigationTimeout(45000)
1350:       page.setDefaultTimeout(45000)
1351:       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
1352:       const q = `https://www.google.com/search?q=${encodeURIComponent(companyName + ' reviews')}`
1353:       await this.gotoWithRetry(page, q, 'domcontentloaded', 30000)
1354:       await new Promise(r=>setTimeout(r,1500))
1355:       const data = await page.evaluate(() => {
1356:         const txt = document.body.innerText || ''
1357:         let rating: number | undefined
1358:         let count: number | undefined
1359:         const ratingMatch = txt.match(/([0-9]\.[0-9])\s*\(?(?:based on\s*)?([\d,]+)\s+Google reviews\)?/i) || txt.match(/([0-9]\.[0-9])\s+rating\s+from\s+([\d,]+)\s+Google reviews/i)
1360:         if (ratingMatch) {
1361:           rating = parseFloat(ratingMatch[1])
1362:           count = parseInt(ratingMatch[2].replace(/,/g,''))
1363:         } else {
1364:           const countOnly = txt.match(/([\d,]+)\s+Google reviews/i)
1365:           if (countOnly) count = parseInt(countOnly[1].replace(/,/g,''))
1366:         }
1367:         return { rating, count }
1368:       })
1369:       if (!data.rating && !data.count) return null
1370:       return data
1371:     } catch (e) {
1372:       return null
1373:     } finally {
1374:       await page.close()
1375:     }
1376:   }
1377: 
1378:   async scrapeCompanyWebsite(website: string): Promise<{
1379:     description?: string;
1380:     industry?: string;
1381:   } | null> {
1382:     if (!this.browser) return null;
1383: 
1384:     const page = await this.browser.newPage();
1385: 
1386:     try {
1387:       page.setDefaultNavigationTimeout(45000)
1388:       page.setDefaultTimeout(45000)
1389:       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
1390:       await page.setViewport({ width: 1366, height: 768 });
1391: 
1392:       await this.gotoWithRetry(page, website, 'domcontentloaded', 30000)
1393: 
1394:       // Wait for content to load
1395:       await new Promise(r => setTimeout(r, 2000));
1396: 
1397:       const data = await page.evaluate(() => {
1398:         const result: any = {};
1399: 
1400:         // Get meta description
1401:         const descriptionMeta = document.querySelector('meta[name="description"]');
1402:         if (descriptionMeta) {
1403:           const description = descriptionMeta.getAttribute('content')?.trim();
1404:           if (description && description.length > 50) {
1405:             result.description = description;
1406:           }
1407:         }
1408: 
1409:         // Get about text from common selectors
1410:         if (!result.description) {
1411:           const aboutSelectors = [
1412:             '[class*="about"]',
1413:             '[id*="about"]',
1414:             '.about-us',
1415:             '#about',
1416:             '[class*="mission"]',
1417:             '[class*="company"]'
1418:           ];
1419: 
1420:           for (const selector of aboutSelectors) {
1421:             const elements = document.querySelectorAll(`${selector} p, ${selector} div`);
1422:             let text = '';
1423: 
1424:             elements.forEach(el => {
1425:               const content = el.textContent?.trim();
1426:               if (content && content.length > 20) {
1427:                 text += content + ' ';
1428:                 if (text.length > 500) return;
1429:               }
1430:             });
1431: 
1432:             if (text.length > 100) {
1433:               result.description = text.substring(0, 500);
1434:               break;
1435:             }
1436:           }
1437:         }
1438: 
1439:         // Try to infer industry from content
1440:         const bodyText = document.body.textContent || '';
1441:         const industryKeywords = {
1442:           'technology': ['software', 'tech', 'digital', 'app', 'platform', 'saas'],
1443:           'healthcare': ['health', 'medical', 'patient', 'care', 'clinical'],
1444:           'finance': ['financial', 'banking', 'investment', 'wealth', 'capital'],
1445:           'retail': ['retail', 'shopping', 'store', 'product', 'consumer'],
1446:           'consulting': ['consulting', 'advisory', 'strategy', 'management'],
1447:           'education': ['education', 'learning', 'training', 'student', 'academic']
1448:         };
1449: 
1450:         for (const [industry, keywords] of Object.entries(industryKeywords)) {
1451:           const matches = keywords.filter(keyword =>
1452:             bodyText.toLowerCase().includes(keyword.toLowerCase())
1453:           );
1454:           if (matches.length >= 2) {
1455:             result.industry = industry.charAt(0).toUpperCase() + industry.slice(1);
1456:             break;
1457:           }
1458:         }
1459: 
1460:         return result;
1461:       });
1462: 
1463:       // If description is still missing, crawl common subpages best-effort
1464:       if (!data.description) {
1465:         const links = await page.$$eval('a[href^="/"], a[href^="http"]', els => Array.from(new Set(els.map(a => (a as HTMLAnchorElement).getAttribute('href') || ''))).slice(0, 40))
1466:         const candidates = links.filter(h => /about|company|who|mission|values|culture|careers|leadership|team|news|press/i.test(h || '')).slice(0, 8)
1467:         for (const rel of candidates) {
1468:           try {
1469:             const base = new URL(window.location.href)
1470:             const url = rel.startsWith('http') ? rel : new URL(rel, `${base.protocol}//${base.host}`).toString()
1471:             // fetch content via XHR inside the page context to avoid new navigation
1472:             const html = await fetch(url, { credentials: 'omit' }).then(r => r.text()).catch(()=> '')
1473:             const text = html.replace(/<script[\s\S]*?<\/script>/gi, '').replace(/<style[\s\S]*?<\/style>/gi,'').replace(/<[^>]+>/g,' ')
1474:             const cleaned = text.split(/\s+/).join(' ').trim()
1475:             if (cleaned.length > 200 && !data.description) {
1476:               data.description = cleaned.slice(0, 600)
1477:             }
1478:             if (data.description) break
1479:           } catch {}
1480:         }
1481:       }
1482: 
1483:       return data;
1484:     } catch (error) {
1485:       console.error('Website scraping error:', error);
1486:       return null;
1487:     } finally {
1488:       await page.close();
1489:     }
1490:   }
1491: 
1492:   private async scrapeNewsData(companyName: string): Promise<Array<{
1493:     title: string;
1494:     url: string;
1495:     publishedAt: Date;
1496:     summary: string;
1497:   }> | null> {
1498:     if (!this.browser) return null;
1499: 
1500:     const page = await this.browser.newPage();
1501: 
1502:     try {
1503:       page.setDefaultNavigationTimeout(45000)
1504:       page.setDefaultTimeout(45000)
1505:       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
1506:       await page.setViewport({ width: 1366, height: 768 });
1507: 
1508:       // Use Google News search
1509:       const searchQuery = encodeURIComponent(`${companyName} company news`);
1510:       const newsUrl = `https://www.google.com/search?q=${searchQuery}&tbm=nws&tbs=qdr:m`;
1511: 
1512:       await this.gotoWithRetry(page, newsUrl, 'domcontentloaded', 30000)
1513: 
1514:       await new Promise(r => setTimeout(r, 2000));
1515: 
1516:       const newsData = await page.evaluate(() => {
1517:         const articles: Array<{
1518:           title: string;
1519:           url: string;
1520:           publishedAt: Date;
1521:           summary: string;
1522:         }> = [];
1523: 
1524:         // Google News selectors
1525:         const newsItems = document.querySelectorAll('[data-ved], .WlydOe');
1526: 
1527:         newsItems.forEach((item, index) => {
1528:           if (index >= 5) return; // Limit to 5 news items
1529: 
1530:           const titleElement = item.querySelector('h3, .mCBkyc');
1531:           const linkElement = item.querySelector('a[href]');
1532:           const summaryElement = item.querySelector('.GI74Re, .c0cFT, .s3v9rd');
1533:           const dateElement = item.querySelector('.OSrXXb, .eNg7of, .f');
1534: 
1535:           if (titleElement && linkElement) {
1536:             const title = titleElement.textContent?.trim();
1537:             const url = linkElement.getAttribute('href');
1538:             const summary = summaryElement?.textContent?.trim() || '';
1539:             const dateText = dateElement?.textContent?.trim();
1540: 
1541:             if (title && url) {
1542:               articles.push({
1543:                 title,
1544:                 url: url.startsWith('http') ? url : `https://news.google.com${url}`,
1545:                 publishedAt: dateText ? new Date(dateText) : new Date(),
1546:                 summary: summary || title
1547:               });
1548:             }
1549:           }
1550:         });
1551: 
1552:         return articles.filter(article => article.title.length > 10);
1553:       });
1554: 
1555:       return newsData.length > 0 ? newsData : null;
1556:     } catch (error) {
1557:       console.error('News scraping error:', error);
1558:       return null;
1559:     } finally {
1560:       await page.close();
1561:     }
1562:   }
1563: 
1564:   private generateFallbackCulture(companyName: string): string[] {
1565:     // Generate generic but positive culture descriptions
1566:     const cultures = [
1567:       'Collaborative and innovative work environment',
1568:       'Focus on employee development and growth',
1569:       'Work-life balance and flexible arrangements',
1570:       'Diverse and inclusive workplace culture',
1571:       'Strong emphasis on teamwork and communication',
1572:       'Commitment to excellence and quality',
1573:       'Supportive leadership and mentorship programs'
1574:     ];
1575: 
1576:     // Return 3-4 random cultures
1577:     const shuffled = cultures.sort(() => 0.5 - Math.random());
1578:     return shuffled.slice(0, 4);
1579:   }
1580: 
1581:   private generateFallbackBenefits(): string[] {
1582:     return [
1583:       'Health, dental, and vision insurance',
1584:       '401k matching program',
1585:       'Flexible work arrangements',
1586:       'Professional development budget',
1587:       'Paid time off and holidays',
1588:       'Wellness and fitness programs',
1589:       'Modern office facilities'
1590:     ];
1591:   }
1592: 
1593:   private generateFallbackDescription(companyName: string): string {
1594:     return '';
1595:   }
1596: }
1597: 
1598: // Export a singleton instance
1599: export const webScraper = new WebScraperService();
</file>

<file path="src/services/job-search-cache.service.ts">
  1: /**
  2:  * Job Search Cache Service
  3:  * 
  4:  * Manages job search caching with 3-week retention:
  5:  * - Reduces API calls by reusing similar searches
  6:  * - Tracks which jobs users have seen (adds "seen" indicator)
  7:  * - Shares results across users with similar keywords
  8:  * - Auto-expires after 3 weeks
  9:  */
 10: 
 11: import { Types } from 'mongoose';
 12: import JobSearchCache, { IJobSearchCache } from '@/models/JobSearchCache';
 13: import { dbService } from '@/lib/database';
 14: 
 15: export interface CachedJob {
 16:   jobId: string;
 17:   title: string;
 18:   company: string;
 19:   location: string;
 20:   description: string;
 21:   url: string;
 22:   source: string;
 23:   salary?: string;
 24:   postedDate?: Date;
 25:   workType?: string;
 26:   skillMatchScore?: number;
 27:   
 28:   // User-specific tracking
 29:   seen?: boolean; // Has current user seen this job?
 30:   applied?: boolean; // Has current user applied?
 31:   saved?: boolean; // Has current user saved?
 32:   viewCount?: number; // How many users have viewed
 33: }
 34: 
 35: export interface SearchCacheOptions {
 36:   keywords: string | string[];
 37:   location: string;
 38:   workType?: 'remote' | 'hybrid' | 'onsite' | 'any';
 39:   experienceLevel?: 'entry' | 'mid' | 'senior' | 'executive';
 40:   userId?: string; // For tracking user-specific data
 41: }
 42: 
 43: class JobSearchCacheService {
 44:   private static instance: JobSearchCacheService;
 45: 
 46:   private constructor() {}
 47: 
 48:   static getInstance(): JobSearchCacheService {
 49:     if (!JobSearchCacheService.instance) {
 50:       JobSearchCacheService.instance = new JobSearchCacheService();
 51:     }
 52:     return JobSearchCacheService.instance;
 53:   }
 54: 
 55:   /**
 56:    * Normalize keywords for consistent matching
 57:    */
 58:   private normalizeKeywords(keywords: string | string[]): string[] {
 59:     const keywordArray = Array.isArray(keywords) 
 60:       ? keywords 
 61:       : keywords.split(',').map(k => k.trim());
 62:     
 63:     return keywordArray
 64:       .map(k => k.toLowerCase().trim())
 65:       .filter(Boolean)
 66:       .sort();
 67:   }
 68: 
 69:   /**
 70:    * Generate unique job ID for deduplication
 71:    */
 72:   private generateJobId(title: string, company: string, location: string): string {
 73:     const normalized = `${title}-${company}-${location}`
 74:       .toLowerCase()
 75:       .replace(/[^a-z0-9]/g, '-');
 76:     
 77:     return normalized;
 78:   }
 79: 
 80:   /**
 81:    * Find cached search results
 82:    */
 83:   async findCachedSearch(options: SearchCacheOptions): Promise<IJobSearchCache | null> {
 84:     try {
 85:       await dbService.connect();
 86: 
 87:       const normalizedKeywords = this.normalizeKeywords(options.keywords);
 88:       
 89:       const cache = await JobSearchCache.findOne({
 90:         normalizedKeywords: { $all: normalizedKeywords },
 91:         location: new RegExp(options.location, 'i'),
 92:         $or: [
 93:           { workType: options.workType },
 94:           { workType: 'any' },
 95:           { workType: { $exists: false } }
 96:         ],
 97:         expiresAt: { $gt: new Date() } // Not expired
 98:       })
 99:       .sort({ lastSearched: -1 }) // Most recent first
100:       .exec();
101: 
102:       if (cache) {
103:         console.log(`[JOB_CACHE] ✅ Found cached search with ${cache.jobs.length} jobs`);
104:       }
105: 
106:       return cache;
107:     } catch (error) {
108:       console.error('[JOB_CACHE] Error finding cached search:', error);
109:       return null;
110:     }
111:   }
112: 
113:   /**
114:    * Get cached jobs with user-specific tracking
115:    */
116:   async getCachedJobs(
117:     options: SearchCacheOptions
118:   ): Promise<CachedJob[] | null> {
119:     try {
120:       const cache = await this.findCachedSearch(options);
121:       
122:       if (!cache) {
123:         return null;
124:       }
125: 
126:       const userId = options.userId ? new Types.ObjectId(options.userId) : null;
127: 
128:       // Map jobs with user-specific data
129:       const jobs: CachedJob[] = cache.jobs.map((job: any) => ({
130:         jobId: job.jobId,
131:         title: job.title,
132:         company: job.company,
133:         location: job.location,
134:         description: job.description,
135:         url: job.url,
136:         source: job.source,
137:         salary: job.salary,
138:         postedDate: job.postedDate,
139:         workType: job.workType,
140:         skillMatchScore: job.skillMatchScore,
141:         
142:         // User-specific tracking
143:         seen: userId ? job.viewedBy.some((id: any) => id.equals(userId)) : false,
144:         applied: userId ? job.appliedBy.some((id: any) => id.equals(userId)) : false,
145:         saved: userId ? job.savedBy.some((id: any) => id.equals(userId)) : false,
146:         viewCount: job.viewedBy.length
147:       }));
148: 
149:       // Update search count and last searched
150:       cache.searchCount += 1;
151:       cache.lastSearched = new Date();
152:       await cache.save();
153: 
154:       console.log(`[JOB_CACHE] ✅ Returning ${jobs.length} cached jobs (${jobs.filter(j => j.seen).length} seen by user)`);
155: 
156:       return jobs;
157:     } catch (error) {
158:       console.error('[JOB_CACHE] Error getting cached jobs:', error);
159:       return null;
160:     }
161:   }
162: 
163:   /**
164:    * Cache new search results
165:    */
166:   async cacheSearchResults(
167:     options: SearchCacheOptions,
168:     jobs: any[]
169:   ): Promise<void> {
170:     try {
171:       await dbService.connect();
172: 
173:       // CRITICAL FIX: Validate and clean jobs BEFORE caching
174:       const validJobs = jobs.filter(job => {
175:         // Ensure all required fields exist
176:         if (!job.title || !job.company || !job.location || !job.url) {
177:           console.log(`[JOB_CACHE] ❌ Skipping invalid job: missing required fields`);
178:           return false;
179:         }
180:         
181:         // Ensure description exists (set default if empty)
182:         if (!job.description || job.description.trim() === '') {
183:           job.description = 'No description available';
184:         }
185:         
186:         // Ensure source exists
187:         if (!job.source) {
188:           job.source = 'Unknown';
189:         }
190:         
191:         return true;
192:       });
193: 
194:       console.log(`[JOB_CACHE] Validated ${validJobs.length}/${jobs.length} jobs for caching`);
195: 
196:       const normalizedKeywords = this.normalizeKeywords(options.keywords);
197: 
198:       // Check if cache already exists
199:       const existing = await this.findCachedSearch(options);
200: 
201:       if (existing) {
202:         // Merge new jobs with existing (avoid duplicates)
203:         const existingJobIds = new Set(existing.jobs.map((j: any) => j.jobId));
204:         
205:         const newJobs = validJobs
206:           .filter(job => {
207:             const jobId = this.generateJobId(job.title, job.company, job.location);
208:             return !existingJobIds.has(jobId);
209:           })
210:           .map(job => ({
211:             jobId: this.generateJobId(job.title, job.company, job.location),
212:             title: job.title,
213:             company: job.company,
214:             location: job.location,
215:             description: job.description || '',
216:             url: job.url || job.link || '',
217:             source: job.source || 'Unknown',
218:             salary: job.salary,
219:             postedDate: job.postedDate || job.datePosted,
220:             workType: job.workType || job.remote ? 'remote' : undefined,
221:             skillMatchScore: job.skillMatchScore,
222:             viewedBy: [],
223:             appliedBy: [],
224:             savedBy: []
225:           }));
226: 
227:         if (newJobs.length > 0) {
228:           existing.jobs.push(...newJobs);
229:           existing.lastSearched = new Date();
230:           existing.searchCount += 1;
231:           await existing.save();
232:           
233:           console.log(`[JOB_CACHE] ✅ Added ${newJobs.length} new jobs to existing cache`);
234:         } else {
235:           console.log(`[JOB_CACHE] ℹ️ No new jobs to add (all duplicates)`);
236:         }
237:       } else {
238:         // Create new cache entry
239:         const cacheEntry = new JobSearchCache({
240:           keywords: Array.isArray(options.keywords) ? options.keywords : [options.keywords],
241:           normalizedKeywords,
242:           location: options.location,
243:           workType: options.workType || 'any',
244:           experienceLevel: options.experienceLevel,
245:           jobs: validJobs.map(job => ({
246:             jobId: this.generateJobId(job.title, job.company, job.location),
247:             title: job.title,
248:             company: job.company,
249:             location: job.location,
250:             description: job.description || '',
251:             url: job.url || job.link || '',
252:             source: job.source || 'Unknown',
253:             salary: job.salary,
254:             postedDate: job.postedDate || job.datePosted,
255:             workType: job.workType || job.remote ? 'remote' : undefined,
256:             skillMatchScore: job.skillMatchScore,
257:             viewedBy: [],
258:             appliedBy: [],
259:             savedBy: []
260:           })),
261:           searchCount: 1,
262:           lastSearched: new Date(),
263:           expiresAt: new Date(Date.now() + 21 * 24 * 60 * 60 * 1000) // 3 weeks
264:         });
265: 
266:         await cacheEntry.save();
267:         console.log(`[JOB_CACHE] ✅ Created new cache with ${validJobs.length} jobs`);
268:       }
269:     } catch (error) {
270:       console.error('[JOB_CACHE] Error caching search results:', error);
271:       // Non-critical, don't throw
272:     }
273:   }
274: 
275:   /**
276:    * Mark job as viewed by user
277:    */
278:   async markJobViewed(
279:     jobId: string,
280:     userId: string
281:   ): Promise<void> {
282:     try {
283:       await dbService.connect();
284: 
285:       const userObjectId = new Types.ObjectId(userId);
286: 
287:       await JobSearchCache.updateOne(
288:         { 'jobs.jobId': jobId },
289:         { 
290:           $addToSet: { 'jobs.$.viewedBy': userObjectId }
291:         }
292:       );
293: 
294:       console.log(`[JOB_CACHE] ✅ Marked job ${jobId} as viewed by user ${userId}`);
295:     } catch (error) {
296:       console.error('[JOB_CACHE] Error marking job as viewed:', error);
297:     }
298:   }
299: 
300:   /**
301:    * Mark job as applied by user
302:    */
303:   async markJobApplied(
304:     jobId: string,
305:     userId: string
306:   ): Promise<void> {
307:     try {
308:       await dbService.connect();
309: 
310:       const userObjectId = new Types.ObjectId(userId);
311: 
312:       await JobSearchCache.updateOne(
313:         { 'jobs.jobId': jobId },
314:         { 
315:           $addToSet: { 
316:             'jobs.$.appliedBy': userObjectId,
317:             'jobs.$.viewedBy': userObjectId // Also mark as viewed
318:           }
319:         }
320:       );
321: 
322:       console.log(`[JOB_CACHE] ✅ Marked job ${jobId} as applied by user ${userId}`);
323:     } catch (error) {
324:       console.error('[JOB_CACHE] Error marking job as applied:', error);
325:     }
326:   }
327: 
328:   /**
329:    * Mark job as saved by user
330:    */
331:   async markJobSaved(
332:     jobId: string,
333:     userId: string,
334:     saved: boolean = true
335:   ): Promise<void> {
336:     try {
337:       await dbService.connect();
338: 
339:       const userObjectId = new Types.ObjectId(userId);
340: 
341:       if (saved) {
342:         await JobSearchCache.updateOne(
343:           { 'jobs.jobId': jobId },
344:           { 
345:             $addToSet: { 
346:               'jobs.$.savedBy': userObjectId,
347:               'jobs.$.viewedBy': userObjectId // Also mark as viewed
348:             }
349:           }
350:         );
351:       } else {
352:         await JobSearchCache.updateOne(
353:           { 'jobs.jobId': jobId },
354:           { 
355:             $pull: { 'jobs.$.savedBy': userObjectId }
356:           }
357:         );
358:       }
359: 
360:       console.log(`[JOB_CACHE] ✅ Marked job ${jobId} as ${saved ? 'saved' : 'unsaved'} by user ${userId}`);
361:     } catch (error) {
362:       console.error('[JOB_CACHE] Error marking job as saved:', error);
363:     }
364:   }
365: 
366:   /**
367:    * Get cache statistics
368:    */
369:   async getCacheStats(): Promise<{
370:     totalCaches: number;
371:     totalJobs: number;
372:     averageJobsPerCache: number;
373:     oldestCache: Date | null;
374:     newestCache: Date | null;
375:   }> {
376:     try {
377:       await dbService.connect();
378: 
379:       const caches = await JobSearchCache.find({
380:         expiresAt: { $gt: new Date() }
381:       }).exec();
382: 
383:       const totalJobs = caches.reduce((sum, cache) => sum + cache.jobs.length, 0);
384: 
385:       return {
386:         totalCaches: caches.length,
387:         totalJobs,
388:         averageJobsPerCache: caches.length > 0 ? Math.round(totalJobs / caches.length) : 0,
389:         oldestCache: caches.length > 0 
390:           ? new Date(Math.min(...caches.map(c => c.createdAt.getTime())))
391:           : null,
392:         newestCache: caches.length > 0
393:           ? new Date(Math.max(...caches.map(c => c.createdAt.getTime())))
394:           : null
395:       };
396:     } catch (error) {
397:       console.error('[JOB_CACHE] Error getting cache stats:', error);
398:       return {
399:         totalCaches: 0,
400:         totalJobs: 0,
401:         averageJobsPerCache: 0,
402:         oldestCache: null,
403:         newestCache: null
404:       };
405:     }
406:   }
407: }
408: 
409: export const jobSearchCacheService = JobSearchCacheService.getInstance();
</file>

<file path="src/types/comprehensive.ts">
 1: /**
 2:  * Comprehensive Job Research Types
 3:  * One-shot research data for entire Career Finder flow
 4:  */
 5: 
 6: import type { HiringContact, CompanyReview } from './unified'
 7: 
 8: export interface JobAnalysis {
 9:   matchScore: number
10:   matchingSkills: string[]
11:   missingSkills: string[]
12:   skillsToHighlight: string[]
13:   recommendations: string[]
14:   estimatedFit: string
15: }
16: 
17: export interface CompanyIntel {
18:   culture: string
19:   values: string[]
20:   industry: string
21:   size?: string
22:   founded?: string
23:   headquarters?: string
24: }
25: 
26: export interface CompanyNews {
27:   title: string
28:   date: string
29:   summary: string
30:   url?: string
31:   sentiment?: 'positive' | 'neutral' | 'negative'
32: }
33: 
34: // Re-export from unified to avoid conflicts
35: export type { HiringContact, CompanyReview }
36: 
37: export interface ComprehensiveJobResearchData {
38:   jobAnalysis: JobAnalysis
39:   companyIntel: CompanyIntel
40:   hiringContacts: HiringContact[]
41:   news: CompanyNews[]
42:   reviews: CompanyReview[]
43:   marketIntelligence?: {
44:     salaryRange?: string
45:     demandLevel?: string
46:     growthTrend?: string
47:   }
48:   researchedAt: Date
49: }
50: 
51: export interface ComprehensiveJobResearchResponse {
52:   success: boolean
53:   data?: ComprehensiveJobResearchData
54:   error?: string
55:   cached?: boolean
56: }
</file>

<file path="src/types/index.ts">
  1: // Re-export from unified types
  2: export * from './unified'
  3: 
  4: // Autopilot domain types
  5: export * from './signals'
  6: export * from './comprehensive'
  7: export * from './variants'
  8: export * from './cover-letters'
  9: export * from './email-outreach'
 10: 
 11: // Resume Types
 12: export interface Resume {
 13:   _id?: string;
 14:   userId: string;
 15:   userName?: string;
 16:   originalFileName: string;
 17:   fileUrl?: string;
 18:   extractedText: string;
 19:   customizedVersions: CustomizedResume[];
 20:   createdAt: Date;
 21:   updatedAt: Date;
 22: }
 23: 
 24: export interface CustomizedResume {
 25:   _id?: string;
 26:   jobApplicationId: string;
 27:   customizedText: string;
 28:   jobTitle: string;
 29:   companyName: string;
 30:   matchScore: number;
 31:   createdAt: Date;
 32: }
 33: 
 34: // Job Application Types
 35: export interface JobApplication {
 36:   _id?: string;
 37:   userId: string;
 38:   jobTitle: string;
 39:   companyName: string;
 40:   jobDescription: string;
 41:   jobUrl?: string;
 42:   applicationStatus: ApplicationStatus;
 43:   appliedDate: Date;
 44:   followUpDates: Date[];
 45:   companyResearch: CompanyData;
 46:   notes?: string;
 47:   createdAt: Date;
 48:   updatedAt: Date;
 49: }
 50: 
 51: export type ApplicationStatus =
 52:   | 'saved'
 53:   | 'applied'
 54:   | 'interviewing'
 55:   | 'offer'
 56:   | 'rejected'
 57:   | 'withdrawn';
 58: 
 59: // Company Research Types
 60: export interface CompanyData {
 61:   _id?: string;
 62:   companyName: string;
 63:   website?: string;
 64:   industry?: string;
 65:   size?: string;
 66:   description?: string;
 67:   culture?: string[];
 68:   benefits?: string[];
 69:   recentNews?: CompanyNews[];
 70:   glassdoorRating?: number;
 71:   glassdoorReviews?: number;
 72:   linkedinData?: LinkedInData;
 73:   socialMedia?: SocialMediaData;
 74:   hiringContacts?: Array<{ name: string; title: string; profileUrl?: string; source: string }>;
 75:   contactInfo?: { emails: string[]; phones: string[]; addresses: string[] };
 76:   googleReviewsRating?: number;
 77:   googleReviewsCount?: number;
 78:   cachedAt: Date;
 79:   expiresAt: Date;
 80: }
 81: 
 82: export interface CompanyNews {
 83:   title: string;
 84:   url: string;
 85:   publishedAt: Date;
 86:   summary: string;
 87: }
 88: 
 89: export interface LinkedInData {
 90:   companyPage: string;
 91:   employeeCount?: number;
 92:   followers?: number;
 93:   recentPosts?: LinkedInPost[];
 94: }
 95: 
 96: export interface LinkedInPost {
 97:   content: string;
 98:   postedAt: Date;
 99:   engagement: number;
100: }
101: 
102: export interface SocialMediaData {
103:   twitter?: TwitterData;
104:   facebook?: FacebookData;
105:   instagram?: InstagramData;
106: }
107: 
108: export interface TwitterData {
109:   handle: string;
110:   followers: number;
111:   recentTweets: Tweet[];
112: }
113: 
114: export interface Tweet {
115:   text: string;
116:   createdAt: Date;
117:   likes: number;
118:   retweets: number;
119: }
120: 
121: export interface FacebookData {
122:   pageUrl: string;
123:   followers: number;
124:   recentPosts: FacebookPost[];
125: }
126: 
127: export interface FacebookPost {
128:   content: string;
129:   postedAt: Date;
130:   reactions: number;
131: }
132: 
133: export interface InstagramData {
134:   handle: string;
135:   followers: number;
136:   recentPosts: InstagramPost[];
137: }
138: 
139: export interface InstagramPost {
140:   caption: string;
141:   postedAt: Date;
142:   likes: number;
143:   comments: number;
144: }
145: 
146: // API Request/Response Types
147: export interface ResumeUploadRequest {
148:   file: File;
149: }
150: 
151: export interface ResumeUploadResponse {
152:   success: boolean;
153:   resume: Resume;
154:   message?: string;
155: }
156: 
157: export interface JobAnalysisRequest {
158:   jobDescription: string;
159:   jobTitle?: string;
160:   companyName?: string;
161: }
162: 
163: export interface JobAnalysisResponse {
164:   success: boolean;
165:   analysis: JobAnalysis;
166:   keywords: string[];
167:   requirements: string[];
168: }
169: 
170: export interface JobAnalysis {
171:   jobTitle: string;
172:   companyName: string;
173:   keyRequirements: string[];
174:   preferredSkills: string[];
175:   responsibilities: string[];
176:   companyCulture: string[];
177:   salaryRange?: string;
178:   experienceLevel?: string;
179: }
180: 
181: export interface ResumeCustomizationRequest {
182:   resumeId: string;
183:   jobDescription: string;
184:   jobTitle: string;
185:   companyName: string;
186: }
187: 
188: export interface ResumeCustomizationResponse {
189:   success: boolean;
190:   customizedResume: CustomizedResume;
191:   matchScore: number;
192:   improvements: string[];
193: }
194: 
195: export interface CompanyResearchRequest {
196:   companyName: string;
197:   website?: string;
198: }
199: 
200: export interface CompanyResearchResponse {
201:   success: boolean;
202:   companyData: CompanyData;
203:   sources: string[];
204: }
205: 
206: export interface CoverLetterGenerationRequest {
207:   jobApplicationId: string;
208:   resumeId: string;
209:   tone?: 'professional' | 'casual' | 'enthusiastic';
210:   length?: 'short' | 'medium' | 'long';
211: }
212: 
213: export interface CoverLetterGenerationResponse {
214:   success: boolean;
215:   coverLetter: string;
216:   keyPoints: string[];
217: }
218: 
219: export interface FollowUpEmailRequest {
220:   jobApplicationId: string;
221:   daysSinceApplication: number;
222:   context?: string;
223: }
224: 
225: export interface FollowUpEmailResponse {
226:   success: boolean;
227:   emailSubject: string;
228:   emailBody: string;
229:   suggestedTiming: string;
230: }
231: 
232: // UI Component Props Types
233: export interface ResumeUploadProps {
234:   onUploadSuccess: (resume: Resume) => void;
235:   onUploadError: (error: string) => void;
236:   maxFileSize?: number;
237:   acceptedTypes?: string[];
238: }
239: 
240: export interface JobAnalysisFormProps {
241:   onAnalysisComplete: (analysis: JobAnalysisResponse) => void;
242:   onError: (error: string) => void;
243: }
244: 
245: export interface ResumeCustomizerProps {
246:   resume: Resume;
247:   jobAnalysis: JobAnalysis;
248:   onCustomizationComplete: (customized: CustomizedResume) => void;
249:   onError: (error: string) => void;
250: }
251: 
252: export interface CompanyResearchPanelProps {
253:   companyName: string;
254:   onResearchComplete: (data: CompanyData) => void;
255:   onError: (error: string) => void;
256: }
257: 
258: export interface ApplicationTrackerProps {
259:   userId: string;
260:   applications: JobApplication[];
261:   onStatusUpdate: (applicationId: string, status: ApplicationStatus) => void;
262: }
263: 
264: // Utility Types
265: export type LoadingState = 'idle' | 'loading' | 'success' | 'error';
266: 
267: export interface ApiResponse<T> {
268:   success: boolean;
269:   data?: T;
270:   error?: string;
271:   message?: string;
272: }
273: 
274: export interface PaginatedResponse<T> {
275:   data: T[];
276:   pagination: {
277:     page: number;
278:     limit: number;
279:     total: number;
280:     totalPages: number;
281:   };
282: }
283: 
284: // Network Types
285: export interface NetworkPost {
286:   _id: string;
287:   userId: string;
288:   userName: string;
289:   userAvatar?: string;
290:   userTitle?: string;
291:   type: 'job_opportunity' | 'career_advice' | 'success_story' | 'question' | 'general';
292:   title?: string;
293:   content: string;
294:   tags?: string[];
295:   attachments?: Array<{
296:     type: 'image' | 'document' | 'link';
297:     url: string;
298:     name: string;
299:   }>;
300:   likes: string[];
301:   comments: Array<{
302:     userId: string;
303:     userName: string;
304:     content: string;
305:     createdAt: Date;
306:   }>;
307:   shares: number;
308:   createdAt: Date;
309:   updatedAt: Date;
310:   visibility: 'public' | 'connections' | 'private';
311: }
312: 
313: export interface NetworkUser {
314:   id: string;
315:   name: string;
316:   title?: string;
317:   avatar?: string;
318:   location?: string;
319:   skills?: string[];
320:   experience?: string;
321:   connections: number;
322:   mutualConnections: number;
323:   isOnline?: boolean;
324:   lastActive?: Date;
325: }
326: 
327: export interface NetworkConnection {
328:   _id: string;
329:   userId: string;
330:   connectedUserId: string;
331:   status: 'pending' | 'accepted' | 'declined' | 'blocked';
332:   initiatedBy: string;
333:   acceptedAt?: Date;
334:   message?: string;
335:   user?: NetworkUser;
336:   createdAt: Date;
337:   updatedAt: Date;
338: }
339: 
340: export interface Message {
341:   _id: string;
342:   senderId: string;
343:   receiverId: string;
344:   conversationId: string;
345:   content: string;
346:   messageType: 'text' | 'image' | 'file' | 'link';
347:   attachments?: Array<{
348:     type: string;
349:     url: string;
350:     name: string;
351:     size?: number;
352:   }>;
353:   isRead: boolean;
354:   readAt?: Date;
355:   createdAt: Date;
356:   updatedAt: Date;
357: }
358: 
359: // Job Board Integration Types
360: export interface JobBoardIntegration {
361:   _id: string;
362:   userId: string;
363:   boardName: string;
364:   boardDisplayName: string;
365:   status: 'disconnected' | 'connecting' | 'connected' | 'error' | 'requires_auth';
366:   lastSyncAt?: Date;
367:   lastSuccessfulSyncAt?: Date;
368:   syncStatus: 'idle' | 'syncing' | 'success' | 'failed';
369:   errorMessage?: string;
370:   totalApplications: number;
371:   successfulApplications: number;
372:   lastApplicationAt?: Date;
373:   settings: {
374:     autoSync: boolean;
375:     syncFrequency: 'manual' | 'daily' | 'weekly';
376:     defaultResumeId?: string;
377:     defaultCoverLetterId?: string;
378:     notificationPreferences: {
379:       applicationSubmitted: boolean;
380:       applicationViewed: boolean;
381:       interviewRequested: boolean;
382:       errors: boolean;
383:     };
384:   };
385:   metadata: {
386:     apiVersion?: string;
387:     accountId?: string;
388:     accountName?: string;
389:     accountType?: string;
390:     rateLimits?: {
391:       requestsPerHour: number;
392:       requestsPerDay: number;
393:       lastRequestAt?: Date;
394:     };
395:   };
396:   createdAt: Date;
397:   updatedAt: Date;
398: }
399: 
400: export interface JobBoardSubmissionRequest {
401:   jobApplicationId: string;
402:   jobBoards: string[];
403:   resumeId?: string;
404:   coverLetterId?: string;
405:   customizations?: Record<string, unknown>;
406: }
407: 
408: export interface JobBoardSubmissionResult {
409:   jobBoard: string;
410:   success: boolean;
411:   message: string;
412:   applicationUrl?: string;
413:   trackingId?: string;
414:   error?: string;
415: }
</file>

<file path="src/types/unified.ts">
  1: // Unified Type System for Career Lever AI
  2: // Single source of truth for all application types
  3: 
  4: export interface User {
  5:   _id: string
  6:   email: string
  7:   name: string
  8:   image?: string
  9:   createdAt: Date
 10:   updatedAt: Date
 11: }
 12: 
 13: export interface Resume {
 14:   _id: string
 15:   userId: string
 16:   originalFileName: string
 17:   extractedText: string
 18:   customizedVersions: CustomizedResume[]
 19:   uploadedAt: Date
 20:   createdAt: Date
 21:   updatedAt: Date
 22: }
 23: 
 24: export interface CustomizedResume {
 25:   _id: string
 26:   jobApplicationId: string
 27:   customizedText: string
 28:   jobTitle: string
 29:   companyName: string
 30:   matchScore: number
 31:   createdAt: Date
 32: }
 33: 
 34: export interface JobApplication {
 35:   _id: string
 36:   userId: string
 37:   jobTitle: string
 38:   companyName: string
 39:   jobDescription: string
 40:   jobUrl?: string
 41:   location?: string
 42:   salary?: string
 43:   applicationStatus: 'saved' | 'applied' | 'screening' | 'interviewing' | 'offer' | 'rejected' | 'withdrawn'
 44:   appliedDate?: Date
 45:   notes?: string[]
 46:   documents?: ApplicationDocument[]
 47:   createdAt: Date
 48:   updatedAt: Date
 49: }
 50: 
 51: export interface ApplicationDocument {
 52:   type: 'resume' | 'cover-letter' | 'portfolio' | 'other'
 53:   filename: string
 54:   url?: string
 55:   generatedAt: Date
 56: }
 57: 
 58: // Single unified job result interface for all scraping sources
 59: export interface JobResult {
 60:   id: string
 61:   title: string
 62:   company: string
 63:   location?: string
 64:   salary?: string
 65:   url?: string
 66:   source: string
 67:   description?: string
 68:   snippet?: string
 69:   postedDate?: Date | string
 70:   requirements?: string[]
 71:   benefits?: string[]
 72: }
 73: 
 74: export interface CompanyResearch {
 75:   _id: string
 76:   companyName: string
 77:   website?: string
 78:   industry?: string
 79:   size?: string
 80:   description?: string
 81:   culture?: string[]
 82:   financials?: FinancialData[]
 83:   news?: NewsItem[]
 84:   reviews?: CompanyReview[]
 85:   contacts?: HiringContact[]
 86:   lastUpdated: Date
 87:   expiresAt?: Date
 88: }
 89: 
 90: export interface FinancialData {
 91:   year: number
 92:   revenue?: string
 93:   growth?: string
 94:   funding?: string
 95: }
 96: 
 97: export interface NewsItem {
 98:   title: string
 99:   url: string
100:   date: Date | string
101:   source: string
102:   summary?: string
103: }
104: 
105: export interface CompanyReview {
106:   rating: number
107:   title: string
108:   pros?: string
109:   cons?: string
110:   source: string
111:   date?: Date | string
112: }
113: 
114: export interface HiringContact {
115:   name: string
116:   title?: string
117:   email?: string
118:   linkedIn?: string
119:   role?: string
120:   department?: string
121:   linkedinUrl?: string
122:   emailType?: 'public' | 'inferred' | 'pattern'
123:   source?: string
124:   confidence?: number
125:   phone?: string
126:   alternativeEmails?: string[]
127:   discoveryMethod?: string
128: }
129: 
130: // API Response wrapper for consistent responses
131: export interface APIResponse<T = any> {
132:   success: boolean
133:   data?: T
134:   error?: string
135:   message?: string
136:   metadata?: ResponseMetadata
137: }
138: 
139: export interface ResponseMetadata {
140:   requestId?: string
141:   timestamp: Date
142:   cached?: boolean
143:   executionTime?: number
144: }
145: 
146: // Perplexity API types
147: export interface PerplexityJobSearch {
148:   query: string
149:   results?: JobResult[]
150:   sources?: string[]
151: }
152: 
153: export interface IntelligenceResponse {
154:   company: string
155:   freshness: string
156:   sources: any[]
157:   confidence: number
158:   financials: any[]
159:   culture: any[]
160:   salaries: any[]
161:   contacts: any[]
162:   growth: any[]
163:   summary: string
164:   description: string
165:   size: string
166:   revenue: string
167:   industry: string
168:   founded: string
169:   headquarters: string
170:   psychology: string
171:   marketIntelligence: string
172: }
173: 
174: // PDF Processing types
175: export interface PDFExtractionResult {
176:   text: string
177:   method: 'text-extraction' | 'ocr-fallback' | 'manual-input'
178:   confidence: number
179:   error?: string
180: }
181: 
182: // Session types (NextAuth)
183: export interface SessionUser {
184:   id: string
185:   email: string
186:   name?: string
187:   image?: string
188: }
189: 
190: // Form validation schemas
191: export interface ResumeCustomizeInput {
192:   resumeId: string
193:   jobDescription: string
194:   jobTitle: string
195:   companyName: string
196:   tone?: 'professional' | 'casual' | 'enthusiastic'
197: }
198: 
199: export interface CompanyResearchInput {
200:   companyName: string
201:   website?: string
202:   includeNews?: boolean
203:   includeReviews?: boolean
204: }
205: 
206: // Rate limiting types
207: export interface RateLimitConfig {
208:   windowMs: number
209:   maxRequests: number
210:   skipSuccessfulRequests?: boolean
211:   skipFailedRequests?: boolean
212: }
213: 
214: export interface RateLimitEntry {
215:   count: number
216:   resetTime: number
217: }
218: 
219: // Circuit breaker types for AI service
220: export interface CircuitBreakerState {
221:   failures: number
222:   lastFailureTime: number
223:   state: 'closed' | 'open' | 'half-open'
224: }
225: 
226: export interface AIResponse<T = any> {
227:   success: boolean
228:   data?: T
229:   error?: string
230:   cached?: boolean
231:   cost: number
232:   model: string
233: }
</file>

<file path="src/app/resume-builder/page.tsx">
 1: import { Suspense } from 'react'
 2: import { getServerSession } from 'next-auth/next'
 3: import { redirect } from 'next/navigation'
 4: import { authOptions } from '@/lib/auth'
 5: import { ResumeBuilder } from './components/resume-builder'
 6: 
 7: export default async function ResumeBuilderPage() {
 8:   const session = await getServerSession(authOptions)
 9: 
10:   if (!session) {
11:     redirect('/auth/signin')
12:   }
13: 
14:   return (
15:     <div className="min-h-screen bg-background">
16:       <div className="mx-auto max-w-7xl px-4 py-8 sm:px-6 lg:px-8">
17:         <div className="mb-8">
18:           <h1 className="text-3xl font-bold text-foreground">Resume Builder</h1>
19:           <p className="mt-2 text-lg text-muted-foreground">
20:             Create professional, ATS-optimized resumes with AI assistance and beautiful templates
21:           </p>
22:         </div>
23: 
24:         <Suspense fallback={<ResumeBuilderSkeleton />}>
25:           <ResumeBuilder userId={session.user.id} />
26:         </Suspense>
27:       </div>
28:     </div>
29:   )
30: }
31: 
32: function ResumeBuilderSkeleton() {
33:   return (
34:     <div className="space-y-8">
35:       {/* Template Selection Skeleton */}
36:       <div className="bg-card rounded-lg p-6 shadow-sm animate-pulse">
37:         <div className="w-48 h-6 bg-gray-200 rounded mb-4"></div>
38:         <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
39:           {[...Array(3)].map((_, i) => (
40:             <div key={i} className="border rounded-lg p-4">
41:               <div className="w-full h-32 bg-gray-200 rounded mb-3"></div>
42:               <div className="w-20 h-4 bg-gray-200 rounded"></div>
43:             </div>
44:           ))}
45:         </div>
46:       </div>
47: 
48:       {/* Builder Interface Skeleton */}
49:       <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
50:         <div className="lg:col-span-2 space-y-6">
51:           {[...Array(4)].map((_, i) => (
52:             <div key={i} className="bg-card rounded-lg p-6 shadow-sm animate-pulse">
53:               <div className="w-32 h-6 bg-gray-200 rounded mb-4"></div>
54:               <div className="space-y-3">
55:                 <div className="w-full h-10 bg-gray-200 rounded"></div>
56:                 <div className="w-3/4 h-10 bg-gray-200 rounded"></div>
57:               </div>
58:             </div>
59:           ))}
60:         </div>
61: 
62:         <div className="space-y-6">
63:           <div className="bg-card rounded-lg p-6 shadow-sm animate-pulse">
64:             <div className="w-24 h-6 bg-gray-200 rounded mb-4"></div>
65:             <div className="w-full h-64 bg-gray-200 rounded"></div>
66:           </div>
67: 
68:           <div className="bg-card rounded-lg p-6 shadow-sm animate-pulse">
69:             <div className="w-20 h-6 bg-gray-200 rounded mb-4"></div>
70:             <div className="w-full h-32 bg-gray-200 rounded"></div>
71:           </div>
72:         </div>
73:       </div>
74:     </div>
75:   )
76: }
</file>

<file path="src/components/job-card.tsx">
  1: 'use client'
  2: 
  3: import { useState } from 'react'
  4: import { useSession } from 'next-auth/react'
  5: import Link from 'next/link'
  6: import {
  7:   MapPinIcon,
  8:   CurrencyDollarIcon,
  9:   CheckCircleIcon,
 10:   EnvelopeIcon,
 11:   EyeIcon,
 12:   CheckBadgeIcon
 13: } from '@heroicons/react/24/outline'
 14: import { Button } from '@/components/ui/button'
 15: import { useToast } from '@/components/ui/use-toast'
 16: import { cn } from '@/lib/utils'
 17: 
 18: interface Job {
 19:   id: string
 20:   title: string
 21:   company: string
 22:   location: string
 23:   salary?: string
 24:   skills?: string[]
 25:   url: string
 26:   logo?: string
 27:   description?: string
 28:   contacts?: { email?: string } // From research
 29:   seen?: boolean // User has viewed this job
 30:   applied?: boolean // User has applied to this job
 31:   saved?: boolean // User has saved this job
 32: }
 33: 
 34: interface JobCardProps {
 35:   job: Job;
 36:   resumeText?: string;
 37:   coverText?: string;
 38:   className?: string;
 39: }
 40: 
 41: export function JobCard({ job, resumeText, coverText, className }: JobCardProps) {
 42:   const { data: session } = useSession()
 43:   const { toast } = useToast()
 44:   const [isApplying, setIsApplying] = useState(false)
 45: 
 46:   const handleApply = async () => {
 47:     if (!session?.user?.id || !resumeText || !coverText || !job.contacts?.email) {
 48:       toast({
 49:         title: 'Apply Failed',
 50:         description: 'Login and complete research first.',
 51:         variant: 'destructive'
 52:       })
 53:       return
 54:     }
 55: 
 56:     setIsApplying(true)
 57:     try {
 58:       const response = await fetch('/api/outreach/compose', {
 59:         method: 'POST',
 60:         headers: { 'Content-Type': 'application/json' },
 61:         body: JSON.stringify({
 62:           jobId: job.id,
 63:           resumeText,
 64:           coverText,
 65:           contacts: job.contacts,
 66:           company: job.company,
 67:           jobTitle: job.title
 68:         })
 69:       })
 70: 
 71:       if (!response.ok) {
 72:         throw new Error('Compose failed')
 73:       }
 74: 
 75:       const data = await response.json()
 76:       window.location.href = data.mailtoUrl // Open email client
 77:       toast({
 78:         title: 'Application Sent!',
 79:         description: `Tracked as ${data.applicationId}. Check your email client.`,
 80:       })
 81:     } catch (error) {
 82:       toast({
 83:         title: 'Apply Failed',
 84:         description: 'Try again or check contacts.',
 85:         variant: 'destructive'
 86:       })
 87:     } finally {
 88:       setIsApplying(false)
 89:     }
 90:   }
 91: 
 92:   // Dynamic gradient classes using CSS variables
 93:   const gradientStyles = [
 94:     'linear-gradient(135deg, hsl(var(--primary)), hsl(var(--accent)))', // Blue to Yellow
 95:     'linear-gradient(135deg, hsl(var(--secondary)), hsl(var(--primary)))', // Red to Blue
 96:     'linear-gradient(135deg, hsl(var(--accent)), hsl(var(--warning)))', // Yellow to Orange
 97:     'linear-gradient(135deg, hsl(var(--success)), hsl(142 76% 30%))', // Green
 98:     'linear-gradient(135deg, hsl(var(--primary)), hsl(var(--secondary)))', // Blue to Red
 99:   ]
100:   const gradientIndex = parseInt(job.id) % gradientStyles.length
101:   const gradientStyle = gradientStyles[gradientIndex]
102: 
103:   return (
104:     <div className={cn(
105:       'bg-card border border-border rounded-xl p-6 hover:shadow-lg transition-all duration-300 hover:border-primary/50 relative',
106:       className
107:     )}>
108:       {/* Status Badges */}
109:       <div className="absolute top-4 right-4 flex gap-2">
110:         {job.seen && (
111:           <div className="flex items-center gap-1 px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-full text-xs font-semibold">
112:             <EyeIcon className="w-3 h-3" />
113:             Viewed
114:           </div>
115:         )}
116:         {job.applied && (
117:           <div className="flex items-center gap-1 px-2 py-1 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 rounded-full text-xs font-semibold">
118:             <CheckBadgeIcon className="w-3 h-3" />
119:             Applied
120:           </div>
121:         )}
122:       </div>
123:       {/* Modern gradient border wrapper using theme colors */}
124:       <div 
125:         className="p-1 rounded-3xl shadow-lg hover:shadow-2xl transition-all duration-300 hover:-translate-y-2"
126:         style={{ background: gradientStyle }}
127:       >
128:         <div className="bg-card rounded-[calc(1.5rem-1px)] p-6 h-full">
129:           <Link href={job.url} className="block">
130:             {/* Header with colorful logo */}
131:             <div className="flex items-start gap-4 mb-4">
132:               <div 
133:                 className="w-16 h-16 rounded-2xl flex items-center justify-center flex-shrink-0 shadow-lg"
134:                 style={{ background: gradientStyle }}
135:               >
136:                 {job.logo ? (
137:                   <img src={job.logo} alt={`${job.company} logo`} className="w-14 h-14 rounded-xl object-cover" />
138:                 ) : (
139:                   <span className="text-2xl font-bold text-white">{job.company.charAt(0).toUpperCase()}</span>
140:                 )}
141:               </div>
142:               <div className="flex-1 min-w-0">
143:                 <h3 className="text-xl font-bold text-foreground mb-1 line-clamp-2 group-hover:text-primary transition-colors">{job.title}</h3>
144:                 <p className="text-base font-semibold text-muted-foreground">{job.company}</p>
145:                 <div className="flex items-center text-sm text-muted-foreground mt-1">
146:                   <MapPinIcon className="w-4 h-4 mr-1 flex-shrink-0" />
147:                   <span className="truncate">{job.location}</span>
148:                 </div>
149:               </div>
150:             </div>
151: 
152:             {/* Description */}
153:             <p className="text-sm text-muted-foreground mb-4 line-clamp-2">
154:               {job.description || 'Exciting opportunity in a dynamic team. Apply now to learn more!'}
155:             </p>
156: 
157:             {/* Modern skill badges */}
158:             {job.skills && job.skills.length > 0 && (
159:               <div className="flex flex-wrap gap-2 mb-4">
160:                 {job.skills.slice(0, 3).map((skill, idx) => {
161:                   const badgeClasses = [
162:                     'badge-primary',
163:                     'badge-secondary',
164:                     'badge-accent',
165:                   ]
166:                   const badgeClass = badgeClasses[idx % badgeClasses.length]
167:                   return (
168:                     <span key={idx} className={`${badgeClass} text-xs font-bold`}>
169:                       {skill}
170:                     </span>
171:                   )
172:                 })}
173:               </div>
174:             )}
175: 
176:             {/* Salary with icon */}
177:             {job.salary && (
178:               <div className="flex items-center text-sm font-bold text-primary mb-4">
179:                 <CurrencyDollarIcon className="w-5 h-5 mr-1" />
180:                 {job.salary}
181:               </div>
182:             )}
183:           </Link>
184: 
185:           {/* Modern Apply Button */}
186:           <Button 
187:             onClick={handleApply} 
188:             disabled={isApplying} 
189:             className="w-full text-white font-bold py-3 rounded-xl shadow-lg hover:shadow-2xl hover:-translate-y-1 transition-all duration-300 border-0 mb-3"
190:             style={{ background: gradientStyle }}
191:           >
192:             {isApplying ? (
193:               <>
194:                 <EnvelopeIcon className="w-5 h-5 mr-2" />
195:                 Sending...
196:               </>
197:             ) : (
198:               <>
199:                 <CheckCircleIcon className="w-5 h-5 mr-2" />
200:                 Apply Now
201:               </>
202:             )}
203:           </Button>
204: 
205:           {/* Quick Access Buttons */}
206:           <div className="grid grid-cols-2 gap-2">
207:             <Link 
208:               href={`/career-finder/company?company=${encodeURIComponent(job.company)}`}
209:               className="flex items-center justify-center gap-2 px-3 py-2 text-xs font-semibold text-primary border border-primary rounded-lg hover:bg-primary/10 transition-colors"
210:             >
211:               🔍 Research
212:             </Link>
213:             <Link 
214:               href={`/career-finder/job-analysis?job=${job.id}`}
215:               className="flex items-center justify-center gap-2 px-3 py-2 text-xs font-semibold text-primary border border-primary rounded-lg hover:bg-primary/10 transition-colors"
216:             >
217:               📊 Analytics
218:             </Link>
219:           </div>
220:         </div>
221:       </div>
222:     </div>
223:   )
224: }
</file>

<file path="src/components/modern/ModernJobCard.tsx">
  1: 'use client'
  2: 
  3: import React from 'react'
  4: import { MapPinIcon, CurrencyDollarIcon, CheckCircleIcon } from '@heroicons/react/24/outline'
  5: 
  6: interface JobCardProps {
  7:   job: {
  8:     id: string
  9:     title: string
 10:     company: string
 11:     location: string
 12:     salary?: string
 13:     skills: string[]
 14:     urgent?: boolean
 15:     featured?: boolean
 16:     logo?: string
 17:   }
 18:   onApply?: () => void
 19: }
 20: 
 21: export const ModernJobCard: React.FC<JobCardProps> = ({ job, onApply }) => {
 22:   return (
 23:     <div className="dribbble-card p-6 group cursor-pointer">
 24:       {/* Status Badges */}
 25:       <div className="flex justify-between items-start mb-4">
 26:         <div className="flex gap-2">
 27:           {job.featured && (
 28:             <span className="px-3 py-1 bg-gradient-to-r from-yellow-400 to-orange-500 text-white text-xs font-bold rounded-full">
 29:               FEATURED
 30:             </span>
 31:           )}
 32:           {job.urgent && (
 33:             <span className="px-3 py-1 bg-gradient-to-r from-red-500 to-pink-500 text-white text-xs font-bold rounded-full animate-pulse">
 34:               URGENT
 35:             </span>
 36:           )}
 37:         </div>
 38:         <div className="w-12 h-12 bg-gradient-to-r from-blue-500 to-purple-600 rounded-2xl flex items-center justify-center text-white font-bold text-lg shadow-lg">
 39:           {job.logo ? (
 40:             <img src={job.logo} alt={job.company} className="w-full h-full rounded-2xl object-cover" />
 41:           ) : (
 42:             job.company.charAt(0)
 43:           )}
 44:         </div>
 45:       </div>
 46: 
 47:       {/* Job Info */}
 48:       <div className="mb-4">
 49:         <h3 className="text-xl font-bold text-foreground mb-2 group-hover:text-blue-600 transition-colors">
 50:           {job.title}
 51:         </h3>
 52:         <p className="text-gray-600 font-medium text-lg">{job.company}</p>
 53:       </div>
 54: 
 55:       {/* Location & Salary */}
 56:       <div className="flex items-center gap-4 mb-4 text-sm text-gray-500">
 57:         <div className="flex items-center gap-1">
 58:           <MapPinIcon className="w-4 h-4 text-blue-500" />
 59:           <span>{job.location}</span>
 60:         </div>
 61:         {job.salary && (
 62:           <div className="flex items-center gap-1">
 63:             <CurrencyDollarIcon className="w-4 h-4 text-green-500" />
 64:             <span className="font-semibold text-green-600">{job.salary}</span>
 65:           </div>
 66:         )}
 67:       </div>
 68: 
 69:       {/* Skills */}
 70:       <div className="flex flex-wrap gap-2 mb-6">
 71:         {job.skills.slice(0, 3).map((skill, index) => (
 72:           <span 
 73:             key={skill}
 74:             className={`px-3 py-1 rounded-full text-sm font-medium ${
 75:               index === 0 ? 'bg-blue-100 text-blue-700' :
 76:               index === 1 ? 'bg-red-100 text-red-700' :
 77:               'bg-yellow-100 text-yellow-700'
 78:             }`}
 79:           >
 80:             {skill}
 81:           </span>
 82:         ))}
 83:         {job.skills.length > 3 && (
 84:           <span className="px-3 py-1 bg-gray-100 text-gray-600 rounded-full text-sm font-medium">
 85:             +{job.skills.length - 3}
 86:           </span>
 87:         )}
 88:       </div>
 89: 
 90:       {/* Apply Button */}
 91:       <button 
 92:         onClick={onApply}
 93:         className="btn-dribbble-primary w-full group-hover:scale-[1.02] transition-transform"
 94:       >
 95:         <span className="flex items-center justify-center gap-2">
 96:           Apply Now
 97:           <CheckCircleIcon className="w-5 h-5" />
 98:         </span>
 99:       </button>
100:     </div>
101:   )
102: }
</file>

<file path="src/components/modern/SearchHeroSection.tsx">
 1: 'use client'
 2: 
 3: import React, { useState } from 'react'
 4: import { MagnifyingGlassIcon, FunnelIcon } from '@heroicons/react/24/outline'
 5: 
 6: interface SearchHeroProps {
 7:   onSearch?: (query: string, location: string) => void
 8:   onFilterClick?: () => void
 9: }
10: 
11: export const SearchHeroSection: React.FC<SearchHeroProps> = ({ onSearch, onFilterClick }) => {
12:   const [searchQuery, setSearchQuery] = useState('')
13:   const [location, setLocation] = useState('')
14: 
15:   const handleSearch = (e: React.FormEvent) => {
16:     e.preventDefault()
17:     onSearch?.(searchQuery, location)
18:   }
19: 
20:   return (
21:     <div className="relative overflow-hidden rounded-3xl mb-8 mx-4">
22:       {/* Animated Background */}
23:       <div className="bg-gradient-to-r from-blue-600 via-purple-600 to-red-500 p-8 relative">
24:         {/* Floating Elements */}
25:         <div className="absolute top-4 right-4 w-32 h-32 bg-yellow-400 bg-opacity-20 rounded-full animate-bounce blur-xl" style={{ animationDelay: '0s', animationDuration: '3s' }}></div>
26:         <div className="absolute bottom-4 left-4 w-20 h-20 bg-card bg-opacity-10 rounded-2xl animate-bounce blur-lg" style={{ animationDelay: '1s', animationDuration: '4s' }}></div>
27:         <div className="absolute top-1/2 left-1/4 w-16 h-16 bg-red-400 bg-opacity-15 rounded-full animate-bounce blur-lg" style={{ animationDelay: '2s', animationDuration: '5s' }}></div>
28: 
29:         <div className="relative z-10 text-center mb-8">
30:           <h1 className="text-4xl font-bold text-white mb-4 drop-shadow-lg">
31:             🚀 Find Your Dream Job
32:           </h1>
33:           <p className="text-white text-opacity-90 text-lg font-medium">
34:             Discover opportunities that match your skills and passion
35:           </p>
36:         </div>
37: 
38:         {/* Search Bar */}
39:         <form onSubmit={handleSearch} className="relative z-10 max-w-4xl mx-auto">
40:           <div className="bg-card bg-opacity-95 backdrop-blur-sm rounded-2xl p-6 shadow-2xl">
41:             <div className="flex flex-col md:flex-row gap-4">
42:               {/* Job Title Search */}
43:               <div className="flex-1 relative">
44:                 <MagnifyingGlassIcon className="absolute left-4 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
45:                 <input
46:                   type="text"
47:                   placeholder="Job title or keyword"
48:                   value={searchQuery}
49:                   onChange={(e) => setSearchQuery(e.target.value)}
50:                   className="w-full pl-12 pr-4 py-4 bg-gray-50 border-2 border-border rounded-xl text-foreground placeholder-gray-500 focus:border-blue-500 focus:ring-0 focus:outline-none transition-colors"
51:                 />
52:               </div>
53: 
54:               {/* Location Search */}
55:               <div className="flex-1 relative">
56:                 <input
57:                   type="text"
58:                   placeholder="Location"
59:                   value={location}
60:                   onChange={(e) => setLocation(e.target.value)}
61:                   className="w-full px-4 py-4 bg-gray-50 border-2 border-border rounded-xl text-foreground placeholder-gray-500 focus:border-blue-500 focus:ring-0 focus:outline-none transition-colors"
62:                 />
63:               </div>
64: 
65:               {/* Filter Button */}
66:               <button 
67:                 type="button"
68:                 onClick={onFilterClick}
69:                 className="px-6 py-4 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors flex items-center justify-center"
70:               >
71:                 <FunnelIcon className="w-5 h-5 text-gray-600" />
72:               </button>
73: 
74:               {/* Search Button */}
75:               <button 
76:                 type="submit"
77:                 className="btn-dribbble-primary px-8 py-4 flex items-center justify-center gap-2 whitespace-nowrap"
78:               >
79:                 <MagnifyingGlassIcon className="w-5 h-5" />
80:                 Search Jobs
81:               </button>
82:             </div>
83:           </div>
84:         </form>
85:       </div>
86:     </div>
87:   )
88: }
</file>

<file path="src/lib/agents/agent-orchestrator.ts">
  1: /**
  2:  * AGENT ORCHESTRATOR
  3:  * Manages all agents and routes tasks with parallel execution
  4:  */
  5: 
  6: import { JobDiscoveryAgent } from './job-discovery-agent'
  7: import { ContactResearchAgent } from './contact-research-agent'
  8: import { AgentTask, AgentResult } from './base-agent'
  9: 
 10: export class AgentOrchestrator {
 11:   private jobAgent: JobDiscoveryAgent
 12:   private contactAgent: ContactResearchAgent
 13: 
 14:   constructor() {
 15:     console.log('🤖 [ORCHESTRATOR] Initializing agent system...')
 16:     this.jobAgent = new JobDiscoveryAgent()
 17:     this.contactAgent = new ContactResearchAgent()
 18:     console.log('✅ [ORCHESTRATOR] All agents ready')
 19:   }
 20: 
 21:   async executeTask(task: AgentTask): Promise<AgentResult> {
 22:     console.log(`🎯 [ORCHESTRATOR] Routing task: ${task.type} (priority: ${task.priority})`)
 23:     console.log(`📋 [ORCHESTRATOR] Task input:`, task.input)
 24: 
 25:     const started = Date.now()
 26: 
 27:     try {
 28:       let result: AgentResult
 29: 
 30:       switch (task.type) {
 31:         case 'job_search':
 32:           result = await this.jobAgent.execute(task)
 33:           break
 34:         
 35:         case 'contact_research':
 36:           result = await this.contactAgent.execute(task)
 37:           break
 38:         
 39:         default:
 40:           throw new Error(`Unknown task type: ${task.type}`)
 41:       }
 42: 
 43:       const duration = Date.now() - started
 44:       console.log(`✅ [ORCHESTRATOR] Task completed in ${duration}ms`)
 45:       console.log(`📊 [ORCHESTRATOR] Success: ${result.success}, Confidence: ${result.confidence}`)
 46: 
 47:       return result
 48:     } catch (error) {
 49:       const duration = Date.now() - started
 50:       console.error(`❌ [ORCHESTRATOR] Task failed after ${duration}ms:`, error)
 51:       
 52:       return {
 53:         success: false,
 54:         data: null,
 55:         reasoning: `Task failed: ${(error as Error).message}`,
 56:         confidence: 0,
 57:         sources: [],
 58:         duration
 59:       }
 60:     }
 61:   }
 62: 
 63:   async executeMultiple(tasks: AgentTask[]): Promise<AgentResult[]> {
 64:     console.log(`🚀 [ORCHESTRATOR] Executing ${tasks.length} tasks in parallel...`)
 65:     
 66:     const started = Date.now()
 67:     
 68:     // Execute tasks in parallel
 69:     const results = await Promise.all(
 70:       tasks.map(task => this.executeTask(task))
 71:     )
 72:     
 73:     const duration = Date.now() - started
 74:     const successful = results.filter(r => r.success).length
 75:     
 76:     console.log(`✅ [ORCHESTRATOR] Parallel execution complete in ${duration}ms`)
 77:     console.log(`📊 [ORCHESTRATOR] ${successful}/${tasks.length} tasks succeeded`)
 78:     
 79:     return results
 80:   }
 81: 
 82:   async executeSequential(tasks: AgentTask[]): Promise<AgentResult[]> {
 83:     console.log(`🔄 [ORCHESTRATOR] Executing ${tasks.length} tasks sequentially...`)
 84:     
 85:     const started = Date.now()
 86:     const results: AgentResult[] = []
 87:     
 88:     for (const task of tasks) {
 89:       const result = await this.executeTask(task)
 90:       results.push(result)
 91:       
 92:       // Stop if critical task fails
 93:       if (task.priority === 1 && !result.success) {
 94:         console.warn(`⚠️ [ORCHESTRATOR] Critical task failed, stopping sequence`)
 95:         break
 96:       }
 97:     }
 98:     
 99:     const duration = Date.now() - started
100:     const successful = results.filter(r => r.success).length
101:     
102:     console.log(`✅ [ORCHESTRATOR] Sequential execution complete in ${duration}ms`)
103:     console.log(`📊 [ORCHESTRATOR] ${successful}/${results.length} tasks succeeded`)
104:     
105:     return results
106:   }
107: 
108:   generateTaskId(): string {
109:     return `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
110:   }
111: }
</file>

<file path="src/lib/job-outlook-analyzer.ts">
  1: /**
  2:  * AI/Automation Job Outlook Analyzer
  3:  * 
  4:  * Provides 5-year job market projections using Perplexity AI
  5:  * Analyzes automation risk, growth trends, and career recommendations
  6:  */
  7: 
  8: import { PerplexityIntelligenceService } from './perplexity-intelligence'
  9: 
 10: export interface JobOutlook {
 11:   jobTitle: string
 12:   location: string
 13:   
 14:   // 5-Year Projections
 15:   projections: {
 16:     year: number
 17:     demandTrend: 'increasing' | 'stable' | 'decreasing'
 18:     salaryGrowth: number // percentage
 19:     jobOpenings: number // estimated
 20:   }[]
 21:   
 22:   // Automation Risk Analysis
 23:   automation: {
 24:     riskLevel: 'low' | 'medium' | 'high' | 'critical'
 25:     riskScore: number // 0-100
 26:     automationTimeline: string // e.g. "5-10 years", "10+ years"
 27:     vulnerableTasks: string[]
 28:     safeTasks: string[]
 29:     recommendations: string[]
 30:   }
 31:   
 32:   // Market Intelligence
 33:   market: {
 34:     currentDemand: 'very high' | 'high' | 'moderate' | 'low'
 35:     competitionLevel: 'very competitive' | 'competitive' | 'moderate' | 'favorable'
 36:     emergingSkills: string[]
 37:     decliningSkills: string[]
 38:     topIndustries: string[]
 39:     averageSalary: {
 40:       min: number
 41:       max: number
 42:       median: number
 43:       currency: string
 44:     }
 45:   }
 46:   
 47:   // Career Recommendations
 48:   recommendations: {
 49:     upskilling: string[]
 50:     pivotOpportunities: string[]
 51:     certifications: string[]
 52:     safetyScore: number // 0-100, higher = more future-proof
 53:   }
 54:   
 55:   // Data Sources
 56:   metadata: {
 57:     analyzedAt: string
 58:     sources: string[]
 59:     confidence: 'high' | 'medium' | 'low'
 60:   }
 61: }
 62: 
 63: export class JobOutlookAnalyzer {
 64:   /**
 65:    * Analyze job outlook using Perplexity AI with real-time market data
 66:    */
 67:   static async analyzeJobOutlook(
 68:     jobTitle: string,
 69:     location: string = 'Canada'
 70:   ): Promise<JobOutlook> {
 71:     const SYSTEM_PROMPT = `You are a labor market analyst and AI/automation expert specializing in Canadian and US job markets.
 72: 
 73: Analyze job outlook with:
 74: 1. 5-year demand and salary projections (year-by-year)
 75: 2. AI/automation risk assessment with timeline
 76: 3. Vulnerable vs. safe job tasks
 77: 4. Current market intelligence
 78: 5. Emerging and declining skills
 79: 6. Career recommendations and pivot opportunities
 80: 
 81: Use REAL data from:
 82: - Statistics Canada
 83: - US Bureau of Labor Statistics  
 84: - LinkedIn Workforce Reports
 85: - Indeed job market data
 86: - McKinsey automation studies
 87: - WEF Future of Jobs reports
 88: 
 89: OUTPUT ONLY valid JSON, no explanations.`
 90: 
 91:     const USER_PROMPT = `Analyze the job outlook for: "${jobTitle}" in ${location}
 92: 
 93: Provide comprehensive 5-year analysis including automation risk.
 94: 
 95: Return ONLY this JSON:
 96: {
 97:   "jobTitle": "${jobTitle}",
 98:   "location": "${location}",
 99:   "projections": [
100:     {
101:       "year": 2025,
102:       "demandTrend": "increasing",
103:       "salaryGrowth": 3.5,
104:       "jobOpenings": 15000
105:     }
106:   ],
107:   "automation": {
108:     "riskLevel": "medium",
109:     "riskScore": 45,
110:     "automationTimeline": "10-15 years",
111:     "vulnerableTasks": ["Task 1", "Task 2"],
112:     "safeTasks": ["Task 1", "Task 2"],
113:     "recommendations": ["Learn AI tools", "Focus on strategic thinking"]
114:   },
115:   "market": {
116:     "currentDemand": "high",
117:     "competitionLevel": "competitive",
118:     "emergingSkills": ["AI/ML", "Data Analysis"],
119:     "decliningSkills": ["Manual data entry"],
120:     "topIndustries": ["Technology", "Finance"],
121:     "averageSalary": {
122:       "min": 60000,
123:       "max": 120000,
124:       "median": 85000,
125:       "currency": "CAD"
126:     }
127:   },
128:   "recommendations": {
129:     "upskilling": ["Learn Python", "Get certified in X"],
130:     "pivotOpportunities": ["Data Analyst", "Product Manager"],
131:     "certifications": ["PMP", "AWS Cloud"],
132:     "safetyScore": 75
133:   },
134:   "metadata": {
135:     "analyzedAt": "${new Date().toISOString()}",
136:     "sources": ["Statistics Canada", "LinkedIn Workforce Report"],
137:     "confidence": "high"
138:   }
139: }`
140: 
141:     try {
142:       const response = await PerplexityIntelligenceService.customQuery({
143:         systemPrompt: SYSTEM_PROMPT,
144:         userPrompt: USER_PROMPT,
145:         temperature: 0.2,
146:         maxTokens: 3000
147:       })
148: 
149:       // Extract JSON from response.content
150:       let text = response.content.trim()
151:       const jsonMatch = text.match(/\{[\s\S]*\}/)
152:       if (jsonMatch) {
153:         text = jsonMatch[0]
154:       }
155: 
156:       const outlook = JSON.parse(text) as JobOutlook
157: 
158:       // Validate and provide defaults
159:       return {
160:         jobTitle: outlook.jobTitle || jobTitle,
161:         location: outlook.location || location,
162:         projections: outlook.projections || this.defaultProjections(),
163:         automation: outlook.automation || this.defaultAutomation(),
164:         market: outlook.market || this.defaultMarket(),
165:         recommendations: outlook.recommendations || this.defaultRecommendations(),
166:         metadata: outlook.metadata || {
167:           analyzedAt: new Date().toISOString(),
168:           sources: ['Perplexity AI'],
169:           confidence: 'medium'
170:         }
171:       }
172:     } catch (error) {
173:       console.error('[JOB OUTLOOK ANALYZER] Failed:', error)
174:       
175:       // Fallback to general outlook
176:       return this.fallbackOutlook(jobTitle, location)
177:     }
178:   }
179: 
180:   /**
181:    * Quick automation risk check (faster, less comprehensive)
182:    */
183:   static async quickAutomationRisk(jobTitle: string): Promise<{
184:     riskLevel: 'low' | 'medium' | 'high' | 'critical'
185:     riskScore: number
186:     summary: string
187:   }> {
188:     const QUICK_PROMPT = `What is the automation risk for "${jobTitle}" jobs? 
189:     
190: Return JSON:
191: {
192:   "riskLevel": "low|medium|high|critical",
193:   "riskScore": 0-100,
194:   "summary": "One sentence explanation"
195: }`
196: 
197:     try {
198:       const response = await PerplexityIntelligenceService.customQuery({
199:         systemPrompt: 'You assess job automation risk based on AI capabilities.',
200:         userPrompt: QUICK_PROMPT,
201:         temperature: 0.2,
202:         maxTokens: 300
203:       })
204: 
205:       const data = JSON.parse(response.content.match(/\{[\s\S]*\}/)![0])
206:       return data
207:     } catch {
208:       return {
209:         riskLevel: 'medium',
210:         riskScore: 50,
211:         summary: 'Unable to assess automation risk at this time.'
212:       }
213:     }
214:   }
215: 
216:   // Fallback data
217:   private static fallbackOutlook(jobTitle: string, location: string): JobOutlook {
218:     return {
219:       jobTitle,
220:       location,
221:       projections: this.defaultProjections(),
222:       automation: this.defaultAutomation(),
223:       market: this.defaultMarket(),
224:       recommendations: this.defaultRecommendations(),
225:       metadata: {
226:         analyzedAt: new Date().toISOString(),
227:         sources: ['Fallback data'],
228:         confidence: 'low'
229:       }
230:     }
231:   }
232: 
233:   private static defaultProjections() {
234:     return [2025, 2026, 2027, 2028, 2029].map((year, i) => ({
235:       year,
236:       demandTrend: 'stable' as const,
237:       salaryGrowth: 2.5 + i * 0.5,
238:       jobOpenings: 10000 + i * 1000
239:     }))
240:   }
241: 
242:   private static defaultAutomation() {
243:     return {
244:       riskLevel: 'medium' as const,
245:       riskScore: 50,
246:       automationTimeline: '10-15 years',
247:       vulnerableTasks: ['Routine data entry', 'Basic report generation'],
248:       safeTasks: ['Strategic planning', 'Client relationship management'],
249:       recommendations: [
250:         'Focus on soft skills and strategic thinking',
251:         'Learn to work with AI tools',
252:         'Develop leadership capabilities'
253:       ]
254:     }
255:   }
256: 
257:   private static defaultMarket() {
258:     return {
259:       currentDemand: 'moderate' as const,
260:       competitionLevel: 'competitive' as const,
261:       emergingSkills: ['AI/ML literacy', 'Data analysis', 'Cloud computing'],
262:       decliningSkills: ['Manual processes', 'Legacy systems'],
263:       topIndustries: ['Technology', 'Finance', 'Healthcare'],
264:       averageSalary: {
265:         min: 50000,
266:         max: 100000,
267:         median: 70000,
268:         currency: 'CAD'
269:       }
270:     }
271:   }
272: 
273:   private static defaultRecommendations() {
274:     return {
275:       upskilling: ['Learn AI tools', 'Improve data literacy', 'Develop soft skills'],
276:       pivotOpportunities: ['Data Analyst', 'Project Manager', 'Business Analyst'],
277:       certifications: ['PMP', 'Scrum Master', 'Google Analytics'],
278:       safetyScore: 65
279:     }
280:   }
281: }
</file>

<file path="src/lib/linkedin-job-integration.ts">
  1: /**
  2:  * Complete LinkedIn + Job Scraping Integration
  3:  * Combines OAuth, job search, and contact validation
  4:  */
  5: 
  6: import { PerplexityIntelligenceService, type JobListing } from './perplexity-intelligence'
  7: import { validateHiringContacts, filterContactsByScore, getBestContact, type ValidatedContact } from './contact-validation'
  8: 
  9: export interface JobWithContacts {
 10:   job: JobListing
 11:   contacts: ValidatedContact[]
 12:   bestContact: ValidatedContact | null
 13:   contactStats: {
 14:     total: number
 15:     withEmail: number
 16:     withLinkedIn: number
 17:     validated: number
 18:   }
 19: }
 20: 
 21: export interface JobSearchResult {
 22:   success: boolean
 23:   totalJobs: number
 24:   jobsWithContacts: number
 25:   jobs: JobWithContacts[]
 26:   searchMetadata: {
 27:     location: string
 28:     role: string
 29:     duration: number
 30:     timestamp: number
 31:   }
 32: }
 33: 
 34: /**
 35:  * Main integration function: Find jobs with verified hiring contacts
 36:  */
 37: export async function findJobsWithVerifiedContacts(
 38:   location: string,
 39:   role: string,
 40:   resumeText: string,
 41:   options: {
 42:     maxJobs?: number
 43:     workType?: 'remote' | 'hybrid' | 'onsite' | 'any'
 44:     minContactScore?: number
 45:   } = {}
 46: ): Promise<JobSearchResult> {
 47:   const startTime = Date.now()
 48:   const maxJobs = options.maxJobs || 10
 49:   const minContactScore = options.minContactScore || 50
 50: 
 51:   console.log(`🔍 Starting job search: ${role} in ${location}`)
 52: 
 53:   // 1. Search for jobs
 54:   const jobsResult = await PerplexityIntelligenceService.jobMarketAnalysisV2(
 55:     location,
 56:     resumeText,
 57:     {
 58:       roleHint: role,
 59:       maxResults: 40,
 60:       workType: options.workType || 'any'
 61:     }
 62:   )
 63: 
 64:   if (!jobsResult.success || jobsResult.data.length === 0) {
 65:     console.log('❌ No jobs found')
 66:     return {
 67:       success: false,
 68:       totalJobs: 0,
 69:       jobsWithContacts: 0,
 70:       jobs: [],
 71:       searchMetadata: {
 72:         location,
 73:         role,
 74:         duration: Date.now() - startTime,
 75:         timestamp: startTime
 76:       }
 77:     }
 78:   }
 79: 
 80:   console.log(`✅ Found ${jobsResult.data.length} jobs`)
 81: 
 82:   // 2. For each job, find and validate hiring contacts
 83:   const jobsWithContacts: JobWithContacts[] = []
 84:   const topJobs = jobsResult.data.slice(0, maxJobs)
 85: 
 86:   for (let i = 0; i < topJobs.length; i++) {
 87:     const job = topJobs[i]
 88:     console.log(`\n[${i + 1}/${topJobs.length}] 📧 Finding contacts for ${job.company}...`)
 89: 
 90:     try {
 91:       // Find contacts
 92:       const contactsResult = await PerplexityIntelligenceService.hiringContactsWithAgent(
 93:         job.company
 94:       )
 95: 
 96:       if (!contactsResult.success || contactsResult.data.length === 0) {
 97:         console.log(`  ⚠️ No contacts found`)
 98:         jobsWithContacts.push({
 99:           job,
100:           contacts: [],
101:           bestContact: null,
102:           contactStats: {
103:             total: 0,
104:             withEmail: 0,
105:             withLinkedIn: 0,
106:             validated: 0
107:           }
108:         })
109:         continue
110:       }
111: 
112:       console.log(`  ✅ Found ${contactsResult.data.length} potential contacts`)
113: 
114:       // Validate contacts
115:       const validatedContacts = await validateHiringContacts(contactsResult.data)
116:       const filteredContacts = filterContactsByScore(validatedContacts, minContactScore)
117:       const bestContact = getBestContact(filteredContacts)
118: 
119:       // Calculate stats
120:       const contactStats = {
121:         total: validatedContacts.length,
122:         withEmail: validatedContacts.filter(c => c.validation.emailValid).length,
123:         withLinkedIn: validatedContacts.filter(c => c.validation.linkedInValid).length,
124:         validated: filteredContacts.length
125:       }
126: 
127:       console.log(`  📊 Stats: ${contactStats.validated}/${contactStats.total} validated (score ≥${minContactScore})`)
128:       
129:       if (bestContact) {
130:         console.log(`  ⭐ Best: ${bestContact.name} (${bestContact.title}) - Score: ${bestContact.validation.overallScore}`)
131:       }
132: 
133:       jobsWithContacts.push({
134:         job,
135:         contacts: filteredContacts,
136:         bestContact,
137:         contactStats
138:       })
139: 
140:     } catch (error) {
141:       console.error(`  ❌ Error processing ${job.company}:`, error)
142:       jobsWithContacts.push({
143:         job,
144:         contacts: [],
145:         bestContact: null,
146:         contactStats: {
147:           total: 0,
148:           withEmail: 0,
149:           withLinkedIn: 0,
150:           validated: 0
151:         }
152:       })
153:     }
154: 
155:     // Small delay to avoid rate limits
156:     if (i < topJobs.length - 1) {
157:       await new Promise(resolve => setTimeout(resolve, 1000))
158:     }
159:   }
160: 
161:   const duration = Date.now() - startTime
162:   const jobsWithValidContacts = jobsWithContacts.filter(j => j.contacts.length > 0).length
163: 
164:   console.log(`\n✅ Complete! Found ${jobsWithValidContacts}/${jobsWithContacts.length} jobs with verified contacts`)
165:   console.log(`⏱️ Duration: ${(duration / 1000).toFixed(1)}s`)
166: 
167:   return {
168:     success: true,
169:     totalJobs: jobsWithContacts.length,
170:     jobsWithContacts: jobsWithValidContacts,
171:     jobs: jobsWithContacts,
172:     searchMetadata: {
173:       location,
174:       role,
175:       duration,
176:       timestamp: startTime
177:     }
178:   }
179: }
180: 
181: /**
182:  * Export results to JSON
183:  */
184: export function exportJobsToJSON(result: JobSearchResult): string {
185:   return JSON.stringify(result, null, 2)
186: }
187: 
188: /**
189:  * Export results to CSV
190:  */
191: export function exportJobsToCSV(result: JobSearchResult): string {
192:   const headers = [
193:     'Job Title',
194:     'Company',
195:     'Location',
196:     'URL',
197:     'Salary',
198:     'Work Type',
199:     'Posted Date',
200:     'Match %',
201:     'Contact Name',
202:     'Contact Title',
203:     'Contact Email',
204:     'Contact LinkedIn',
205:     'Contact Score'
206:   ]
207: 
208:   const rows = result.jobs.map(item => {
209:     const contact = item.bestContact
210:     return [
211:       item.job.title,
212:       item.job.company,
213:       item.job.location,
214:       item.job.url,
215:       item.job.salary || 'N/A',
216:       item.job.workType,
217:       item.job.postedDate,
218:       item.job.skillMatchPercent,
219:       contact?.name || 'N/A',
220:       contact?.title || 'N/A',
221:       contact?.email || 'N/A',
222:       contact?.linkedinUrl || 'N/A',
223:       contact?.validation.overallScore || 0
224:     ].map(val => `"${val}"`).join(',')
225:   })
226: 
227:   return [headers.join(','), ...rows].join('\n')
228: }
229: 
230: /**
231:  * Generate outreach email for a job
232:  */
233: export async function generateOutreachForJob(
234:   jobWithContacts: JobWithContacts,
235:   userProfile: {
236:     name: string
237:     currentRole?: string
238:     summary?: string
239:   }
240: ): Promise<string | null> {
241:   if (!jobWithContacts.bestContact) {
242:     return null
243:   }
244: 
245:   const contact = jobWithContacts.bestContact
246:   const job = jobWithContacts.job
247: 
248:   // Use Perplexity to generate personalized outreach
249:   // This would call your existing outreach generation function
250:   const outreach = `Subject: ${job.title} at ${job.company}
251: 
252: Hi ${contact.name?.split(' ')[0] || 'there'},
253: 
254: I noticed ${job.company} is hiring for a ${job.title} position. With my background in ${userProfile.currentRole || 'this field'}, I believe I'd be a strong fit.
255: 
256: ${userProfile.summary || 'I have relevant experience and skills that align well with this role.'}
257: 
258: I'd love to learn more about the position and discuss how I can contribute to ${job.company}'s success.
259: 
260: Best regards,
261: ${userProfile.name}
262: 
263: ---
264: Job: ${job.url}
265: ${contact.linkedinUrl ? `LinkedIn: ${contact.linkedinUrl}` : ''}
266: `
267: 
268:   return outreach
269: }
270: 
271: /**
272:  * Example usage
273:  */
274: export async function exampleUsage() {
275:   const result = await findJobsWithVerifiedContacts(
276:     'Toronto, ON',
277:     'Product Manager',
278:     'Experienced Product Manager with 5 years in SaaS. Led product teams, launched features, drove growth.',
279:     {
280:       maxJobs: 5,
281:       workType: 'hybrid',
282:       minContactScore: 60
283:     }
284:   )
285: 
286:   // Export to JSON
287:   console.log('\n📄 JSON Export:')
288:   console.log(exportJobsToJSON(result))
289: 
290:   // Export to CSV
291:   console.log('\n📊 CSV Export:')
292:   console.log(exportJobsToCSV(result))
293: 
294:   // Generate outreach for first job with contacts
295:   const jobWithContact = result.jobs.find(j => j.bestContact)
296:   if (jobWithContact) {
297:     const outreach = await generateOutreachForJob(jobWithContact, {
298:       name: 'John Doe',
299:       currentRole: 'Senior Product Manager',
300:       summary: 'Led product strategy for B2B SaaS platform with 10k+ users'
301:     })
302:     console.log('\n📧 Sample Outreach:')
303:     console.log(outreach)
304:   }
305: 
306:   return result
307: }
</file>

<file path="package.json">
  1: {
  2:     "name": "career-lever-ai",
  3:     "version": "1.0.0",
  4:     "description": "AI-powered job application assistant for resume customization and company research",
  5:     "main": "index.js",
  6:     "engines": {
  7:         "node": ">=20.x",
  8:         "npm": ">=10.0.0"
  9:     },
 10:     "scripts": {
 11:         "dev": "next dev",
 12:         "build": "next build",
 13:         "build:mobile": "node scripts/build-mobile.js",
 14:         "start": "next start -H 0.0.0.0 -p ${PORT:-8080}",
 15:         "lint": "next lint",
 16:         "type-check": "tsc --noEmit",
 17:         "check:env": "node scripts/check-env.js",
 18:         "prebuild": "echo '✅ Environment variables will be validated at runtime'",
 19:         "test": "vitest run --reporter=verbose",
 20:         "debug:perplexity": "node debug-perplexity.js",
 21:         "test:perplexity": "PPX_DEBUG=true node -e \"require('./debug-perplexity.js')\"",
 22:         "cap:init": "npx cap init",
 23:         "cap:add:ios": "npx cap add ios",
 24:         "cap:add:android": "npx cap add android",
 25:         "cap:sync": "npx cap sync",
 26:         "cap:open:ios": "npx cap open ios",
 27:         "cap:open:android": "npx cap open android",
 28:         "mobile:build": "npm run build:mobile && npx cap sync",
 29:         "mobile:ios": "npm run mobile:build && npx cap open ios",
 30:         "mobile:android": "npm run mobile:build && npx cap open android"
 31:     },
 32:     "dependencies": {
 33:         "@auth/mongodb-adapter": "^3.10.0",
 34:         "@capacitor/android": "7.4.3",
 35:         "@capacitor/app": "7.1.0",
 36:         "@capacitor/core": "7.4.3",
 37:         "@capacitor/filesystem": "7.1.4",
 38:         "@capacitor/haptics": "7.0.2",
 39:         "@capacitor/ios": "7.4.3",
 40:         "@capacitor/keyboard": "7.0.3",
 41:         "@capacitor/network": "7.0.2",
 42:         "@capacitor/share": "7.0.2",
 43:         "@capacitor/splash-screen": "7.0.3",
 44:         "@capacitor/status-bar": "7.0.3",
 45:         "@heroicons/react": "^2.2.0",
 46:         "@hookform/resolvers": "^3.3.0",
 47:         "@next/env": "14.2.33",
 48:         "@radix-ui/react-alert-dialog": "^1.1.15",
 49:         "@radix-ui/react-avatar": "^1.1.10",
 50:         "@radix-ui/react-checkbox": "^1.3.3",
 51:         "@radix-ui/react-dialog": "^1.1.15",
 52:         "@radix-ui/react-dropdown-menu": "^2.1.16",
 53:         "@radix-ui/react-label": "^2.1.7",
 54:         "@radix-ui/react-progress": "^1.1.7",
 55:         "@radix-ui/react-select": "^2.2.6",
 56:         "@radix-ui/react-separator": "^1.1.7",
 57:         "@radix-ui/react-slot": "^1.0.0",
 58:         "@radix-ui/react-tabs": "^1.1.13",
 59:         "@radix-ui/react-toast": "^1.2.15",
 60:         "@react-pdf/renderer": "4.3.1",
 61:         "@sentry/nextjs": "^8.35.0",
 62:         "@sparticuz/chromium": "^138.0.2",
 63:         "@stripe/stripe-js": "8.1.0",
 64:         "@tanstack/react-query": "^5.90.2",
 65:         "@types/bcryptjs": "^2.4.6",
 66:         "@types/jsonwebtoken": "^9.0.0",
 67:         "@types/mongoose": "^5.11.97",
 68:         "@types/multer": "^1.4.11",
 69:         "@types/node": "^20.0.0",
 70:         "@types/pdfkit": "0.17.3",
 71:         "@types/react": "^18.2.0",
 72:         "@types/react-dom": "^18.2.0",
 73:         "ajv": "8.17.1",
 74:         "ajv-formats": "3.0.1",
 75:         "autoprefixer": "^10.4.0",
 76:         "bcryptjs": "^2.4.3",
 77:         "canvas-confetti": "1.9.3",
 78:         "chart.js": "4.5.1",
 79:         "cheerio": "1.1.2",
 80:         "class-variance-authority": "^0.7.0",
 81:         "clsx": "^2.1.1",
 82:         "date-fns": "^4.1.0",
 83:         "docx": "9.5.1",
 84:         "file-saver": "2.0.5",
 85:         "framer-motion": "10.18.0",
 86:         "ioredis": "5.8.2",
 87:         "isomorphic-dompurify": "^2.28.0",
 88:         "jsonwebtoken": "^9.0.0",
 89:         "jspdf": "^3.0.3",
 90:         "lucide-react": "^0.294.0",
 91:         "mongodb": "6.11.0",
 92:         "mongoose": "8.19.1",
 93:         "multer": "^1.4.5-lts.1",
 94:         "next": "14.2.33",
 95:         "next-auth": "^4.24.10",
 96:         "pdf-parse-debugging-disabled": "1.1.1",
 97:         "pdfjs-dist": "^4.2.0",
 98:         "pdfkit": "0.17.2",
 99:         "postcss": "^8.4.0",
100:         "puppeteer": "24.25.0",
101:         "puppeteer-core": "^24.22.0",
102:         "react": "^18.2.0",
103:         "react-chartjs-2": "5.3.0",
104:         "react-dom": "^18.2.0",
105:         "react-dropzone": "^14.2.0",
106:         "react-hook-form": "^7.48.0",
107:         "react-hot-toast": "^2.4.1",
108:         "redis": "4.6.14",
109:         "resend": "6.2.2",
110:         "stripe": "19.1.0",
111:         "tailwind-merge": "^2.6.0",
112:         "tailwindcss": "^3.3.0",
113:         "tailwindcss-animate": "^1.0.7",
114:         "zod": "^3.25.76",
115:         "zustand": "^5.0.8"
116:     },
117:     "overrides": {
118:         "next": "14.2.33",
119:         "@next/env": "14.2.33",
120:         "chromium-bidi": "0.5.10",
121:         "webdriver-bidi-protocol": "0.3.8"
122:     },
123:     "devDependencies": {
124:         "@capacitor/cli": "7.4.3",
125:         "@playwright/test": "1.56.1",
126:         "@tanstack/react-query-devtools": "^5.90.2",
127:         "@typescript-eslint/eslint-plugin": "6.21.0",
128:         "@typescript-eslint/parser": "6.21.0",
129:         "@vitest/coverage-v8": "3.2.4",
130:         "esbuild": "^0.25.10",
131:         "eslint": "8.57.1",
132:         "eslint-config-next": "^14.0.0",
133:         "mongodb-memory-server": "10.2.0",
134:         "prettier": "^3.0.0",
135:         "typescript": "5.3.3",
136:         "vitest": "^3.2.4"
137:     },
138:     "keywords": [
139:         "job-application",
140:         "resume",
141:         "ai",
142:         "career",
143:         "recruitment"
144:     ],
145:     "author": "Career Lever AI Team",
146:     "license": "MIT"
147: }
</file>

<file path="src/components/resume-builder/template-selector.tsx">
 1: 'use client'
 2: 
 3: import { TemplatePreview } from './template-preview'
 4: 
 5: const TEMPLATES = [
 6:   {
 7:     id: 'modern',
 8:     name: 'Modern',
 9:     description: 'Clean, contemporary design with gradient header',
10:     preview: '🎨',
11:     color: 'from-blue-500 to-purple-600',
12:     recommended: true
13:   },
14:   {
15:     id: 'professional',
16:     name: 'Professional',
17:     description: 'Traditional layout perfect for corporate roles',
18:     preview: '💼',
19:     color: 'from-gray-700 to-gray-900',
20:     recommended: false
21:   },
22:   {
23:     id: 'creative',
24:     name: 'Creative',
25:     description: 'Bold, colorful design for creative industries',
26:     preview: '🎭',
27:     color: 'from-pink-500 to-orange-500',
28:     recommended: false
29:   },
30:   {
31:     id: 'tech',
32:     name: 'Tech-Focused',
33:     description: 'Code-friendly with monospace accents',
34:     preview: '💻',
35:     color: 'from-green-500 to-teal-600',
36:     recommended: false
37:   },
38:   {
39:     id: 'minimal',
40:     name: 'Minimal',
41:     description: 'ATS-optimized, maximum compatibility',
42:     preview: '📄',
43:     color: 'from-gray-400 to-gray-600',
44:     recommended: false
45:   },
46:   {
47:     id: 'executive',
48:     name: 'Executive',
49:     description: 'Premium, leadership-focused design',
50:     preview: '👔',
51:     color: 'from-indigo-600 to-purple-700',
52:     recommended: false
53:   }
54: ]
55: 
56: interface TemplateSelectorProps {
57:   selectedTemplate: string
58:   onSelectTemplate: (templateId: string) => void
59: }
60: 
61: export function TemplateSelector({ selectedTemplate, onSelectTemplate }: TemplateSelectorProps) {
62:   return (
63:     <div className="bg-card rounded-xl border-2 border-border p-6">
64:       <h3 className="text-xl font-bold text-foreground mb-4">Choose Your Template</h3>
65:       
66:       <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
67:         {TEMPLATES.map((template) => (
68:           <TemplatePreview
69:             key={template.id}
70:             id={template.id}
71:             name={template.name}
72:             description={template.description}
73:             isSelected={selectedTemplate === template.id}
74:             onSelect={() => onSelectTemplate(template.id)}
75:             recommended={template.recommended}
76:           />
77:         ))}
78:       </div>
79: 
80:       <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-950/30 rounded-lg border border-blue-200 dark:border-blue-800">
81:         <p className="text-sm text-blue-800 dark:text-blue-300">
82:           <strong>💡 Tip:</strong> All templates are ATS-compatible. Choose based on your industry and personal style!
83:         </p>
84:       </div>
85:     </div>
86:   )
87: }
</file>

<file path="src/lib/scrapers/advanced-scraper.ts">
  1: /**
  2:  * Advanced Web Scraper with 4-Tier Fallback Strategy
  3:  * 
  4:  * Strategy 1: JSON-LD Structured Data (fastest, most reliable)
  5:  * Strategy 2: Cheerio HTML Parsing (fast, reliable for static sites)
  6:  * Strategy 3: Puppeteer Browser (for JavaScript-heavy sites)
  7:  * Strategy 4: Regex Extraction (last resort)
  8:  */
  9: 
 10: import * as cheerio from 'cheerio'
 11: import puppeteer from 'puppeteer-core'
 12: import chromium from '@sparticuz/chromium'
 13: 
 14: export interface ScrapeResult {
 15:   success: boolean
 16:   data?: {
 17:     title?: string
 18:     description?: string
 19:     requirements?: string[]
 20:     salary?: string
 21:     company?: string
 22:     location?: string
 23:     postedDate?: string
 24:   }
 25:   method?: 'structured' | 'cheerio' | 'puppeteer' | 'regex'
 26:   error?: string
 27: }
 28: 
 29: export class AdvancedScraper {
 30:   private readonly USER_AGENTS = [
 31:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
 32:     'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
 33:     'Mozilla/5.0 (X11; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0',
 34:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0'
 35:   ]
 36: 
 37:   /**
 38:    * Main scraping method with 3-tier fallback
 39:    */
 40:   async scrape(url: string): Promise<ScrapeResult> {
 41:     if (process.env.PPX_DEBUG === 'true') {
 42:       console.log(`[SCRAPER] Processing: ${url}`)
 43:     }
 44: 
 45:     // Strategy 1: Structured data (JSON-LD) - fastest and most reliable
 46:     try {
 47:       const structured = await this.tryStructuredData(url)
 48:       if (structured.success && structured.data?.description && structured.data.description.length > 100) {
 49:         if (process.env.PPX_DEBUG === 'true') {
 50:           console.log('[SCRAPER] ✓ Structured data found')
 51:         }
 52:         return { ...structured, method: 'structured' }
 53:       }
 54:     } catch (e) {
 55:       if (process.env.PPX_DEBUG === 'true') {
 56:         console.log('[SCRAPER] Structured data failed:', (e as Error).message)
 57:       }
 58:     }
 59: 
 60:     // Strategy 2: Cheerio HTML parsing - fast and reliable for static sites
 61:     try {
 62:       const cheerioResult = await this.tryCheerioScraping(url)
 63:       if (cheerioResult.success && cheerioResult.data?.description && cheerioResult.data.description.length > 100) {
 64:         if (process.env.PPX_DEBUG === 'true') {
 65:           console.log('[SCRAPER] ✓ Cheerio parsing succeeded')
 66:         }
 67:         return { ...cheerioResult, method: 'cheerio' }
 68:       }
 69:     } catch (e) {
 70:       if (process.env.PPX_DEBUG === 'true') {
 71:         console.log('[SCRAPER] Cheerio failed:', (e as Error).message)
 72:       }
 73:     }
 74: 
 75:     // Strategy 3: Puppeteer browser - for JavaScript-heavy sites (Indeed, LinkedIn, etc.)
 76:     try {
 77:       const puppeteerResult = await this.tryPuppeteerScraping(url)
 78:       if (puppeteerResult.success && puppeteerResult.data?.description && puppeteerResult.data.description.length > 100) {
 79:         if (process.env.PPX_DEBUG === 'true') {
 80:           console.log('[SCRAPER] ✓ Puppeteer scraping succeeded')
 81:         }
 82:         return { ...puppeteerResult, method: 'puppeteer' }
 83:       }
 84:     } catch (e) {
 85:       if (process.env.PPX_DEBUG === 'true') {
 86:         console.log('[SCRAPER] Puppeteer failed:', (e as Error).message)
 87:       }
 88:     }
 89: 
 90:     // Strategy 4: Regex extraction - last resort
 91:     try {
 92:       const regex = await this.tryRegexExtraction(url)
 93:       if (regex.success && regex.data?.description && regex.data.description.length > 100) {
 94:         if (process.env.PPX_DEBUG === 'true') {
 95:           console.log('[SCRAPER] ✓ Regex extraction succeeded')
 96:         }
 97:         return { ...regex, method: 'regex' }
 98:       }
 99:     } catch (e) {
100:       if (process.env.PPX_DEBUG === 'true') {
101:         console.log('[SCRAPER] Regex failed:', (e as Error).message)
102:       }
103:     }
104: 
105:     return {
106:       success: false,
107:       error: 'All 4 scraping strategies failed - page may require login or CAPTCHA'
108:     }
109:   }
110: 
111:   /**
112:    * Strategy 1: Extract JSON-LD structured data
113:    * Many job boards include this for SEO
114:    */
115:   private async tryStructuredData(url: string): Promise<ScrapeResult> {
116:     const html = await this.fetchHTML(url)
117:     const jsonLdMatches = html.match(/<script type="application\/ld\+json">(.*?)<\/script>/gs)
118: 
119:     if (!jsonLdMatches) {
120:       return { success: false, error: 'No structured data found' }
121:     }
122: 
123:     for (const match of jsonLdMatches) {
124:       try {
125:         const json = JSON.parse(match.replace(/<\/?script[^>]*>/g, ''))
126: 
127:         // Check for JobPosting schema
128:         if (json['@type'] === 'JobPosting') {
129:           return {
130:             success: true,
131:             data: {
132:               title: json.title,
133:               description: json.description,
134:               company: json.hiringOrganization?.name,
135:               location: json.jobLocation?.address?.addressLocality || json.jobLocation?.address?.addressRegion,
136:               salary: this.extractSalaryFromStructured(json.baseSalary),
137:               postedDate: json.datePosted
138:             }
139:           }
140:         }
141:       } catch {
142:         continue
143:       }
144:     }
145: 
146:     return { success: false, error: 'No JobPosting structured data found' }
147:   }
148: 
149:   /**
150:    * Strategy 2: Cheerio HTML parsing
151:    * Works for most standard HTML pages
152:    */
153:   private async tryCheerioScraping(url: string): Promise<ScrapeResult> {
154:     const html = await this.fetchHTML(url)
155:     const $ = cheerio.load(html)
156: 
157:     // Remove noise elements
158:     $('script, style, nav, header, footer, aside, .advertisement, .ads').remove()
159: 
160:     // Try multiple selectors for description (ordered by specificity)
161:     const descriptionSelectors = [
162:       '.job-description',
163:       '[class*="job-description"]',
164:       '[class*="description"]',
165:       '[id*="description"]',
166:       '[class*="job-details"]',
167:       '[class*="jobDetails"]',
168:       '[data-job-description]',
169:       'article',
170:       'main',
171:       '.content'
172:     ]
173: 
174:     let description = ''
175:     for (const selector of descriptionSelectors) {
176:       const text = $(selector).text().trim()
177:       if (text.length > description.length && text.length > 100) {
178:         description = text
179:       }
180:     }
181: 
182:     // Extract title
183:     const title = 
184:       $('h1.job-title').text() ||
185:       $('[class*="job-title"]').first().text() ||
186:       $('[class*="jobTitle"]').first().text() ||
187:       $('h1').first().text() ||
188:       ''
189: 
190:     // Extract requirements
191:     const requirements: string[] = []
192:     $('.requirements li, .qualifications li, [class*="requirement"] li, [class*="qualification"] li').each((i, el) => {
193:       const req = $(el).text().trim()
194:       if (req && req.length > 10 && req.length < 500) {
195:         requirements.push(req)
196:       }
197:     })
198: 
199:     // Extract salary
200:     const salary = this.extractSalaryFromText(html)
201: 
202:     // Extract company
203:     const company = 
204:       $('[class*="company-name"]').first().text() ||
205:       $('[class*="companyName"]').first().text() ||
206:       $('[data-company]').text() ||
207:       ''
208: 
209:     // Extract location
210:     const location = 
211:       $('[class*="location"]').first().text() ||
212:       $('[class*="job-location"]').first().text() ||
213:       ''
214: 
215:     return {
216:       success: description.length > 100,
217:       data: {
218:         title: this.cleanText(title),
219:         description: this.cleanText(description),
220:         requirements,
221:         salary: this.cleanText(salary),
222:         company: this.cleanText(company),
223:         location: this.cleanText(location)
224:       }
225:     }
226:   }
227: 
228:   /**
229:    * Strategy 3: Puppeteer browser scraping (for JavaScript-heavy sites)
230:    * Handles Indeed, LinkedIn, Glassdoor, and other dynamic job boards
231:    */
232:   private async tryPuppeteerScraping(url: string): Promise<ScrapeResult> {
233:     let browser: Awaited<ReturnType<typeof puppeteer.launch>> | null = null
234:     try {
235:       // Launch headless browser with optimized settings
236:       const args = [
237:         ...chromium.args,
238:         '--no-sandbox',
239:         '--disable-setuid-sandbox',
240:         '--disable-dev-shm-usage',
241:         '--disable-gpu',
242:         '--no-first-run',
243:         '--no-zygote',
244:         '--single-process',
245:         '--disable-blink-features=AutomationControlled'
246:       ]
247: 
248:       const executablePath = process.env.CHROMIUM_PATH || await chromium.executablePath()
249: 
250:       browser = await puppeteer.launch({
251:         args,
252:         executablePath,
253:         headless: true,
254:         timeout: 30000
255:       })
256: 
257:       const page = await browser.newPage()
258: 
259:       // Set realistic user agent and viewport
260:       const userAgent = this.USER_AGENTS[Math.floor(Math.random() * this.USER_AGENTS.length)]
261:       await page.setUserAgent(userAgent)
262:       await page.setViewport({ width: 1920, height: 1080 })
263: 
264:       // Navigate to page and wait for content
265:       await page.goto(url, {
266:         waitUntil: 'networkidle2',
267:         timeout: 30000
268:       })
269: 
270:       // Wait for job description to load (common selectors)
271:       await page.waitForSelector('body', { timeout: 5000 }).catch(() => {})
272: 
273:       // Extract job data using page.evaluate
274:       const data = await page.evaluate(() => {
275:         // Helper to clean text
276:         const cleanText = (text: string) => text.replace(/\s+/g, ' ').trim()
277: 
278:         // Extract title
279:         const titleSelectors = [
280:           'h1[class*="title"]',
281:           'h1[class*="jobTitle"]',
282:           'h1[class*="job-title"]',
283:           '[data-testid="jobTitle"]',
284:           '.job-title',
285:           'h1'
286:         ]
287:         let title = ''
288:         for (const sel of titleSelectors) {
289:           const el = document.querySelector(sel)
290:           if (el?.textContent) {
291:             title = cleanText(el.textContent)
292:             break
293:           }
294:         }
295: 
296:         // Extract description
297:         const descSelectors = [
298:           '[class*="jobDescriptionText"]',
299:           '[class*="job-description"]',
300:           '[id*="jobDescriptionText"]',
301:           '[data-testid="jobDescription"]',
302:           '.description',
303:           'article',
304:           'main'
305:         ]
306:         let description = ''
307:         for (const sel of descSelectors) {
308:           const el = document.querySelector(sel)
309:           if (el?.textContent && el.textContent.length > description.length) {
310:             description = cleanText(el.textContent)
311:           }
312:         }
313: 
314:         // Extract company
315:         const companySelectors = [
316:           '[class*="companyName"]',
317:           '[data-testid="companyName"]',
318:           '[class*="company-name"]',
319:           '.company'
320:         ]
321:         let company = ''
322:         for (const sel of companySelectors) {
323:           const el = document.querySelector(sel)
324:           if (el?.textContent) {
325:             company = cleanText(el.textContent)
326:             break
327:           }
328:         }
329: 
330:         // Extract location
331:         const locationSelectors = [
332:           '[class*="location"]',
333:           '[data-testid="location"]',
334:           '[class*="job-location"]'
335:         ]
336:         let location = ''
337:         for (const sel of locationSelectors) {
338:           const el = document.querySelector(sel)
339:           if (el?.textContent) {
340:             location = cleanText(el.textContent)
341:             break
342:           }
343:         }
344: 
345:         // Extract salary
346:         const salarySelectors = [
347:           '[class*="salary"]',
348:           '[data-testid="salary"]',
349:           '[class*="compensation"]'
350:         ]
351:         let salary = ''
352:         for (const sel of salarySelectors) {
353:           const el = document.querySelector(sel)
354:           if (el?.textContent) {
355:             salary = cleanText(el.textContent)
356:             break
357:           }
358:         }
359: 
360:         return { title, description, company, location, salary }
361:       })
362: 
363:       await browser.close()
364: 
365:       return {
366:         success: data.description.length > 100,
367:         data: {
368:           title: data.title,
369:           description: data.description,
370:           company: data.company,
371:           location: data.location,
372:           salary: data.salary || undefined
373:         }
374:       }
375:     } catch (error) {
376:       if (browser) {
377:         try { await browser.close() } catch {}
378:       }
379:       throw error
380:     }
381:   }
382: 
383:   /**
384:    * Strategy 4: Regex extraction (last resort)
385:    * Works when HTML structure is non-standard
386:    */
387:   private async tryRegexExtraction(url: string): Promise<ScrapeResult> {
388:     const html = await this.fetchHTML(url)
389: 
390:     // Extract description between common patterns
391:     const descPatterns = [
392:       /<div[^>]*class="[^"]*description[^"]*"[^>]*>(.*?)<\/div>/is,
393:       /<section[^>]*class="[^"]*job[^"]*"[^>]*>(.*?)<\/section>/is,
394:       /<article[^>]*>(.*?)<\/article>/is,
395:       /<main[^>]*>(.*?)<\/main>/is
396:     ]
397: 
398:     let description = ''
399:     for (const pattern of descPatterns) {
400:       const match = html.match(pattern)
401:       if (match && match[1].length > description.length) {
402:         description = match[1]
403:       }
404:     }
405: 
406:     // Extract title
407:     const titleMatch = html.match(/<h1[^>]*>(.*?)<\/h1>/i)
408:     const title = titleMatch ? titleMatch[1] : ''
409: 
410:     return {
411:       success: description.length > 100,
412:       data: {
413:         title: this.cleanHTML(title),
414:         description: this.cleanHTML(description)
415:       }
416:     }
417:   }
418: 
419:   /**
420:    * Fetch HTML with realistic headers to avoid bot detection
421:    */
422:   private async fetchHTML(url: string): Promise<string> {
423:     const userAgent = this.USER_AGENTS[Math.floor(Math.random() * this.USER_AGENTS.length)]
424: 
425:     const response = await fetch(url, {
426:       headers: {
427:         'User-Agent': userAgent,
428:         'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
429:         'Accept-Language': 'en-US,en;q=0.9',
430:         'Accept-Encoding': 'gzip, deflate, br',
431:         'DNT': '1',
432:         'Connection': 'keep-alive',
433:         'Upgrade-Insecure-Requests': '1',
434:         'Referer': 'https://www.google.com/'
435:       },
436:       signal: AbortSignal.timeout(15000)
437:     })
438: 
439:     if (!response.ok) {
440:       throw new Error(`HTTP ${response.status}: ${response.statusText}`)
441:     }
442: 
443:     // Add small delay to be respectful
444:     await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000))
445: 
446:     return await response.text()
447:   }
448: 
449:   /**
450:    * Helper: Extract salary from structured data
451:    */
452:   private extractSalaryFromStructured(baseSalary: any): string {
453:     if (!baseSalary) return ''
454:     if (typeof baseSalary === 'string') return baseSalary
455:     
456:     if (baseSalary.value) {
457:       const value = baseSalary.value.value || baseSalary.value
458:       const currency = baseSalary.currency || '$'
459:       return `${currency}${value}`
460:     }
461:     
462:     if (baseSalary.minValue && baseSalary.maxValue) {
463:       const currency = baseSalary.currency || '$'
464:       return `${currency}${baseSalary.minValue} - ${currency}${baseSalary.maxValue}`
465:     }
466:     
467:     return ''
468:   }
469: 
470:   /**
471:    * Helper: Extract salary from text using patterns
472:    */
473:   private extractSalaryFromText(text: string): string {
474:     const patterns = [
475:       /\$\s*[\d,]+\s*-\s*\$\s*[\d,]+/,
476:       /\$\s*[\d,]+k?\s*-\s*\$?\s*[\d,]+k?/i,
477:       /salary:\s*\$?[\d,]+\s*-\s*\$?[\d,]+/i,
478:       /[\d,]+\s*-\s*[\d,]+\s*per\s+(?:year|hour|month)/i,
479:       /compensation:\s*\$?[\d,]+\s*-\s*\$?[\d,]+/i
480:     ]
481: 
482:     for (const pattern of patterns) {
483:       const match = text.match(pattern)
484:       if (match) return match[0]
485:     }
486: 
487:     return ''
488:   }
489: 
490:   /**
491:    * Helper: Clean HTML tags and entities
492:    */
493:   private cleanHTML(html: string): string {
494:     return html
495:       .replace(/<script[^>]*>.*?<\/script>/gis, '')
496:       .replace(/<style[^>]*>.*?<\/style>/gis, '')
497:       .replace(/<[^>]+>/g, ' ')
498:       .replace(/&nbsp;/g, ' ')
499:       .replace(/&amp;/g, '&')
500:       .replace(/&lt;/g, '<')
501:       .replace(/&gt;/g, '>')
502:       .replace(/&quot;/g, '"')
503:       .replace(/&#39;/g, "'")
504:       .replace(/\s+/g, ' ')
505:       .trim()
506:   }
507: 
508:   /**
509:    * Helper: Clean text (whitespace only)
510:    */
511:   private cleanText(text: string): string {
512:     return text
513:       .replace(/\s+/g, ' ')
514:       .replace(/\n\s*\n/g, '\n')
515:       .trim()
516:   }
517: }
</file>

<file path="src/app/api/resume/upload/route.ts">
  1: import { NextRequest, NextResponse } from 'next/server'
  2: import { getServerSession } from 'next-auth/next'
  3: import { authOptions } from '@/lib/auth'
  4: import Resume from '@/models/Resume'
  5: import { dbService } from '@/lib/database'
  6: import { isRateLimited } from '@/lib/rate-limit'
  7: import path from 'path'
  8: import { cleanPDFExtraction } from '@/lib/utils/pdf-cleaner'
  9: 
 10: function cleanExtractedText(text: string): string {
 11:   // Use comprehensive PDF cleaner first
 12:   let cleaned = cleanPDFExtraction(text)
 13:   
 14:   // Additional cleaning for resume-specific content
 15:   cleaned = cleaned
 16:     .replace(/https?:\/\/[^\s]+/gi, '') // URLs
 17:     .replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi, '') // Emails (during parsing)
 18:     .replace(/\s+/g, ' ') // Whitespace
 19:     .trim()
 20:   
 21:   return cleaned
 22: }
 23: 
 24: const MIN_VALID_PDF_TEXT_LENGTH = Number(process.env.RESUME_MIN_TEXT_LENGTH || 150)
 25: const ASCII_FALLBACK_CONFIDENCE = 0.3
 26: 
 27: // AI-based OCR fallback using base64 encoding
 28: async function extractTextWithAI(buffer: Buffer): Promise<string> {
 29:   try {
 30:     console.log('[PDF_PARSE] Attempting AI-based extraction')
 31:     const { PerplexityIntelligenceService } = await import('@/lib/perplexity-intelligence')
 32:     
 33:     // Convert PDF to base64
 34:     const base64 = buffer.toString('base64')
 35:     
 36:     const result = await PerplexityIntelligenceService.customQuery({
 37:       systemPrompt: 'You are a resume text extractor. Extract ALL text from the provided PDF resume. Return ONLY the extracted text, no formatting, no markdown, no explanations.',
 38:       userPrompt: `Extract all text from this PDF resume (base64 encoded, first 1000 chars): ${base64.slice(0, 1000)}...\n\nReturn the complete resume text.`,
 39:       temperature: 0.1,
 40:       maxTokens: 4000
 41:     })
 42:     
 43:     if (result.content && result.content.length > MIN_VALID_PDF_TEXT_LENGTH) {
 44:       console.log('[PDF_PARSE] ✅ AI extraction SUCCESS:', result.content.length, 'chars')
 45:       return result.content
 46:     }
 47:     
 48:     throw new Error('AI extraction returned insufficient text')
 49:   } catch (error) {
 50:     console.error('[PDF_PARSE] ❌ AI extraction failed:', error)
 51:     throw error
 52:   }
 53: }
 54: 
 55: async function extractTextFromPDF(buffer: Buffer): Promise<{ text: string; method: string; confidence?: number }> {
 56:   console.log('[PDF_PARSE] ==========================================')
 57:   console.log('[PDF_PARSE] Starting extraction')
 58:   console.log('[PDF_PARSE] Buffer size:', buffer.length, 'bytes')
 59:   console.log('[PDF_PARSE] Buffer type:', typeof buffer)
 60:   console.log('[PDF_PARSE] Is Buffer:', Buffer.isBuffer(buffer))
 61:   console.log('[PDF_PARSE] ==========================================')
 62:   
 63:   // Try Method 1: pdf-parse-debugging-disabled (MOST RELIABLE)
 64:   try {
 65:     console.log('[PDF_PARSE] 🔄 Method 1: pdf-parse-debugging-disabled')
 66:     const pdfParse = await import('pdf-parse-debugging-disabled')
 67:     console.log('[PDF_PARSE] Module loaded:', !!pdfParse, 'default:', !!pdfParse.default)
 68:     
 69:     const data = await pdfParse.default(buffer, { 
 70:       max: 0, // Parse all pages
 71:       version: 'v2.0.550' // Specify version
 72:     })
 73:     
 74:     console.log('[PDF_PARSE] Raw result:', {
 75:       hasData: !!data,
 76:       hasText: !!data?.text,
 77:       textLength: data?.text?.length || 0,
 78:       numpages: data?.numpages,
 79:       numrender: data?.numrender,
 80:       info: data?.info,
 81:       metadata: data?.metadata
 82:     })
 83:     
 84:     if (data?.text) {
 85:       console.log('[PDF_PARSE] Raw text preview (first 500 chars):', data.text.slice(0, 500))
 86:       console.log('[PDF_PARSE] Raw text preview (last 200 chars):', data.text.slice(-200))
 87:       
 88:       const cleanedText = cleanExtractedText(data.text)
 89:       console.log('[PDF_PARSE] After cleaning:', {
 90:         rawLength: data.text.length,
 91:         cleanedLength: cleanedText.length,
 92:         preview: cleanedText.slice(0, 300)
 93:       })
 94:       
 95:       if (cleanedText.length >= 50) {
 96:         const confidence = cleanedText.length >= MIN_VALID_PDF_TEXT_LENGTH ? 0.95 : 0.6
 97:         console.log('[PDF_PARSE] ✅✅✅ Method 1 SUCCESS - confidence:', confidence)
 98:         return {
 99:           text: cleanedText,
100:           method: 'pdf-parse',
101:           confidence
102:         }
103:       } else {
104:         console.log('[PDF_PARSE] ⚠️ Method 1 extracted text but too short:', cleanedText.length, 'chars')
105:       }
106:     } else {
107:       console.log('[PDF_PARSE] ⚠️ Method 1 returned no text')
108:     }
109:   } catch (error: any) {
110:     console.error('[PDF_PARSE] ❌ Method 1 FAILED')
111:     console.error('[PDF_PARSE] Error type:', error?.constructor?.name)
112:     console.error('[PDF_PARSE] Error message:', error?.message)
113:     console.error('[PDF_PARSE] Error stack:', error?.stack)
114:   }
115: 
116:   // Try Method 2: pdfjs-dist fallback (BETTER for complex PDFs)
117:   try {
118:     console.log('[PDF_PARSE] 🔄 Method 2: pdfjs-dist')
119:     const pdfjsLib = await import('pdfjs-dist')
120:     console.log('[PDF_PARSE] pdfjs-dist module loaded')
121:     
122:     // Load the PDF document with proper TypeScript types
123:     const loadingTask = pdfjsLib.getDocument({
124:       data: new Uint8Array(buffer),
125:       verbosity: 0,
126:       useSystemFonts: true,
127:       disableFontFace: false,
128:       standardFontDataUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/standard_fonts/'
129:     })
130:     
131:     const pdfDoc = await loadingTask.promise
132:     console.log('[PDF_PARSE] Document loaded successfully')
133:     console.log('[PDF_PARSE] Pages:', pdfDoc.numPages)
134:     console.log('[PDF_PARSE] Fingerprints:', pdfDoc.fingerprints)
135:     
136:     let fullText = ''
137:     let totalChars = 0
138:     
139:     // Extract text from each page
140:     for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
141:       try {
142:         const page = await pdfDoc.getPage(pageNum)
143:         const textContent = await page.getTextContent()
144:         
145:         // Better text extraction with spacing
146:         const pageText = textContent.items
147:           .map((item: any) => {
148:             if ('str' in item && item.str) {
149:               return item.str
150:             }
151:             return ''
152:           })
153:           .filter(Boolean)
154:           .join(' ')
155:         
156:         fullText += pageText + '\n\n'
157:         totalChars += pageText.length
158:         console.log(`[PDF_PARSE] Page ${pageNum}/${pdfDoc.numPages}: ${pageText.length} chars (total: ${totalChars})`)
159:       } catch (pageError) {
160:         console.error(`[PDF_PARSE] Error on page ${pageNum}:`, pageError)
161:       }
162:     }
163:     
164:     console.log('[PDF_PARSE] Raw extraction complete:', fullText.length, 'chars')
165:     console.log('[PDF_PARSE] Raw text preview:', fullText.slice(0, 500))
166:     
167:     const cleanedText = cleanExtractedText(fullText.trim())
168:     console.log('[PDF_PARSE] After cleaning:', {
169:       rawLength: fullText.length,
170:       cleanedLength: cleanedText.length,
171:       preview: cleanedText.slice(0, 300)
172:     })
173:     
174:     if (cleanedText.length >= 50) {
175:       const confidence = cleanedText.length >= MIN_VALID_PDF_TEXT_LENGTH ? 0.9 : 0.6
176:       console.log('[PDF_PARSE] ✅✅✅ Method 2 SUCCESS - confidence:', confidence)
177:       return {
178:         text: cleanedText,
179:         method: 'pdfjs-dist',
180:         confidence
181:       }
182:     } else {
183:       console.log('[PDF_PARSE] ⚠️ Method 2 extracted text but too short:', cleanedText.length, 'chars')
184:     }
185:   } catch (error: any) {
186:     console.error('[PDF_PARSE] ❌ Method 2 FAILED')
187:     console.error('[PDF_PARSE] Error type:', error?.constructor?.name)
188:     console.error('[PDF_PARSE] Error message:', error?.message)
189:     console.error('[PDF_PARSE] Error stack:', error?.stack)
190:   }
191: 
192:   // Try Method 3: AI-based extraction (BEST for scanned/image PDFs)
193:   try {
194:     console.log('[PDF_PARSE] Attempting Method 3: AI extraction')
195:     const aiText = await extractTextWithAI(buffer)
196:     
197:     if (aiText && aiText.length >= MIN_VALID_PDF_TEXT_LENGTH) {
198:       const cleanedText = cleanExtractedText(aiText)
199:       console.log('[PDF_PARSE] ✅ Method 3 SUCCESS (AI extraction):', cleanedText.length, 'chars')
200:       
201:       return {
202:         text: cleanedText,
203:         method: 'ai-extraction',
204:         confidence: 0.8
205:       }
206:     }
207:   } catch (error) {
208:     console.error('[PDF_PARSE] ❌ Method 3 failed:', error)
209:   }
210: 
211:   // All methods failed
212:   console.error('[PDF_PARSE] ❌❌❌ ALL EXTRACTION METHODS FAILED')
213:   return {
214:     text: '',
215:     method: 'all-methods-failed',
216:     confidence: 0
217:   }
218: }
219: 
220: export const runtime = 'nodejs'
221: export const dynamic = 'force-dynamic'
222: 
223: export async function POST(request: NextRequest) {
224:   const startTime = Date.now()
225:   console.log('[RESUME_UPLOAD] ========== NEW UPLOAD REQUEST ==========')
226:   
227:   try {
228:     await dbService.connect()
229: 
230:     const session = await getServerSession(authOptions)
231:     if (!session?.user?.id) {
232:       console.log('[RESUME_UPLOAD] ❌ Unauthorized')
233:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
234:     }
235:     
236:     console.log('[RESUME_UPLOAD] User:', session.user.id, session.user.email)
237: 
238:     if (await isRateLimited(session.user.id, 'resume:upload')) {
239:       console.log('[RESUME_UPLOAD] ❌ Rate limited')
240:       return NextResponse.json({ error: 'Rate limited' }, { status: 429 })
241:     }
242: 
243:     const data = await request.formData()
244:     const file = data.get('file') as File
245:     const pastedText = data.get('pastedText') as string
246:     
247:     console.log('[RESUME_UPLOAD] Upload type:', {
248:       hasFile: !!file,
249:       fileSize: file?.size,
250:       fileName: file?.name,
251:       hasPastedText: !!pastedText,
252:       pastedTextLength: pastedText?.length
253:     })
254: 
255:     if (!file && !pastedText) {
256:       console.log('[RESUME_UPLOAD] ❌ No file or text provided')
257:       return NextResponse.json({ error: 'No file or text provided' }, { status: 400 })
258:     }
259: 
260:     let extractedText = ''
261:     let extractionMethod = ''
262:     let extractionError = ''
263:     let extractionConfidence = 0.95
264: 
265:     if (file && file.size > 0) {
266:       // Validate file size and type
267:       if (file.size > 10 * 1024 * 1024) {
268:         return NextResponse.json({ error: 'File too large' }, { status: 400 })
269:       }
270: 
271:       const buffer = Buffer.from(await file.arrayBuffer())
272:       const filename = file.name || 'resume.pdf'
273: 
274:       if (path.extname(filename).toLowerCase() === '.pdf') {
275:         try {
276:           const { text, method, confidence } = await extractTextFromPDF(buffer)
277:           extractedText = text
278:           extractionMethod = method
279:           extractionConfidence = confidence || 0.95
280:           
281:           // Enhanced logging
282:           console.log('🔍 PDF Processing Result:', {
283:             filename,
284:             method: extractionMethod,
285:             textLength: extractedText?.length,
286:             confidence: extractionConfidence,
287:             firstWords: extractedText?.slice(0, 100)
288:           })
289:           
290:           if (!text || text.length < MIN_VALID_PDF_TEXT_LENGTH) {
291:             extractionError = 'PDF text extraction was incomplete. Please paste your resume content instead.'
292:           }
293:         } catch (pdfError) {
294:           console.error('PDF processing failed completely:', pdfError)
295:           extractionError = 'PDF processing failed. Please paste your resume text or try a different file format.'
296:           extractionMethod = 'pdf-failed'
297:         }
298:       } else {
299:         extractedText = await file.text()
300:         extractionMethod = 'direct_text'
301:         extractionConfidence = 1.0
302:       }
303:     } else if (pastedText) {
304:       extractedText = pastedText
305:       extractionMethod = 'pasted_text'
306:     }
307: 
308:     extractedText = cleanExtractedText(extractedText || '')
309: 
310:     const asciiFallbackUsed = extractionMethod === 'ascii-fallback'
311: 
312:     if (asciiFallbackUsed) {
313:       extractionError = extractionError || 'PDF could not be reliably processed (ASCII fallback). Please paste your resume text instead.'
314:       extractionConfidence = Math.min(extractionConfidence, ASCII_FALLBACK_CONFIDENCE)
315:     }
316: 
317:     if (!extractedText || extractedText.length < MIN_VALID_PDF_TEXT_LENGTH) {
318:       return NextResponse.json({ 
319:         error: 'No readable content', 
320:         details: extractionError || 'Could not extract text from the file. Please paste your resume text instead.',
321:         extractionMethod 
322:       }, { status: 400 })
323:     }
324: 
325:     if (asciiFallbackUsed) {
326:       return NextResponse.json({
327:         error: 'Resume quality too low',
328:         details: extractionError,
329:         extractionMethod,
330:         confidence: extractionConfidence
331:       }, { status: 400 })
332:     }
333: 
334:     // CRITICAL FIX: Extract location and keywords from resume text
335:     console.log('═══════════════════════════════════════════════════════')
336:     console.log('[PDF UPLOAD] EXTRACTING RESUME SIGNALS (Location + Keywords)')
337:     console.log('═══════════════════════════════════════════════════════')
338:     console.log('[PDF UPLOAD] Resume text length:', extractedText.length, 'chars')
339:     console.log('[PDF UPLOAD] First 300 chars:', extractedText.substring(0, 300))
340:     console.log('─────────────────────────────────────────────────────────')
341: 
342:     let extractedLocation: string | undefined
343:     let extractedKeywords: string[] = []
344:     let personalInfo: any = {}
345: 
346:     try {
347:       const { PerplexityIntelligenceService } = await import('@/lib/perplexity-intelligence')
348:       const signals = await PerplexityIntelligenceService.extractResumeSignals(extractedText, 50)
349:       
350:       extractedLocation = signals.location
351:       extractedKeywords = signals.keywords || []
352:       personalInfo = signals.personalInfo || {}
353: 
354:       console.log('[PDF UPLOAD] EXTRACTION RESULTS:')
355:       console.log('[PDF UPLOAD] Location extracted:', extractedLocation || 'NONE')
356:       console.log('[PDF UPLOAD] Keywords extracted:', extractedKeywords.length, 'keywords')
357:       console.log('[PDF UPLOAD] First 10 keywords:', extractedKeywords.slice(0, 10).join(', ') || 'NONE')
358:       console.log('[PDF UPLOAD] Personal info:', personalInfo)
359: 
360:       // CRITICAL: Fail if no real location found
361:       if (!extractedLocation || extractedLocation.trim().length < 2) {
362:         console.error('═══════════════════════════════════════════════════════')
363:         console.error('[PDF UPLOAD] ❌ EXTRACTION FAILED - NO LOCATION')
364:         console.error('═══════════════════════════════════════════════════════')
365:         console.error('[PDF UPLOAD] Extracted location:', extractedLocation || 'undefined')
366:         console.error('[PDF UPLOAD] Resume preview (first 500 chars):', extractedText.substring(0, 500))
367:         console.error('═══════════════════════════════════════════════════════')
368:         
369:         return NextResponse.json({
370:           error: 'Could not extract location from resume',
371:           details: 'Please ensure your resume includes your city and state/province in the contact section at the top.',
372:           extractedLocation: extractedLocation,
373:           resumePreview: extractedText.substring(0, 300),
374:           suggestion: 'Add your location (e.g., "Seattle, WA" or "Toronto, ON") to the top of your resume and try again.'
375:         }, { status: 400 })
376:       }
377: 
378:       console.log('═══════════════════════════════════════════════════════')
379:       console.log('[PDF UPLOAD] ✅ EXTRACTION SUCCESSFUL')
380:       console.log('[PDF UPLOAD] Location:', extractedLocation)
381:       console.log('[PDF UPLOAD] Keywords:', extractedKeywords.length, 'extracted')
382:       console.log('═══════════════════════════════════════════════════════')
383:     } catch (signalError) {
384:       console.error('═══════════════════════════════════════════════════════')
385:       console.error('[PDF UPLOAD] ❌ SIGNAL EXTRACTION FAILED')
386:       console.error('═══════════════════════════════════════════════════════')
387:       console.error('[PDF UPLOAD] Error:', (signalError as Error).message)
388:       console.error('[PDF UPLOAD] Stack:', (signalError as Error).stack)
389:       console.error('═══════════════════════════════════════════════════════')
390:       
391:       return NextResponse.json({
392:         error: 'Failed to extract resume information',
393:         details: 'Could not parse location and keywords from your resume. Please ensure your resume is properly formatted with contact information at the top.',
394:         technical: (signalError as Error).message
395:       }, { status: 500 })
396:     }
397: 
398:     const resume = new Resume({
399:       userId: session.user.id,
400:       originalFileName: file?.name || 'pasted-resume.txt',
401:       filename: file?.name || 'pasted-resume.txt',
402:       extractedText,
403:       extractionMethod,
404:       extractionError: extractionError || undefined,
405:       uploadedAt: new Date(),
406:       // Store extracted signals for job matching
407:       metadata: {
408:         extractedLocation,
409:         extractedKeywords: extractedKeywords.slice(0, 20), // Store top 20
410:         personalInfo,
411:         extractionDate: new Date().toISOString()
412:       }
413:     })
414: 
415:     await resume.save()
416:     
417:     const duration = Date.now() - startTime
418:     console.log('[RESUME_UPLOAD] ✅ SUCCESS:', {
419:       resumeId: resume._id.toString(),
420:       textLength: extractedText.length,
421:       method: extractionMethod,
422:       confidence: extractionConfidence,
423:       durationMs: duration
424:     })
425: 
426:     return NextResponse.json({
427:       success: true,
428:       resume: {
429:         _id: resume._id.toString(),
430:         userId: resume.userId,
431:         originalFileName: resume.originalFileName,
432:         filename: resume.filename,
433:         extractedText: resume.extractedText,
434:         extractionMethod: resume.extractionMethod,
435:         uploadedAt: resume.uploadedAt,
436:         metadata: resume.metadata
437:       },
438:       resumeId: resume._id,
439:       extractedText: extractedText.substring(0, 500) + (extractedText.length > 500 ? '...' : ''),
440:       extractionMethod,
441:       extractionError,
442:       confidence: extractionConfidence,
443:       // Include extracted signals in response for frontend
444:       extractedLocation,
445:       extractedKeywords: extractedKeywords.slice(0, 10), // Top 10 for display
446:       personalInfo
447:     })
448:   } catch (error) {
449:     console.error('Upload error:', error)
450:     const errorMessage = error instanceof Error ? error.message : 'Internal server error'
451:     
452:     // Provide helpful error messages based on error type
453:     let userMessage = 'Failed to process resume'
454:     let helpText = 'Please try again or paste your resume text directly.'
455:     
456:     if (errorMessage.includes('validation')) {
457:       userMessage = 'Invalid resume data'
458:       helpText = 'Please ensure your resume contains valid text.'
459:     } else if (errorMessage.includes('database') || errorMessage.includes('mongo')) {
460:       userMessage = 'Database connection error'
461:       helpText = 'Please try again in a moment.'
462:     } else if (errorMessage.includes('memory') || errorMessage.includes('heap')) {
463:       userMessage = 'File too complex to process'
464:       helpText = 'Try a simpler PDF or paste your text instead.'
465:     }
466:     
467:     return NextResponse.json({ 
468:       error: userMessage,
469:       details: helpText,
470:       technical: process.env.NODE_ENV === 'development' ? errorMessage : undefined
471:     }, { status: 500 })
472:   }
473: }
</file>

<file path="src/lib/agents/job-discovery-agent.ts">
  1: /**
  2:  * JOB DISCOVERY AGENT
  3:  * Autonomous job search across 15+ boards with Perplexity web_search + Cheerio fallback
  4:  */
  5: 
  6: import { BaseAgent, AgentTask, AgentResult } from './base-agent'
  7: import { COMPREHENSIVE_JOB_BOARDS, getTopJobBoards } from '../comprehensive-data-sources'
  8: import { AdvancedScraper } from '../scrapers/advanced-scraper'
  9: 
 10: export interface JobListing {
 11:   id?: string
 12:   title: string
 13:   company: string
 14:   location: string
 15:   url: string
 16:   summary: string
 17:   salary?: string | null
 18:   postedDate?: string
 19:   source: string
 20:   skills?: string[]
 21:   workType?: 'remote' | 'hybrid' | 'onsite'
 22:   skillMatchPercent?: number
 23:   description?: string
 24: }
 25: 
 26: export class JobDiscoveryAgent extends BaseAgent {
 27:   private scraper: AdvancedScraper
 28: 
 29:   constructor() {
 30:     super('Job Discovery Agent')
 31:     this.scraper = new AdvancedScraper()
 32:   }
 33: 
 34:   async execute(task: AgentTask): Promise<AgentResult<JobListing[]>> {
 35:     const { jobTitle, location, maxResults = 30 } = task.input
 36:     const started = Date.now()
 37: 
 38:     this.log(`🔍 Searching for "${jobTitle}" in "${location}" across 15 job boards...`)
 39: 
 40:     // Get top 10 job boards by priority
 41:     const boards = getTopJobBoards(10)
 42:     const searchUrls = boards.map(b => ({
 43:       name: b.name,
 44:       url: b.searchUrl(jobTitle, location),
 45:       priority: b.priority
 46:     }))
 47: 
 48:     this.log(`📊 Targeting ${searchUrls.length} job boards`)
 49: 
 50:     // Try Perplexity agent first
 51:     try {
 52:       const perplexityJobs = await this.searchWithPerplexity(jobTitle, location, maxResults, searchUrls)
 53:       
 54:       if (perplexityJobs.length >= maxResults * 0.7) {
 55:         this.log(`✅ Perplexity found ${perplexityJobs.length} jobs`)
 56:         return {
 57:           success: true,
 58:           data: perplexityJobs,
 59:           reasoning: 'Perplexity agent successfully searched multiple job boards using web_search',
 60:           confidence: perplexityJobs.length / maxResults,
 61:           sources: perplexityJobs.map(j => ({ title: j.title, url: j.url })),
 62:           duration: Date.now() - started,
 63:           method: 'perplexity'
 64:         }
 65:       }
 66:       
 67:       this.log(`⚠️ Perplexity only found ${perplexityJobs.length} jobs, trying fallback...`)
 68:     } catch (error) {
 69:       this.log(`❌ Perplexity failed: ${(error as Error).message}`, 'error')
 70:     }
 71: 
 72:     // Fallback: Parallel Cheerio scraping
 73:     this.log(`🔄 Falling back to parallel Cheerio scraping...`)
 74:     const cheerioJobs = await this.searchWithCheerio(searchUrls, maxResults)
 75: 
 76:     return {
 77:       success: cheerioJobs.length > 0,
 78:       data: cheerioJobs,
 79:       reasoning: 'Perplexity failed, used parallel Cheerio scraping across multiple boards',
 80:       confidence: cheerioJobs.length / maxResults,
 81:       sources: cheerioJobs.map(j => ({ title: j.title, url: j.url })),
 82:       duration: Date.now() - started,
 83:       method: 'cheerio'
 84:     }
 85:   }
 86: 
 87:   private async searchWithPerplexity(
 88:     jobTitle: string,
 89:     location: string,
 90:     maxResults: number,
 91:     searchUrls: Array<{ name: string; url: string; priority: number }>
 92:   ): Promise<JobListing[]> {
 93:     const prompt = `🔴 AUTONOMOUS JOB SEARCH MISSION 🔴
 94: 
 95: TASK: Find EXACTLY ${maxResults} real job listings for "${jobTitle}" in "${location}"
 96: 
 97: MANDATORY STEPS:
 98: 1. **USE web_search tool** to visit these job board URLs (search in parallel):
 99: ${searchUrls.map((s, i) => `   ${i+1}. ${s.name}: ${s.url}`).join('\n')}
100: 
101: 2. For EACH job found:
102:    - EXTRACT the job title, company, location from search results
103:    - CLICK the job URL and visit the actual posting page
104:    - SCRAPE the COMPLETE job description (minimum 300 characters)
105:    - VERIFY company name is NOT "Confidential" (skip those immediately)
106:    - EXTRACT salary if visible on the page
107:    - GET the posted date
108: 
109: 3. PRIORITIZE:
110:    - Posted within last 14 days (prefer last 7 days)
111:    - Remote or hybrid work options
112:    - Companies with clear names (not "Confidential")
113:    - Jobs with detailed descriptions
114: 
115: CRITICAL RULES:
116: ✅ Return EXACTLY ${maxResults} jobs (or as many as you can find up to ${maxResults})
117: ✅ Each description should be >100 characters (from actual job page content)
118: ✅ REJECT any job with "Confidential" in company name
119: ✅ Include actual clickable URLs to job postings
120: ✅ Extract real salary data if available
121: ✅ Get actual posted dates
122: 
123: OUTPUT FORMAT (strict JSON array):
124: [{
125:   "title": "Exact title from posting",
126:   "company": "Real company name (NOT Confidential)",
127:   "location": "${location}",
128:   "url": "https://actual-job-posting-url.com",
129:   "summary": "Full job description from the actual page (300+ chars)",
130:   "salary": "$XX,XXX - $YY,XXX" or null,
131:   "postedDate": "YYYY-MM-DD",
132:   "source": "indeed|linkedin|glassdoor|jobbank|etc",
133:   "skills": ["skill1", "skill2", "skill3"],
134:   "workType": "remote|hybrid|onsite",
135:   "skillMatchPercent": 75
136: }]
137: 
138: REASONING: After the JSON, explain:
139: - Which job boards you searched
140: - How many jobs you found on each board
141: - Why you selected these specific jobs
142: - Any challenges you encountered
143: 
144: 🚨 I WILL REJECT YOUR RESPONSE IF:
145: - Less than ${Math.floor(maxResults * 0.5)} jobs returned
146: - Any "Confidential" companies included
147: - Any dead/broken URLs
148: - Made up or fake job listings
149: 
150: START YOUR SEARCH NOW using web_search tool!`
151: 
152:     try {
153:       const response = await this.think(prompt, { maxTokens: 12000, temperature: 0.3 })
154:       
155:       // Try multiple JSON extraction methods
156:       let jobs: JobListing[] = []
157:       
158:       // Method 1: Find JSON array with proper brackets
159:       const jsonMatch = response.match(/\[\s*\{[\s\S]*?\}\s*\]/)?.[0]
160:       if (jsonMatch) {
161:         try {
162:           jobs = JSON.parse(jsonMatch)
163:           this.log(`✅ Extracted JSON using method 1`)
164:         } catch (e) {
165:           this.log(`⚠️ Method 1 failed: ${(e as Error).message}`, 'warn')
166:         }
167:       }
168:       
169:       // Method 2: Try to find and fix common JSON errors
170:       if (jobs.length === 0) {
171:         try {
172:           // Remove markdown code blocks
173:           let cleaned = response.replace(/```json\s*/g, '').replace(/```\s*/g, '')
174:           // Find array
175:           const arrayMatch = cleaned.match(/\[\s*\{[\s\S]*?\}\s*\]/)
176:           if (arrayMatch) {
177:             // Fix common issues: trailing commas, missing commas, etc.
178:             let fixed = arrayMatch[0]
179:               .replace(/,\s*}/g, '}')  // Remove trailing commas before }
180:               .replace(/,\s*\]/g, ']')  // Remove trailing commas before ]
181:               .replace(/}\s*{/g, '},{') // Add missing commas between objects
182:             
183:             jobs = JSON.parse(fixed)
184:             this.log(`✅ Extracted JSON using method 2 (with fixes)`)
185:           }
186:         } catch (e) {
187:           this.log(`⚠️ Method 2 failed: ${(e as Error).message}`, 'warn')
188:         }
189:       }
190:       
191:       if (jobs.length === 0) {
192:         this.log('❌ No valid JSON found in Perplexity response', 'error')
193:         throw new Error('No valid JSON found in agent response')
194:       }
195:       
196:       // Validate and clean jobs
197:       const validated = this.validateJobs(jobs, maxResults)
198:       
199:       this.log(`✅ Validated ${validated.length}/${jobs.length} jobs from Perplexity`)
200:       
201:       return validated
202:     } catch (error) {
203:       this.log(`❌ Perplexity search failed: ${(error as Error).message}`, 'error')
204:       throw error
205:     }
206:   }
207: 
208:   private async searchWithCheerio(
209:     searchUrls: Array<{ name: string; url: string; priority: number }>,
210:     maxResults: number
211:   ): Promise<JobListing[]> {
212:     this.log(`🔄 Starting parallel Cheerio scraping of ${searchUrls.length} boards...`)
213:     
214:     // Scrape all boards in parallel
215:     const scrapePromises = searchUrls.map(async ({ name, url }): Promise<JobListing | null> => {
216:       try {
217:         this.log(`📡 Scraping ${name}...`)
218:         const result = await this.scraper.scrape(url)
219:         
220:         if (result.success && result.data) {
221:           this.log(`✅ ${name}: Found data`)
222:           // Convert scraper result to job listing
223:           const job: JobListing = {
224:             title: result.data.title || 'Unknown',
225:             company: result.data.company || 'Unknown',
226:             location: result.data.location || '',
227:             url: url,
228:             summary: result.data.description || '',
229:             salary: result.data.salary || null,
230:             postedDate: result.data.postedDate || new Date().toISOString().split('T')[0],
231:             source: name.toLowerCase().replace(/\s+/g, '-'),
232:             skills: result.data.requirements || [],
233:             workType: 'onsite' as const,
234:             skillMatchPercent: 0
235:           }
236:           return job
237:         }
238:         
239:         this.log(`⚠️ ${name}: No data found`, 'warn')
240:         return null
241:       } catch (error) {
242:         this.log(`❌ ${name}: ${(error as Error).message}`, 'error')
243:         return null
244:       }
245:     })
246: 
247:     const results = await Promise.all(scrapePromises)
248:     const jobs = results.filter((j): j is JobListing => j !== null)
249:     
250:     this.log(`✅ Cheerio scraping complete: ${jobs.length} jobs found`)
251:     
252:     return this.validateJobs(jobs, maxResults)
253:   }
254: 
255:   private validateJobs(jobs: JobListing[], target: number): JobListing[] {
256:     const validated = jobs
257:       .filter(j => {
258:         // FIX: Only reject if completely missing critical fields
259:         if (!j.title || !j.company || !j.url) {
260:           this.log(`🚫 Rejected job missing critical fields: "${j.title || 'NO TITLE'}" at "${j.company || 'NO COMPANY'}"`)
261:           return false
262:         }
263:         
264:         // FIX: Don't reject based on description length - enrich later
265:         // Short descriptions will be enriched by URL scraping
266:         
267:         // FIX: More lenient confidential filter - only reject obvious ones
268:         const company = String(j.company).toLowerCase().trim()
269:         const isConfidential = company.includes('confidential') && company.length < 20
270:         if (isConfidential) {
271:           this.log(`🚫 Rejected confidential job: "${j.title}" at "${j.company}"`)
272:           return false
273:         }
274:         
275:         // FIX: Accept any valid HTTP URL
276:         if (!j.url.startsWith('http')) {
277:           this.log(`🚫 Rejected job with invalid URL: "${j.title}"`)
278:           return false
279:         }
280:         
281:         return true
282:       })
283:       .slice(0, target)
284:     
285:     this.log(`✅ Validation complete: ${validated.length}/${jobs.length} jobs passed`)
286:     
287:     return validated
288:   }
289: }
</file>

<file path="src/app/api/jobs/search/route.ts">
  1: /**
  2:  * Unified Job Search API - Enhanced with PerplexityIntelligenceService
  3:  * 
  4:  * NOW USES: PerplexityIntelligenceService for comprehensive 25+ board coverage
  5:  * 
  6:  * Features:
  7:  * - 10 Canadian job boards (Job Bank, Jobboom, Workopolis, etc.)
  8:  * - 35+ Canadian ATS companies (Shopify, Wealthsimple, etc.)
  9:  * - Global boards (LinkedIn, Indeed, Glassdoor)
 10:  * - Resume skill matching with scoring
 11:  * - Smart Canadian prioritization
 12:  * - Built-in caching (24hr TTL)
 13:  */
 14: 
 15: import { NextRequest, NextResponse } from 'next/server'
 16: import { getServerSession } from 'next-auth/next'
 17: import { authOptions } from '@/lib/auth'
 18: import { dbService } from '@/lib/database'
 19: import { PerplexityIntelligenceService } from '@/lib/perplexity-intelligence'
 20: import { isRateLimited } from '@/lib/rate-limit'
 21: import Resume from '@/models/Resume'
 22: import { jobSearchCacheService } from '@/services/job-search-cache.service'
 23: 
 24: export const dynamic = 'force-dynamic'
 25: export const runtime = 'nodejs'
 26: export const maxDuration = 60 // Increased to handle Perplexity API calls which can take longer
 27: 
 28: interface JobSearchRequest {
 29:   keywords: string
 30:   location?: string
 31:   sources?: string[] // Specific boards to search
 32:   limit?: number
 33:   remote?: boolean
 34:   salaryMin?: number
 35:   experienceLevel?: 'entry' | 'mid' | 'senior' | 'executive'
 36:   workType?: 'remote' | 'hybrid' | 'onsite' | 'any'
 37:   useResumeMatching?: boolean // Use resume for skill matching
 38:   targetIndustry?: string // ENTERPRISE: User wants to switch industries (e.g., "Technology", "Healthcare")
 39:   disableIndustryWeighting?: boolean // ENTERPRISE: User wants equal weight across all industries
 40: }
 41: 
 42: export async function POST(request: NextRequest) {
 43:   try {
 44:     // CRITICAL FIX: Parse body and validate location BEFORE authentication
 45:     // This allows testing location validation without auth
 46:     const body: JobSearchRequest = await request.json()
 47:     let { 
 48:       keywords, 
 49:       location, 
 50:       sources, 
 51:       limit = 25, 
 52:       remote,
 53:       salaryMin,
 54:       experienceLevel,
 55:       workType,
 56:       targetIndustry,
 57:       disableIndustryWeighting
 58:     } = body
 59:     
 60:     console.log('═══════════════════════════════════════════════════════')
 61:     console.log('[JOB_SEARCH] NEW SEARCH REQUEST')
 62:     console.log('═══════════════════════════════════════════════════════')
 63:     console.log('[JOB_SEARCH] Job Title:', keywords)
 64:     console.log('[JOB_SEARCH] Location:', location || 'UNDEFINED')
 65:     console.log('[JOB_SEARCH] Max Results:', limit)
 66:     console.log('[JOB_SEARCH] Work Type:', workType || 'any')
 67:     console.log('─────────────────────────────────────────────────────────')
 68: 
 69:     // CRITICAL: Validate location BEFORE authentication check
 70:     if (!location || location.trim().length < 2) {
 71:       console.error('[JOB_SEARCH] ❌ MISSING LOCATION')
 72:       return NextResponse.json({
 73:         success: false,
 74:         error: 'Location is required for job search',
 75:         suggestion: 'Upload your resume to extract location, or manually enter city and state/province',
 76:         errorCode: 'LOCATION_REQUIRED'
 77:       }, { status: 400 })
 78:     }
 79: 
 80:     // Reject "Canada" or "United States" (too broad)
 81:     const normalizedLocation = location.toLowerCase().trim()
 82:     if (['canada', 'united states', 'usa', 'us'].includes(normalizedLocation)) {
 83:       console.error('[JOB_SEARCH] ❌ LOCATION TOO BROAD:', location)
 84:       return NextResponse.json({
 85:         success: false,
 86:         error: 'Location is too broad. Please specify a city and state/province.',
 87:         example: 'Examples: Seattle, WA or Toronto, ON or Vancouver, BC',
 88:         errorCode: 'LOCATION_TOO_BROAD'
 89:       }, { status: 400 })
 90:     }
 91: 
 92:     console.log('[JOB_SEARCH] ✅ Location valid, proceeding with authentication...')
 93: 
 94:     // NOW check authentication after location validation passes
 95:     const session = await getServerSession(authOptions)
 96:     if (!session?.user?.id) {
 97:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
 98:     }
 99: 
100:     // Rate limiting
101:     if (await isRateLimited(session.user.id, 'job-search')) {
102:       return NextResponse.json({ 
103:         error: 'Too many searches. Please wait a moment.' 
104:       }, { status: 429 })
105:     }
106: 
107:     await dbService.connect()
108: 
109:     let useResumeMatching = body.useResumeMatching || false
110: 
111:     if (!keywords || keywords.trim().length < 2) {
112:       return NextResponse.json({ 
113:         error: 'Please provide valid search keywords' 
114:       }, { status: 400 })
115:     }
116: 
117:     console.log(`[JOB_SEARCH] User ${session.user.id} searching: "${keywords}" in ${location} (Resume matching: ${useResumeMatching})`)
118: 
119:     // CRITICAL FIX: Get cached jobs but ALWAYS search for new ones too
120:     const cachedJobs = await jobSearchCacheService.getCachedJobs({
121:       keywords,
122:       location,
123:       workType,
124:       experienceLevel,
125:       userId: session.user.id
126:     });
127: 
128:     if (cachedJobs && cachedJobs.length > 0) {
129:       console.log(`[JOB_CACHE] Found ${cachedJobs.length} cached jobs - will merge with NEW search results`);
130:     } else {
131:       console.log(`[JOB_CACHE] No cached jobs found - performing fresh search`);
132:     }
133: 
134:     let result: any
135:     let jobs: any[] = []
136:     let metadata: any = {}
137: 
138:     // Option 1: Resume-matched search with INDUSTRY WEIGHTING (most powerful)
139:     if (useResumeMatching) {
140:       try {
141:         // Get user's resume
142:         const resumeDoc = await Resume.findOne({ userId: session.user.id })
143:           .sort({ createdAt: -1 })
144:           .lean()
145:         
146:         const extractedText = (resumeDoc as any)?.extractedText
147:         
148:         if (!resumeDoc || !extractedText) {
149:           return NextResponse.json({ 
150:             error: 'Please upload a resume first to use resume matching' 
151:           }, { status: 400 })
152:         }
153: 
154:         console.log(`[JOB_SEARCH] Using resume matching with industry weighting for user ${session.user.id}`)
155: 
156:         // ENTERPRISE FEATURE: Analyze career timeline for industry weighting
157:         let careerTimeline: any = null
158:         let effectivePrimaryIndustry: any = null
159:         
160:         // Skip industry analysis if user explicitly disabled it
161:         if (!disableIndustryWeighting) {
162:           try {
163:             careerTimeline = await PerplexityIntelligenceService.extractCareerTimeline(extractedText)
164:             console.log('[JOB_SEARCH] Career timeline:', {
165:               industries: careerTimeline.industries.map((i: any) => `${i.name} (${i.percentage}%)`).join(', '),
166:               primaryIndustry: careerTimeline.industries[0]?.name,
167:               hasTransition: !!careerTimeline.careerTransition,
168:               userTargetIndustry: targetIndustry || 'none'
169:             })
170:             
171:             // ENTERPRISE: User wants to switch industries
172:             if (targetIndustry && targetIndustry.trim()) {
173:               // Find matching industry from resume, or create synthetic one
174:               const normalizedTarget = targetIndustry.toLowerCase()
175:               effectivePrimaryIndustry = careerTimeline.industries.find(
176:                 (i: any) => i?.name?.toLowerCase()?.includes(normalizedTarget)
177:               )
178: 
179:               if (effectivePrimaryIndustry) {
180:                 console.log(`[JOB_SEARCH] User targeting industry switch TO: ${effectivePrimaryIndustry.name}`)
181:               } else {
182:                 // User wants to switch to an entirely new industry not in their history
183:                 console.log(`[JOB_SEARCH] User switching to NEW industry: ${targetIndustry} (no prior experience)`)
184:                 effectivePrimaryIndustry = {
185:                   name: targetIndustry,
186:                   yearsOfExperience: 0,
187:                   keywords: keywords
188:                     .split(',')
189:                     .map((k: string) => k.trim())
190:                     .filter(Boolean),
191:                   percentage: 100 // Give full weight to target industry
192:                 }
193:               }
194:             } else {
195:               // Default: Use longest-tenure industry
196:               effectivePrimaryIndustry = careerTimeline.industries[0]
197:             }
198:           } catch (err) {
199:             console.warn('[JOB_SEARCH] Career timeline extraction failed, using standard matching:', err)
200:           }
201:         } else {
202:           console.log('[JOB_SEARCH] Industry weighting DISABLED by user preference')
203:         }
204: 
205:         // CRITICAL: If career timeline exists, weight job results by industry tenure
206:         let industryWeightedLimit = limit
207:         
208:         if (effectivePrimaryIndustry) {
209:           // Calculate industry-based search distribution
210:           const primaryPercentage = effectivePrimaryIndustry.percentage / 100
211:           
212:           // EXAMPLE: If 95% of career in Transportation, show 95% transport jobs
213:           // UNLESS user is switching industries, then show 100% of new industry
214:           industryWeightedLimit = targetIndustry ? limit : Math.ceil(limit * primaryPercentage)
215:           
216:           console.log('[JOB_SEARCH] Industry weighting:', {
217:             primaryIndustry: effectivePrimaryIndustry.name,
218:             primaryPercentage: `${effectivePrimaryIndustry.percentage}%`,
219:             adjustedLimit: industryWeightedLimit,
220:             keywords: effectivePrimaryIndustry.keywords?.join(', ') || 'none',
221:             isSwitching: !!targetIndustry
222:           })
223:           
224:           // Boost keywords from target/primary industry (if available)
225:           if (effectivePrimaryIndustry.keywords && Array.isArray(effectivePrimaryIndustry.keywords) && effectivePrimaryIndustry.keywords.length > 0) {
226:             const industryKeywords = effectivePrimaryIndustry.keywords.slice(0, 5).join(', ')
227:             keywords = `${industryKeywords}, ${keywords}`.trim()
228:           }
229:         }
230: 
231:         // Use NEW AGENT SYSTEM with Perplexity web_search + Cheerio fallback
232:         console.log('[JOB_SEARCH] 🤖 Calling NEW AGENT SYSTEM jobListingsWithAgent with:', {
233:           jobTitle: keywords,
234:           location,
235:           workType: workType || (remote ? 'remote' : 'any'),
236:           maxResults: limit
237:         })
238:         
239:         result = await PerplexityIntelligenceService.jobListingsWithAgent(
240:           keywords,
241:           location,
242:           {
243:             maxResults: limit,
244:             workType: workType || (remote ? 'remote' : 'any')
245:           }
246:         )
247: 
248:         console.log('[JOB_SEARCH] 🤖 Agent system result:', {
249:           success: result.success,
250:           dataType: typeof result.data,
251:           dataIsArray: Array.isArray(result.data),
252:           dataLength: Array.isArray(result.data) ? result.data.length : 0,
253:           cached: result.cached,
254:           method: result.metadata?.method,
255:           confidence: result.metadata?.confidence,
256:           error: result.metadata?.error
257:         })
258: 
259:         jobs = result.data
260:         
261:         // POST-PROCESSING: Re-rank jobs by industry tenure (respects user preferences)
262:         if (effectivePrimaryIndustry && !disableIndustryWeighting && effectivePrimaryIndustry.keywords && Array.isArray(effectivePrimaryIndustry.keywords)) {
263:           const primaryKeywords = effectivePrimaryIndustry.keywords.map((k: string) => k.toLowerCase())
264:           
265:           jobs = jobs.map((job: any) => {
266:             // Calculate industry match score
267:             const jobTitle = (job.title || '').toLowerCase()
268:             const jobDescription = (job.description || '').toLowerCase()
269:             const jobCompany = (job.company || '').toLowerCase()
270:             const fullText = `${jobTitle} ${jobDescription} ${jobCompany}`
271:             
272:             let industryMatchCount = 0
273:             primaryKeywords.forEach((keyword: string) => {
274:               if (fullText.includes(keyword)) industryMatchCount++
275:             })
276:             
277:             const industryMatchScore = industryMatchCount / primaryKeywords.length
278:             
279:             // Boost jobs from primary/target industry
280:             const originalScore = job.skillMatchScore || 0.5
281:             // If user is switching industries, give HIGHER boost (up to 75%)
282:             const boostMultiplier = targetIndustry ? 0.75 : 0.5
283:             const boostedScore = originalScore * (1 + industryMatchScore * boostMultiplier)
284:             
285:             return {
286:               ...job,
287:               skillMatchScore: Math.min(boostedScore, 1.0), // Cap at 1.0
288:               industryMatchScore,
289:               primaryIndustry: effectivePrimaryIndustry.name,
290:               isSwitchingIndustries: !!targetIndustry
291:             }
292:           }).sort((a: any, b: any) => (b.skillMatchScore || 0) - (a.skillMatchScore || 0)) // Re-sort by boosted score
293:           
294:           const matchedJobs = jobs.filter((j: any) => j.industryMatchScore > 0.3).length
295:           console.log(`[JOB_SEARCH] Applied industry weighting boost to ${jobs.length} jobs (${matchedJobs} strong matches)`)
296:         }
297:         
298:         metadata = {
299:           ...result.metadata,
300:           useResumeMatching: true,
301:           skillMatchingEnabled: true,
302:           industryWeighting: effectivePrimaryIndustry ? {
303:             primaryIndustry: effectivePrimaryIndustry.name,
304:             primaryPercentage: effectivePrimaryIndustry.percentage,
305:             careerTransition: careerTimeline?.careerTransition,
306:             userTargetIndustry: targetIndustry || null,
307:             disabledByUser: disableIndustryWeighting || false
308:           } : null
309:         }
310: 
311:         console.log(`[JOB_SEARCH] Resume matching found ${jobs.length} jobs with skill scores and industry weighting`)
312: 
313:       } catch (error) {
314:         console.error('[JOB_SEARCH] Resume matching failed, falling back to standard search:', error)
315:         // Fall back to standard search
316:         useResumeMatching = false
317:       }
318:     }
319: 
320:     // Option 2: Standard job listing search (25+ boards)
321:     if (!useResumeMatching || jobs.length === 0) {
322:       console.log(`[JOB_SEARCH] Using standard search across 25+ boards`, {
323:         keywords,
324:         location,
325:         limit,
326:         workType: workType || (remote ? 'remote' : undefined)
327:       })
328: 
329:       const jobsResult = await PerplexityIntelligenceService.jobListings(
330:         keywords,
331:         location,
332:         {
333:           limit,
334:           boards: sources
335:         }
336:       )
337: 
338:       console.log(`[JOB_SEARCH] jobListings returned:`, {
339:         type: typeof jobsResult,
340:         isArray: Array.isArray(jobsResult),
341:         length: Array.isArray(jobsResult) ? jobsResult.length : 0,
342:         sample: Array.isArray(jobsResult) && jobsResult[0] ? {
343:           title: jobsResult[0].title,
344:           company: jobsResult[0].company,
345:           hasUrl: !!jobsResult[0].url
346:         } : null
347:       })
348: 
349:       jobs = Array.isArray(jobsResult) ? jobsResult : []
350:       console.log(`[JOB_SEARCH] Standard search returned type: ${typeof jobsResult}, isArray: ${Array.isArray(jobsResult)}, length: ${jobs.length}`)
351: 
352:       metadata = {
353:         useResumeMatching: false,
354:         searchedBoards: sources?.length || 15,
355:         canadianPriority: location.toLowerCase().includes('canada')
356:       }
357: 
358:       console.log(`[JOB_SEARCH] Standard search found ${jobs.length} jobs`)
359:       if (jobs.length > 0) {
360:         console.log(`[JOB_SEARCH] First job sample:`, JSON.stringify(jobs[0]).substring(0, 200))
361:       }
362:     }
363: 
364:     // Save search history
365:     try {
366:       const { default: SearchHistory } = await import('@/models/SearchHistory')
367:       await SearchHistory.create({
368:         userId: session.user.id,
369:         keywords,
370:         location,
371:         resultsCount: jobs.length,
372:         sources: sources || ['all'],
373:         aiUsed: useResumeMatching,
374:         searchDate: new Date()
375:       })
376:     } catch (error) {
377:       console.error('[JOB_SEARCH] Failed to save search history:', error)
378:       // Non-critical, continue
379:     }
380: 
381:     // IMPROVED: Mark confidential jobs instead of filtering them out
382:     let processedJobs = jobs.map((job: any) => {
383:       const company = (job.company || '').toLowerCase().trim()
384:       const title = (job.title || '').toLowerCase().trim()
385:       
386:       // Only filter out COMPLETELY invalid jobs (empty title/company)
387:       const isCompletelyInvalid = (company === '' && title === '')
388:       
389:       // Mark confidential companies but keep them
390:       const confidentialCompanies = ['confidential', 'confidential company', 'undisclosed', 'private']
391:       const isConfidential = confidentialCompanies.includes(company)
392:       
393:       return {
394:         ...job,
395:         isConfidential,
396:         isCompletelyInvalid,
397:         note: isConfidential ? 'Company name not disclosed in posting' : undefined
398:       }
399:     }).filter((job: any) => !job.isCompletelyInvalid) // Only filter completely invalid
400: 
401:     // 🚫 CRITICAL: REMOVE ALL CONFIDENTIAL JOBS - DO NOT SHOW THEM AT ALL
402:     const confidentialCount = processedJobs.filter((j: any) => j.isConfidential).length
403:     processedJobs = processedJobs.filter((j: any) => {
404:       const isConfidential = j.isConfidential || 
405:         j.title?.toLowerCase().includes('confidential') ||
406:         j.company?.toLowerCase().includes('confidential') ||
407:         j.company?.toLowerCase() === 'confidential'
408:       
409:       if (isConfidential) {
410:         console.log(`[JOB_SEARCH] 🚫 REJECTED CONFIDENTIAL JOB: "${j.title}" at "${j.company}"`)
411:       }
412:       
413:       return !isConfidential
414:     })
415:     
416:     console.log(`[JOB_SEARCH] Processed ${jobs.length} jobs, REJECTED ${confidentialCount} confidential jobs, ${processedJobs.length} valid jobs kept`)
417: 
418:     // CRITICAL FIX: Merge cached jobs with new results (remove duplicates by URL)
419:     let finalJobs = [...processedJobs]
420:     if (cachedJobs && cachedJobs.length > 0) {
421:       const newJobUrls = new Set(processedJobs.map((j: any) => j.url).filter(Boolean))
422:       // Also filter confidential from cached jobs
423:       const uniqueCachedJobs = cachedJobs.filter((cj: any) => {
424:         const isConfidential = cj.isConfidential || 
425:           cj.title?.toLowerCase().includes('confidential') ||
426:           cj.company?.toLowerCase().includes('confidential') ||
427:           cj.company?.toLowerCase() === 'confidential'
428:         return !newJobUrls.has(cj.url) && !isConfidential
429:       })
430:       finalJobs = [...processedJobs, ...uniqueCachedJobs]
431:       console.log(`[JOB_CACHE] Merged ${uniqueCachedJobs.length} unique cached jobs with ${processedJobs.length} new jobs = ${finalJobs.length} total`)
432:     }
433: 
434:     // 🚀 NEW: Cache the search results for 3 weeks
435:     if (processedJobs.length > 0) {
436:       await jobSearchCacheService.cacheSearchResults(
437:         {
438:           keywords,
439:           location,
440:           workType,
441:           experienceLevel,
442:           userId: session.user.id
443:         },
444:         processedJobs
445:       );
446:       console.log(`[JOB_CACHE] ✅ Cached ${processedJobs.length} jobs for future searches`);
447:     }
448: 
449:     // Get recommended boards for this location
450:     const recommendedBoards = PerplexityIntelligenceService.getRecommendedBoards(location)
451: 
452:     return NextResponse.json({
453:       success: true,
454:       query: { keywords, location, sources },
455:       totalResults: finalJobs.length,
456:       returnedResults: Math.min(finalJobs.length, limit),
457:       jobs: finalJobs.slice(0, limit),
458:       metadata: {
459:         ...metadata,
460:         searchedAt: new Date().toISOString(),
461:         cachedResults: cachedJobs ? cachedJobs.length : 0,
462:         newResults: processedJobs.length,
463:         totalMerged: finalJobs.length
464:       },
465:       recommendations: {
466:         priorityBoards: recommendedBoards.slice(0, 5),
467:         reasoning: `Recommended job boards for ${location || 'your location'}`
468:       },
469:       sources: [...new Set(finalJobs.map((j: any) => j.source || 'Unknown'))]
470:     })
471: 
472:   } catch (error: any) {
473:     console.error('❌❌❌ [JOB_SEARCH] CRITICAL ERROR ❌❌❌')
474:     console.error('[JOB_SEARCH] Error type:', error?.constructor?.name)
475:     console.error('[JOB_SEARCH] Error message:', error?.message)
476:     console.error('[JOB_SEARCH] Error stack:', error?.stack)
477:     
478:     // Get session for error logging
479:     const session = await getServerSession(authOptions)
480:     console.error('[JOB_SEARCH] User ID:', session?.user?.id)
481:     
482:     return NextResponse.json({ 
483:       error: 'Job search failed', 
484:       details: error?.message || 'Unknown error',
485:       errorType: error?.constructor?.name,
486:       timestamp: new Date().toISOString()
487:     }, { status: 500 })
488:   }
489: }
490: 
491: /**
492:  * GET endpoint for search history and available job boards
493:  */
494: export async function GET(request: NextRequest) {
495:   try {
496:     const session = await getServerSession(authOptions)
497:     if (!session?.user?.id) {
498:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
499:     }
500: 
501:     await dbService.connect()
502: 
503:     const url = new URL(request.url)
504:     const action = url.searchParams.get('action')
505: 
506:     // Get available job boards
507:     if (action === 'boards') {
508:       const boards = PerplexityIntelligenceService.getAvailableJobBoards()
509:       return NextResponse.json({
510:         success: true,
511:         boards,
512:         totalBoards: boards.length
513:       })
514:     }
515: 
516:     // Get search history (default)
517:     const { default: SearchHistory } = await import('@/models/SearchHistory')
518:     const history = await SearchHistory.find({ userId: session.user.id })
519:       .sort({ searchDate: -1 })
520:       .limit(20)
521: 
522:     return NextResponse.json({
523:       success: true,
524:       history
525:     })
526: 
527:   } catch (error) {
528:     console.error('[JOB_SEARCH] Failed to fetch data:', error)
529:     return NextResponse.json({ 
530:       error: 'Failed to fetch data' 
531:     }, { status: 500 })
532:   }
533: }
</file>

<file path="src/lib/perplexity-intelligence.ts">
   1: // FIXED: Universal crypto support (browser + Node.js)
   2: let crypto: any
   3: try {
   4:   crypto = require('crypto')
   5: } catch {
   6:   // Browser environment - will use fallback
   7:   crypto = null
   8: }
   9: import { PerplexityService } from './perplexity-service'
  10: import { 
  11:   CANADIAN_JOB_BOARDS, 
  12:   MAJOR_JOB_BOARDS, 
  13:   OPEN_API_BOARDS,
  14:   ATS_PLATFORMS,
  15:   DISCOVERY_PRIORITY_ORDER
  16: } from './public-job-boards-config'
  17: import { parseAIResponse } from './utils/ai-response-parser'
  18: import { getCoverLetterTemplateById } from './cover-letter-templates'
  19: 
  20: // Environment
  21: const CACHE_TTL_MS = Number(process.env.PPX_CACHE_TTL_MS || 24 * 60 * 60 * 1000)
  22: const MAX_RETRY_ATTEMPTS = Number(process.env.PPX_MAX_RETRIES || 3)
  23: const RETRY_DELAY_MS = Number(process.env.PPX_RETRY_DELAY || 1000)
  24: 
  25: type CacheRecord = {
  26:   value: unknown
  27:   metadata: { createdAt: number; hitCount: number; lastAccessed: number }
  28:   expiresAt: number
  29: }
  30: 
  31: // Simple Map-based cache with TTL
  32: const cache = new Map<string, CacheRecord>()
  33: 
  34: // Cache cleanup interval (every hour)
  35: setInterval(() => {
  36:   const now = Date.now()
  37:   for (const [key, record] of cache.entries()) {
  38:     if (now > record.expiresAt) {
  39:       cache.delete(key)
  40:     }
  41:   }
  42: }, 60 * 60 * 1000)
  43: 
  44: function makeKey(prefix: string, payload: unknown): string {
  45:   const raw = typeof payload === 'string' ? payload : JSON.stringify(payload)
  46:   
  47:   // Use crypto if available (Node.js), otherwise simple hash (browser)
  48:   if (crypto && crypto.createHash) {
  49:     return `${prefix}:${crypto.createHash('sha256').update(raw).digest('hex')}`
  50:   }
  51:   
  52:   // Browser fallback: simple hash
  53:   let hash = 0
  54:   for (let i = 0; i < raw.length; i++) {
  55:     const char = raw.charCodeAt(i)
  56:     hash = ((hash << 5) - hash) + char
  57:     hash = hash & hash
  58:   }
  59:   return `${prefix}:${Math.abs(hash).toString(36)}`
  60: }
  61: 
  62: function getCache(key: string): unknown | undefined {
  63:   const entry = cache.get(key)
  64:   if (!entry) return undefined
  65:   
  66:   // Check if expired
  67:   if (Date.now() > entry.expiresAt) {
  68:     cache.delete(key)
  69:     return undefined
  70:   }
  71:   
  72:   entry.metadata.hitCount += 1
  73:   entry.metadata.lastAccessed = Date.now()
  74:   return entry.value
  75: }
  76: 
  77: function setCache(key: string, value: unknown) {
  78:   cache.set(key, {
  79:     value,
  80:     expiresAt: Date.now() + CACHE_TTL_MS,
  81:     metadata: {
  82:       createdAt: Date.now(),
  83:       hitCount: 0,
  84:       lastAccessed: Date.now()
  85:     }
  86:   })
  87: }
  88: 
  89: function createClient(): PerplexityService { return new PerplexityService() }
  90: 
  91: // ---------- Enhanced helpers (ids, retry, enrichment) ----------
  92: function generateRequestId(): string {
  93:   if (crypto && crypto.randomBytes) {
  94:     return crypto.randomBytes(8).toString('hex')
  95:   }
  96:   // Browser fallback
  97:   return Math.random().toString(36).substr(2, 16) + Date.now().toString(36)
  98: }
  99: 
 100: // FIXED: Add timeout protection
 101: function withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {
 102:   return Promise.race([
 103:     promise,
 104:     new Promise<T>((_, reject) => 
 105:       setTimeout(() => reject(new Error(`Request timeout after ${ms}ms`)), ms)
 106:     )
 107:   ])
 108: }
 109: 
 110: async function withRetry<T>(
 111:   operation: () => Promise<T>,
 112:   maxAttempts: number = MAX_RETRY_ATTEMPTS,
 113:   logger?: { warn?: (message: string, context?: Record<string, unknown>) => void },
 114:   timeoutMs: number = 30000 // 30 second default timeout
 115: ): Promise<T> {
 116:   let lastError: unknown
 117:   for (let attempt = 1; attempt <= maxAttempts; attempt++) {
 118:     try {
 119:       return await withTimeout(operation(), timeoutMs)
 120:     } catch (err) {
 121:       lastError = err
 122:       if (attempt === maxAttempts) break
 123:       const baseDelay = RETRY_DELAY_MS * Math.pow(2, attempt - 1)
 124:       const jitter = Math.random() * RETRY_DELAY_MS
 125:       const delay = baseDelay + jitter
 126:       logger?.warn?.('Retrying Perplexity operation', {
 127:         attempt,
 128:         delay,
 129:         error: err instanceof Error ? err.message : String(err)
 130:       })
 131:       await new Promise(resolve => setTimeout(resolve, delay))
 132:     }
 133:   }
 134:   throw (lastError instanceof Error ? lastError : new Error('Operation failed'))
 135: }
 136: 
 137: // Removed unused PerplexityError class - using standard Error instead
 138: 
 139: // CRITICAL: This generates PATTERN-BASED emails (NOT VERIFIED)
 140: // These are stored as "alternativeEmails" with emailType: 'pattern' and low confidence
 141: // NEVER present these as verified contacts - they are guesses based on common patterns
 142: function inferEmails(name: string, companyDomain: string): string[] {
 143:   if (!name || !companyDomain) return []
 144:   const parts = name.toLowerCase().split(' ').filter(Boolean)
 145:   if (parts.length < 2) return []
 146:   const first = parts[0]
 147:   const last = parts[parts.length - 1]
 148:   const patterns = [
 149:     `${first}.${last}@${companyDomain}`,
 150:     `${first}${last}@${companyDomain}`,
 151:     `${first[0]}${last}@${companyDomain}`,
 152:     `${first}@${companyDomain}`,
 153:     `${last}@${companyDomain}`,
 154:     `${first}.${last[0]}@${companyDomain}`
 155:   ]
 156:   return patterns
 157: }
 158: 
 159: function normalizeSkills(skills: string[]): string[] {
 160:   const mapping: Record<string, string> = {
 161:     javascript: 'JavaScript', js: 'JavaScript',
 162:     typescript: 'TypeScript', ts: 'TypeScript',
 163:     react: 'React', reactjs: 'React',
 164:     node: 'Node.js', nodejs: 'Node.js',
 165:     python: 'Python', py: 'Python',
 166:     sales: 'Sales', selling: 'Sales',
 167:     crm: 'CRM', 'customer relationship management': 'CRM',
 168:     ai: 'Artificial Intelligence', 'artificial intelligence': 'Artificial Intelligence',
 169:     'machine learning': 'Machine Learning', ml: 'Machine Learning'
 170:   }
 171:   return (skills || []).map(s => {
 172:     const k = s.toLowerCase().trim()
 173:     return mapping[k] || s
 174:   })
 175: }
 176: 
 177: // CRITICAL FIX: Calculate years of experience from resume text
 178: // Prevents double-counting overlapping periods and filters out education dates
 179: function calculateYearsFromResume(resumeText: string): number {
 180:   // Extract only the work experience section to avoid counting education dates
 181:   const experienceSection = extractExperienceSection(resumeText)
 182:   
 183:   // Match date ranges in various formats
 184:   const dateRegex = /(\w+\s+\d{4}|(\d{1,2}\/\d{4}))\s*[-–—]\s*(\w+\s+\d{4}|Present|Current|(\d{1,2}\/\d{4}))/gi
 185:   const matches = Array.from(experienceSection.matchAll(dateRegex))
 186:   
 187:   // Parse all date ranges into start/end pairs
 188:   const periods: Array<{ start: Date; end: Date }> = []
 189:   for (const match of matches) {
 190:     try {
 191:       const startStr = match[1]
 192:       const endStr = match[3]
 193:       
 194:       const startDate = new Date(startStr)
 195:       const endDate = endStr.match(/Present|Current/i) ? new Date() : new Date(endStr)
 196:       
 197:       // Validate dates are reasonable (not in future, not before 1970)
 198:       if (startDate.getFullYear() < 1970 || startDate.getFullYear() > new Date().getFullYear()) continue
 199:       if (endDate.getFullYear() < 1970 || endDate.getFullYear() > new Date().getFullYear() + 1) continue
 200:       if (startDate > endDate) continue // Skip invalid ranges
 201:       
 202:       const months = (endDate.getFullYear() - startDate.getFullYear()) * 12 + 
 203:                     (endDate.getMonth() - startDate.getMonth())
 204:       
 205:       // Sanity check: skip periods longer than 50 years or negative
 206:       if (months > 0 && months < 600) {
 207:         periods.push({ start: startDate, end: endDate })
 208:       }
 209:     } catch (e) {
 210:       // Skip invalid dates
 211:       continue
 212:     }
 213:   }
 214:   
 215:   // If no valid periods found, return 0
 216:   if (periods.length === 0) return 0
 217:   
 218:   // Sort periods by start date
 219:   periods.sort((a, b) => a.start.getTime() - b.start.getTime())
 220:   
 221:   // Merge overlapping periods to avoid double-counting
 222:   const merged: Array<{ start: Date; end: Date }> = []
 223:   let current = periods[0]
 224:   
 225:   for (let i = 1; i < periods.length; i++) {
 226:     const next = periods[i]
 227:     
 228:     // If periods overlap or are adjacent, merge them
 229:     if (next.start <= current.end) {
 230:       current.end = new Date(Math.max(current.end.getTime(), next.end.getTime()))
 231:     } else {
 232:       // No overlap, push current and start new period
 233:       merged.push(current)
 234:       current = next
 235:     }
 236:   }
 237:   merged.push(current)
 238:   
 239:   // Calculate total months from merged periods
 240:   let totalMonths = 0
 241:   for (const period of merged) {
 242:     const months = (period.end.getFullYear() - period.start.getFullYear()) * 12 + 
 243:                   (period.end.getMonth() - period.start.getMonth())
 244:     totalMonths += months
 245:   }
 246:   
 247:   const years = Math.round(totalMonths / 12)
 248:   
 249:   // CRITICAL FIX: Cap at realistic maximum
 250:   // Assume candidate started working at age 18, max age 65
 251:   // Most candidates are 25-45, so cap at 25 years to be safe
 252:   const maxRealisticYears = 25
 253:   const cappedYears = Math.min(years, maxRealisticYears)
 254:   
 255:   // If calculated years seem unrealistic (>15), round down to nearest 5
 256:   if (cappedYears > 15) {
 257:     return Math.floor(cappedYears / 5) * 5
 258:   }
 259:   
 260:   return cappedYears
 261: }
 262: 
 263: // Extract work experience section from resume to avoid counting education dates
 264: function extractExperienceSection(resumeText: string): string {
 265:   const text = resumeText.toLowerCase()
 266:   
 267:   // Find work experience section markers
 268:   const experienceMarkers = [
 269:     'work experience',
 270:     'professional experience',
 271:     'employment history',
 272:     'experience',
 273:     'work history',
 274:     'career history'
 275:   ]
 276:   
 277:   // Find education section markers to exclude
 278:   const educationMarkers = [
 279:     'education',
 280:     'academic background',
 281:     'academic history',
 282:     'degrees'
 283:   ]
 284:   
 285:   let experienceStart = -1
 286:   let experienceMarker = ''
 287:   
 288:   // Find the earliest experience marker
 289:   for (const marker of experienceMarkers) {
 290:     const index = text.indexOf(marker)
 291:     if (index !== -1 && (experienceStart === -1 || index < experienceStart)) {
 292:       experienceStart = index
 293:       experienceMarker = marker
 294:     }
 295:   }
 296:   
 297:   // If no experience section found, use entire resume (fallback)
 298:   if (experienceStart === -1) return resumeText
 299:   
 300:   // Find where experience section ends (usually at education or end of document)
 301:   let experienceEnd = resumeText.length
 302:   for (const marker of educationMarkers) {
 303:     const index = text.indexOf(marker, experienceStart + experienceMarker.length)
 304:     if (index !== -1 && index < experienceEnd) {
 305:       experienceEnd = index
 306:     }
 307:   }
 308:   
 309:   return resumeText.substring(experienceStart, experienceEnd)
 310: }
 311: 
 312: // Enhanced response wrappers (non-breaking: used by new V2 methods only)
 313: export type RequestMetadata = { 
 314:   requestId: string
 315:   timestamp: number
 316:   duration?: number
 317:   error?: string
 318:   boardsSearched?: number
 319:   resultsCount?: number
 320:   attemptedCleanups?: string[]
 321:   contactsFound?: number
 322:   withEmails?: number
 323:   agent_iterations?: number
 324:   tools_used?: string[]
 325:   reasoning?: string
 326:   confidence?: number
 327:   method?: string
 328:   sources?: number
 329: }
 330: export type EnhancedResponse<T> = { success: boolean; data: T; metadata: RequestMetadata; cached: boolean }
 331: 
 332: export interface IntelligenceRequest {
 333:   company: string
 334:   role?: string
 335:   geo?: string
 336: }
 337: 
 338: export interface IntelligenceResponse {
 339:   company: string
 340:   freshness: string
 341:   sources: Array<{ title: string; url: string }>
 342:   confidence: number
 343:   financials: Array<{ metric: string; value: string; confidence: number; source?: string }>
 344:   culture: Array<{ point: string; confidence: number; source?: string }>
 345:   salaries: Array<{ title: string; range: string; currency?: string; geo?: string; source?: string; confidence: number }>
 346:   contacts: Array<{ name: string; title: string; url?: string; source?: string; confidence: number }>
 347:   growth: Array<{ signal: string; source?: string; confidence: number }>
 348:   summary: string
 349:   description: string
 350:   size: string
 351:   revenue: string
 352:   industry: string
 353:   founded: string
 354:   headquarters: string
 355:   psychology: string
 356:   marketIntelligence: string
 357:   // CRITICAL: New comprehensive intelligence fields
 358:   recentNews?: Array<{ title: string; date: string; url: string; summary: string }>
 359:   socialMedia?: {
 360:     linkedin?: string
 361:     twitter?: string
 362:     facebook?: string
 363:     instagram?: string
 364:     youtube?: string
 365:   }
 366:   glassdoorRating?: {
 367:     overallRating?: number
 368:     ceoApproval?: number
 369:     recommendToFriend?: number
 370:     reviewCount?: number
 371:     url?: string
 372:   }
 373:   stockProfile?: {
 374:     ticker?: string
 375:     exchange?: string
 376:     currentPrice?: string
 377:     marketCap?: string
 378:     isPublic?: boolean
 379:   }
 380: }
 381: 
 382: // V2 Data structures (for job listings and contacts)
 383: export interface JobListing {
 384:   title: string
 385:   company: string
 386:   location: string
 387:   address?: string | null
 388:   url: string
 389:   source?: string
 390:   summary: string
 391:   postedDate: string
 392:   salary?: string | null
 393:   skillMatchPercent: number
 394:   skills: string[]
 395:   workType?: 'remote' | 'hybrid' | 'onsite'
 396:   experienceLevel?: 'entry' | 'mid' | 'senior' | 'executive'
 397:   contacts: {
 398:     hrEmail?: string | null
 399:     hiringManagerEmail?: string | null
 400:     generalEmail?: string | null
 401:     phone?: string | null
 402:     linkedinProfiles: string[]
 403:   }
 404:   benefits?: string[]
 405:   requirements?: string[]
 406: }
 407: 
 408: export interface HiringContact {
 409:   name: string
 410:   title: string
 411:   department: string
 412:   linkedinUrl?: string | null
 413:   email?: string | null
 414:   emailType?: 'public' | 'inferred' | 'pattern'
 415:   source: string
 416:   confidence: number
 417:   phone?: string | null
 418:   alternativeEmails?: string[]
 419:   discoveryMethod?: string
 420: }
 421: 
 422: export interface QuickSearchItem {
 423:   title: string
 424:   url: string
 425:   snippet: string
 426:   source: string
 427:   postedDate?: string
 428:   location?: string
 429:   company?: string
 430:   date?: string
 431: }
 432: 
 433: const SYSTEM = `You are a research analyst using real-time web tools.
 434: CRITICAL: Your response must be ONLY valid JSON. NO explanatory text, NO markdown, NO commentary.
 435: Rules:
 436: - Use only public sources and respect robots.txt by following links provided by Perplexity tools.
 437: - Always return ONLY structured JSON matching the requested schema.
 438: - Include 5-10 source citations with titles and URLs.
 439: - Provide confidence scores (0-1) for each data point and overall.
 440: - Mark estimates or unverified signals clearly.
 441: - NEVER add text before or after the JSON response.
 442: `
 443: 
 444: interface ComprehensiveJobResearchData {
 445:   jobAnalysis: {
 446:     matchScore: number
 447:     matchingSkills: string[]
 448:     missingSkills: string[]
 449:     skillsToHighlight: string[]
 450:     recommendations: string[]
 451:     estimatedFit: string
 452:   }
 453:   companyIntel: {
 454:     company: string
 455:     description: string
 456:     size?: string
 457:     revenue?: string
 458:     industry?: string
 459:     founded?: string
 460:     headquarters?: string
 461:     website?: string
 462:     marketPosition?: string
 463:   }
 464:   companyPsychology: {
 465:     culture: string
 466:     values: string[]
 467:     managementStyle?: string
 468:     workEnvironment?: string
 469:   }
 470:   hiringContacts: Array<{
 471:     name: string
 472:     title: string
 473:     department?: string
 474:     email?: string
 475:     linkedinUrl?: string
 476:     authority: 'decision maker' | 'recruiter' | 'manager' | 'coordinator'
 477:     confidence: number
 478:     contactMethod?: string
 479:   }>
 480:   marketIntelligence: {
 481:     competitivePosition?: string
 482:     industryTrends?: string
 483:     financialStability?: string
 484:     recentPerformance?: string
 485:   }
 486:   news: Array<{
 487:     title: string
 488:     summary: string
 489:     url: string
 490:     date?: string
 491:     source?: string
 492:     impact?: string
 493:   }>
 494:   reviews: Array<{
 495:     platform: string
 496:     rating?: number
 497:     summary: string
 498:     url: string
 499:     pros?: string[]
 500:     cons?: string[]
 501:   }>
 502:   compensation: {
 503:     salaryRange?: string
 504:     benefits?: string
 505:   }
 506:   strategicRecommendations: {
 507:     applicationStrategy: string
 508:     contactStrategy: string
 509:     interviewPrep: string[]
 510:   }
 511:   sources: string[]
 512:   confidenceLevel: number
 513: }
 514: 
 515: interface EnhancedCompanyResearchData {
 516:   companyIntelligence: {
 517:     name: string
 518:     industry?: string
 519:     founded?: string
 520:     headquarters?: string
 521:     employeeCount?: string
 522:     revenue?: string
 523:     website?: string
 524:     description?: string
 525:     marketPosition?: string
 526:     financialStability?: string
 527:     recentPerformance?: string
 528:   }
 529:   hiringContactIntelligence: {
 530:     officialChannels?: {
 531:       careersPage?: string
 532:       jobsEmail?: string
 533:       hrEmail?: string
 534:       phone?: string
 535:       address?: string
 536:     }
 537:     keyContacts?: Array<{
 538:       name: string
 539:       title: string
 540:       department?: string
 541:       linkedinUrl?: string
 542:       email?: string
 543:       authority?: string
 544:       contactMethod?: string
 545:     }>
 546:     emailFormat?: string
 547:     socialMedia?: Record<string, string>
 548:   }
 549:   companyPsychology?: {
 550:     culture?: string
 551:     values?: string[]
 552:     managementStyle?: string
 553:     workEnvironment?: string
 554:   }
 555:   reviewAnalysis?: {
 556:     glassdoor?: {
 557:       rating?: number
 558:       reviewCount?: number
 559:       ceoApproval?: string | number
 560:       recommendToFriend?: string | number
 561:       pros?: string[]
 562:       cons?: string[]
 563:     }
 564:     employeeSentiment?: string
 565:   }
 566:   aiAutomationThreat?: {
 567:     roleRisk?: string
 568:     automationProbability?: string
 569:     timeframe?: string
 570:     companyAIAdoption?: string
 571:     futureOutlook?: string
 572:     recommendations?: string[]
 573:   }
 574:   recentNews?: Array<{
 575:     headline?: string
 576:     date?: string
 577:     source?: string
 578:     url?: string
 579:     impact?: string
 580:   }>
 581:   compensation?: {
 582:     salaryRange?: string
 583:     benefits?: string
 584:   }
 585:   redFlags?: string[]
 586:   strategicRecommendations?: {
 587:     applicationStrategy?: string
 588:     contactStrategy?: string
 589:     interviewPrep?: string[]
 590:   }
 591:   sources?: string[]
 592:   confidenceLevel?: number
 593: }
 594: 
 595: export class PerplexityIntelligenceService {
 596:   /**
 597:    * CRITICAL FIX: Scrapes job URL to get full description when Perplexity returns incomplete data
 598:    * Fallback for when descriptions are too short
 599:    */
 600:   private static async scrapeJobURL(url: string): Promise<string> {
 601:     try {
 602:       const response = await fetch(url, {
 603:         headers: {
 604:           'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
 605:         },
 606:         signal: AbortSignal.timeout(10000) // 10 second timeout
 607:       })
 608:       
 609:       if (!response.ok) return ''
 610:       
 611:       const html = await response.text()
 612:       
 613:       // Try multiple common job description selectors
 614:       const patterns = [
 615:         /<div[^>]*class="[^"]*description[^"]*"[^>]*>(.*?)<\/div>/is,
 616:         /<div[^>]*id="[^"]*description[^"]*"[^>]*>(.*?)<\/div>/is,
 617:         /<section[^>]*class="[^"]*job-description[^"]*"[^>]*>(.*?)<\/section>/is,
 618:         /<div[^>]*class="[^"]*job-details[^"]*"[^>]*>(.*?)<\/div>/is
 619:       ]
 620:       
 621:       for (const pattern of patterns) {
 622:         const match = html.match(pattern)
 623:         if (match && match[1]) {
 624:           // Strip HTML tags and clean up
 625:           const cleaned = match[1]
 626:             .replace(/<script[^>]*>.*?<\/script>/gis, '')
 627:             .replace(/<style[^>]*>.*?<\/style>/gis, '')
 628:             .replace(/<[^>]+>/g, ' ')
 629:             .replace(/\s+/g, ' ')
 630:             .trim()
 631:           
 632:           if (cleaned.length > 150) {
 633:             return cleaned
 634:           }
 635:         }
 636:       }
 637:       
 638:       return ''
 639:     } catch (error) {
 640:       if (process.env.PPX_DEBUG === 'true') {
 641:         console.warn(`[SCRAPE] Failed to scrape ${url}:`, error)
 642:       }
 643:       return ''
 644:     }
 645:   }
 646: 
 647:   /**
 648:    * CRITICAL FIX: Validates job listings response from Perplexity
 649:    * Filters out incomplete, fake, or low-quality jobs
 650:    */
 651:   private static validateJobListings(jobs: JobListing[], minRequired: number): JobListing[] {
 652:     const validated = jobs.filter((job: JobListing) => {
 653:       // ❌ REJECT: Empty or short descriptions
 654:       if (!job.summary || job.summary.trim().length < 150) {
 655:         if (process.env.PPX_DEBUG === 'true') {
 656:           console.warn(`[VALIDATE] Rejecting ${job.title} - description too short (${job.summary?.length || 0} chars)`)
 657:         }
 658:         return false
 659:       }
 660:       
 661:       // ❌ REJECT: Confidential companies
 662:       const confidentialKeywords = ['confidential', 'various', 'tbd', 'multiple', 'undisclosed', 'anonymous', 'private', 'stealth', 'hidden']
 663:       const company = String(job.company || '').toLowerCase().trim()
 664:       if (confidentialKeywords.some(kw => company.includes(kw)) || company.length < 3) {
 665:         if (process.env.PPX_DEBUG === 'true') {
 666:           console.warn(`[VALIDATE] Rejecting ${job.title} - confidential company: ${job.company}`)
 667:         }
 668:         return false
 669:       }
 670:       
 671:       // ❌ REJECT: No valid URL
 672:       if (!job.url || !job.url.includes('http')) {
 673:         if (process.env.PPX_DEBUG === 'true') {
 674:           console.warn(`[VALIDATE] Rejecting ${job.title} - invalid URL: ${job.url}`)
 675:         }
 676:         return false
 677:       }
 678:       
 679:       // ✅ ACCEPT
 680:       return true
 681:     })
 682:     
 683:     // Warn if too many filtered out
 684:     if (validated.length < minRequired * 0.5 && process.env.PPX_DEBUG === 'true') {
 685:       console.warn(`[VALIDATE] Only ${validated.length}/${minRequired} jobs passed validation (${Math.round(validated.length/minRequired*100)}%)`)
 686:     }
 687:     
 688:     return validated
 689:   }
 690: 
 691:   /**
 692:    * CRITICAL FIX: Validates hiring contacts response from Perplexity
 693:    * Filters out fake emails, personal domains, pattern-based guesses
 694:    */
 695:   private static validateHiringContacts(contacts: HiringContact[]): HiringContact[] {
 696:     const validated = contacts.filter((contact: HiringContact) => {
 697:       // ❌ REJECT: No email and no LinkedIn
 698:       if (!contact.email && !contact.linkedinUrl) {
 699:         if (process.env.PPX_DEBUG === 'true') {
 700:           console.warn(`[VALIDATE] Rejecting ${contact.name} - no contact method`)
 701:         }
 702:         return false
 703:       }
 704:       
 705:       // ❌ REJECT: Personal email domains (if email exists)
 706:       if (contact.email) {
 707:         const personalDomains = ['gmail', 'yahoo', 'hotmail', 'outlook', 'aol', 'icloud', 'protonmail']
 708:         if (personalDomains.some(d => contact.email!.toLowerCase().includes(d))) {
 709:           if (process.env.PPX_DEBUG === 'true') {
 710:             console.warn(`[VALIDATE] Rejecting ${contact.email} - personal domain`)
 711:           }
 712:           return false
 713:         }
 714:         
 715:         // ❌ REJECT: Template/placeholder emails
 716:         if (contact.email.includes('[') || contact.email.includes('VISIT') || contact.email.includes('example') || contact.email.includes('domain.')) {
 717:           if (process.env.PPX_DEBUG === 'true') {
 718:             console.warn(`[VALIDATE] Rejecting ${contact.email} - template email`)
 719:           }
 720:           return false
 721:         }
 722:       }
 723:       
 724:       // ✅ ACCEPT
 725:       return true
 726:     })
 727:     
 728:     return validated
 729:   }
 730: 
 731:   // V2: Enhanced company research with retries and metadata
 732:   static async researchCompanyV2(input: IntelligenceRequest): Promise<EnhancedResponse<IntelligenceResponse>> {
 733:     const requestId = generateRequestId()
 734:     const started = Date.now()
 735:     const key = makeKey('ppx:research:v2', input)
 736:     const cached = getCache(key) as IntelligenceResponse | undefined
 737:     if (cached) {
 738:       return { success: true, data: cached, metadata: { requestId, timestamp: started, duration: Date.now() - started }, cached: true }
 739:     }
 740:     try {
 741:       const userPrompt = `COMPREHENSIVE RESEARCH TASK: Search for contacts, emails, website, and complete intelligence for ${input.company}${input.role ? ` (role: ${input.role})` : ''}${input.geo ? ` in ${input.geo}` : ''}.
 742: 
 743: **MANDATORY SEARCH SOURCES:**
 744: - Use Google search extensively
 745: - Search LinkedIn company page AND individual employee profiles
 746: - Search all social media platforms (Twitter, Facebook, Instagram, YouTube)
 747: - Search company website thoroughly
 748: - Search business directories (BBB, Yellow Pages, ZoomInfo, etc.)
 749: - Search news sources and press releases
 750: - Search Glassdoor for reviews and salaries
 751: - Search stock exchanges if publicly traded
 752: 
 753: **RETURN DETAILED JSON with ALL fields below:**
 754: {
 755:   "company": string (full legal name),
 756:   "description": string (detailed company overview - NOT "No description available"),
 757:   "size": string (employee count with source),
 758:   "revenue": string (annual revenue estimate with source),
 759:   "industry": string (specific industry classification),
 760:   "founded": string (year or date with source),
 761:   "headquarters": string (full address with city, province/state, postal code),
 762:   "psychology": string (company culture, values, workplace environment - from Glassdoor/employee reviews),
 763:   "marketIntelligence": string (market position, competitive landscape, growth trends - detailed analysis),
 764:   "freshness": string (ISO datetime of research),
 765:   "sources": [{"title": string, "url": string}] (minimum 8 sources, up to 20),
 766:   "confidence": number (0 to 1),
 767:   "financials": [{"metric": string, "value": string, "confidence": number, "source": string}],
 768:   "culture": [{"point": string, "confidence": number, "source": string}] (from Glassdoor/reviews),
 769:   "salaries": [{"title": string, "range": string, "currency": string, "geo": string, "source": string, "confidence": number}],
 770:   "contacts": [{"name": string, "title": string, "email": string, "url": string, "source": string, "confidence": number}] (executives, managers, recruiters from LinkedIn with emails),
 771:   "generalEmail": string (company general inbox: careers@, hr@, jobs@, info@, hello@, contact@ - MANDATORY),
 772:   "careersPage": string (company careers/jobs page URL),
 773:   "growth": [{"signal": string, "source": string, "confidence": number}],
 774:   "summary": string (comprehensive 2-3 paragraph summary),
 775:   "recentNews": [{"title": string, "date": string, "url": string, "summary": string}] (last 6 months),
 776:   "socialMedia": {"linkedin": string, "twitter": string, "facebook": string, "instagram": string, "youtube": string},
 777:   "glassdoorRating": {"overallRating": number, "ceoApproval": number, "recommendToFriend": number, "reviewCount": number, "url": string},
 778:   "stockProfile": {"ticker": string, "exchange": string, "currentPrice": string, "marketCap": string, "isPublic": boolean}
 779: }
 780: 
 781: **CRITICAL REQUIREMENTS:**
 782: 1. Search company website for About page, Contact page, Leadership/Team page
 783: 2. **MANDATORY**: Extract company general email from website footer/contact page (careers@, hr@, jobs@, info@, hello@, contact@)
 784: 3. **MANDATORY**: Find company careers/jobs page URL
 785: 4. Search "site:linkedin.com/company/${input.company}" for official company page
 786: 5. Search "site:linkedin.com ${input.company} CEO OR president OR manager" for executive contacts WITH emails
 787: 6. Search "${input.company} headquarters address phone email"
 788: 7. Search "${input.company} site:glassdoor.com" for reviews and culture insights
 789: 8. Search "${input.company} revenue employees industry" for business intelligence
 790: 9. DO NOT return "Unknown", "No description available", or "No data" - search multiple sources until you find information
 791: 10. Include REAL contact information (names, titles, emails, LinkedIn URLs) - minimum 3 contacts if company has >10 employees
 792: 11. **APP IS USELESS WITHOUT CONTACT INFO** - Always return at least generalEmail even if no specific contacts found`
 793:       const out = await withRetry(async () => {
 794:         const client = createClient()
 795:         const user = userPrompt
 796:         const res = await client.makeRequest(SYSTEM, user, { temperature: 0.2, maxTokens: 3000, model: 'sonar-pro' })
 797:         if (!res.content?.trim()) throw new Error('Empty response')
 798:         return res
 799:       })
 800:       const context = {
 801:         requestId,
 802:         prompts: { system: SYSTEM, user: userPrompt },
 803:         timestamp: started,
 804:         duration: Date.now() - started
 805:       }
 806:       const parsed = parseAIResponse<IntelligenceResponse>(out.content ?? '', { stripMarkdown: true, extractFirst: true }, context)
 807:       parsed.company = parsed.company || input.company
 808:       parsed.freshness = parsed.freshness || new Date().toISOString()
 809:       parsed.sources = Array.isArray(parsed.sources) ? parsed.sources.slice(0, 12) : []
 810:       parsed.confidence = typeof parsed.confidence === 'number' ? Math.max(0, Math.min(1, parsed.confidence)) : 0.6
 811:       if (Array.isArray(parsed.contacts)) {
 812:         parsed.contacts = parsed.contacts.map(c => ({ ...c, url: c.url }))
 813:       }
 814:       setCache(key, parsed)
 815:       return { success: true, data: parsed, metadata: { requestId, timestamp: started, duration: Date.now() - started }, cached: false }
 816:     } catch (e) {
 817:       const fb: IntelligenceResponse = {
 818:         company: input.company,
 819:         freshness: new Date().toISOString(),
 820:         sources: [],
 821:         confidence: 0.3,
 822:         financials: [],
 823:         culture: [],
 824:         salaries: [],
 825:         contacts: [],
 826:         growth: [],
 827:         summary: 'Research failed - please retry',
 828:         description: 'No description available',
 829:         size: 'Unknown',
 830:         revenue: 'Unknown',
 831:         industry: 'Unknown',
 832:         founded: 'Unknown',
 833:         headquarters: 'Unknown',
 834:         psychology: 'No insights available',
 835:         marketIntelligence: 'No market data available',
 836:         recentNews: [],
 837:         socialMedia: {},
 838:         glassdoorRating: undefined,
 839:         stockProfile: undefined
 840:       }
 841:       return { success: false, data: fb, metadata: { requestId, timestamp: started, duration: Date.now() - started, error: (e as Error).message }, cached: false }
 842:     }
 843:   }
 844:   // REMOVED: Old researchCompany - Use researchCompanyV2 instead
 845: 
 846:   static async salaryForRole(role: string, company?: string, geo?: string) {
 847:     const key = makeKey('ppx:salary', { role, company, geo })
 848:     const cached = getCache(key)
 849:     if (cached) return cached
 850:     const client = createClient()
 851:     const user = `Find current salary ranges for ${role}${company ? ` at ${company}` : ''}${geo ? ` in ${geo}` : ''}. Return JSON: items[{title,range,currency,geo,source,confidence}], summary, freshness`;
 852:     try {
 853:       const out = await client.makeRequest(SYSTEM, user, { temperature: 0.2, maxTokens: 900, model: 'sonar-pro' })
 854:       const text = (out.content || '').trim()
 855:       const context = {
 856:         requestId: generateRequestId(),
 857:         prompts: { system: SYSTEM, user },
 858:         timestamp: Date.now(),
 859:         duration: 0
 860:       }
 861:       const parsed = parseAIResponse<Record<string, unknown>>(text, { stripMarkdown: true, extractFirst: true }, context)
 862:       setCache(key, parsed)
 863:       return parsed
 864:     } catch {
 865:       return { items: [], summary: 'Unavailable', freshness: new Date().toISOString() }
 866:     }
 867:   }
 868: 
 869:   /**
 870:    * Enhanced job listings search across 25+ Canadian and global job boards
 871:    * Integrates with public-job-boards-config.ts for comprehensive coverage
 872:    */
 873:   static async jobListings(
 874:     jobTitle: string, 
 875:     location: string,
 876:     options: {
 877:       boards?: string[] // Specific boards to search (uses DISCOVERY_PRIORITY_ORDER if not specified)
 878:       limit?: number
 879:       includeCanadianOnly?: boolean
 880:     } = {}
 881:   ) {
 882:     const { boards, limit = 50, includeCanadianOnly = false } = options
 883:     const key = makeKey('ppx:jobs', { jobTitle, location, boards, limit })
 884:     const cached = getCache(key)
 885:     if (cached) return cached
 886: 
 887:     // Determine which boards to search
 888:     const targetBoards = boards || (includeCanadianOnly 
 889:       ? Object.keys(CANADIAN_JOB_BOARDS)
 890:       : DISCOVERY_PRIORITY_ORDER.slice(0, 15) // Top 15 boards
 891:     )
 892: 
 893:     // Note: targetBoards is used in the Perplexity prompt below to guide source selection
 894: 
 895:     const client = createClient()
 896:     const SYSTEM_JOBS = `You are an advanced Job Listings Aggregator with real-time web access across 25+ Canadian and global job boards.
 897: 
 898: PRIORITY CANADIAN SOURCES:
 899: - Job Bank Canada (jobbank.gc.ca) - Government jobs
 900: - AutoJobs (autojobs.com) - Canadian automotive & skilled trades
 901: - SimplyHired Canada (simplyhired.ca) - Canadian aggregator
 902: - Jobboom (jobboom.com) - Bilingual Canadian
 903: - Workopolis (workopolis.com) - Canadian
 904: - Indeed Canada (ca.indeed.com)
 905: - Jooble Canada (ca.jooble.org)
 906: - ZipRecruiter Canada (ziprecruiter.ca)
 907: - Monster Canada (monster.ca)
 908: - Glassdoor Canada (glassdoor.ca)
 909: - Dice Canada (dice.com)
 910: - Careerjet Canada (careerjet.ca)
 911: 
 912: GLOBAL SOURCES:
 913: - LinkedIn (linkedin.com/jobs)
 914: - Indeed (indeed.com)
 915: - Glassdoor (glassdoor.com)
 916: - Adzuna (adzuna.com)
 917: 
 918: ATS PLATFORMS (Canadian Tech Companies):
 919: - Greenhouse: Shopify, Hootsuite, Wealthsimple, Faire, Thinkific, Lightspeed
 920: - Lever: Slack, Shopify, Bench, Clio, Clearco, League
 921: - Workable: FreshBooks, Visier, Unbounce, Axonify
 922: - Recruitee: Paytm, Ecobee, Geotab, Auvik, Wave, KOHO
 923: - Ashby: Faire, Clearco, Maple, Borrowell, Shakepay
 924: - Breezy HR: Lumerate, Zymewire, and other Canadian startups
 925: - Communitech Job Board: communitech.ca/companies (Waterloo tech ecosystem)
 926: - RemoteRocketship: remoterocketship.com (Remote Canadian jobs)
 927: 
 928: 🔥 CRITICAL - FOLLOW LINKS AND EXTRACT FULL CONTENT:
 929: For EACH job found, you MUST:
 930: 1. Find the job in search results (title, company, location, URL)
 931: 2. **FOLLOW THE JOB URL** and visit the actual job posting page
 932: 3. **SCRAPE THE COMPLETE JOB DESCRIPTION** from the posting page (all paragraphs, all bullet points)
 933: 4. Extract salary, benefits, requirements, responsibilities from the posting page
 934: 5. If company name is "Confidential" in search results - **VISIT THE URL** and extract the REAL company name from the posting page
 935: 6. If description is missing - **TRY COMPANY CAREERS PAGE** (company.com/careers) or **COMPANY ATS** (company.breezy.hr, company.greenhouse.io)
 936: 
 937: CRITICAL REQUIREMENTS:
 938: 1. **ONLY REAL COMPANY NAMES** - ABSOLUTELY NO CONFIDENTIAL LISTINGS:
 939:    ❌ REJECT AND SKIP: "Confidential", "Various Employers", "Multiple Companies", "Undisclosed", "Private", "TBD", "N/A", "Various [Industry]", "Anonymous", "Stealth", "Hidden"
 940:    ❌ DO NOT INCLUDE jobs where company name is hidden or confidential
 941:    ✅ ONLY INCLUDE: Jobs with real, specific company names (e.g., "Ricoh Canada", "Shopify", "TD Bank", "Lumerate", "Zymewire")
 942: 2. **VERIFY COMPANY EXISTS** - Must be a real, identifiable company
 943: 3. **SKIP INVALID LISTINGS** - If company name is missing or confidential, DO NOT include it in results
 944: 4. **EXTRACT FULL DESCRIPTIONS** - Visit each job URL and scrape complete description (minimum 200 words)
 945: 5. Search ONLY publicly accessible listings (no login required)
 946: 6. Prioritize Canadian sources for Canadian locations
 947: 7. **Extract salary** from job posting page if available
 948: 8. Deduplicate across all sources by company + title
 949: 9. Rank by: recency → Canadian source priority → relevance
 950: 10. Return EXACTLY ${limit} unique listings with REAL company names and FULL descriptions
 951: 
 952: OUTPUT JSON (MUST BE VALID, COMPLETE JSON):
 953: [{
 954:   "title": string (specific job title, not "Various Positions"),
 955:   "company": string (EXACT company name, not generic),
 956:   "location": string (specific city/province),
 957:   "url": string (direct job posting link),
 958:   "summary": string (200-400 words, COMPLETE job description from posting page),
 959:   "salary": string | null (extracted from posting page),
 960:   "postedDate": "YYYY-MM-DD",
 961:   "source": string (board name),
 962:   "requirements": string[] (key requirements from posting),
 963:   "benefits": string[] (benefits mentioned in posting)
 964: }]`
 965: 
 966:     const USER_JOBS = `Search for "${jobTitle}" jobs in ${location} across these prioritized sources:
 967: ${targetBoards.slice(0, 10).join(', ')}
 968: 
 969: Return ${limit} unique, recent listings in JSON format. For Canadian locations, prioritize Job Bank, Jobboom, Workopolis first.`
 970: 
 971:     const requestId = generateRequestId()
 972:     const started = Date.now()
 973:     try {
 974:       const out = await client.makeRequest(SYSTEM_JOBS, USER_JOBS, { 
 975:         temperature: 0.2, 
 976:         maxTokens: Math.min(limit * 500, 30000), // CRITICAL FIX: Increased from 300 to 500 tokens per job for full descriptions
 977:         model: 'sonar-pro' // Use research model for job search
 978:       })
 979:       
 980:       // FIXED: Check for truncation warning
 981:       if (out.content.length > 18000) {
 982:         console.warn('[JOB_LISTINGS] Response may be truncated, consider reducing limit or splitting into batches')
 983:       }
 984:       let text = (out.content || '').trim()
 985:       
 986:       // Extract JSON from response if wrapped in markdown or explanation
 987:       const jsonMatch = text.match(/\[[\s\S]*\]/)
 988:       if (jsonMatch) {
 989:         text = jsonMatch[0]
 990:       }
 991:       
 992:       // FIX: Clean up truncated JSON
 993:       // If JSON ends abruptly without closing ], try to fix it
 994:       if (!text.endsWith(']')) {
 995:         console.warn('[PERPLEXITY] JSON appears truncated, attempting to fix')
 996:         // Find last complete object
 997:         const lastCompleteObj = text.lastIndexOf('}')
 998:         if (lastCompleteObj > 0) {
 999:           text = text.substring(0, lastCompleteObj + 1) + ']'
1000:         }
1001:       }
1002:       
1003:       // FIX: Remove trailing commas before ]
1004:       text = text.replace(/,(\s*)\]/g, '$1]')
1005:       
1006:       const context = {
1007:         requestId,
1008:         prompts: { system: SYSTEM_JOBS, user: USER_JOBS },
1009:         timestamp: started,
1010:         duration: Date.now() - started
1011:       }
1012:       let parsed: unknown
1013:       try {
1014:         parsed = parseAIResponse<unknown>(text, { stripMarkdown: true, extractFirst: true }, context)
1015:       } catch (parseError: unknown) {
1016:         console.error('[PERPLEXITY] JSON parse failed, raw text:', text.substring(0, 500))
1017:         console.error('[PERPLEXITY] Parse error:', parseError)
1018:         return []
1019:       }
1020:       
1021:       const arr = Array.isArray(parsed) ? parsed.slice(0, limit) : []
1022:       
1023:       // CRITICAL FIX: Filter out confidential companies (NO FAKE/INFERRED DATA)
1024:       const filtered = arr.filter((job: unknown) => {
1025:         const jobObj = job as Record<string, unknown>
1026:         const companyRaw = String(jobObj.company || '')
1027:         const company = companyRaw.toLowerCase().trim()
1028:         
1029:         const isConfidential = 
1030:           company.includes('confidential') ||
1031:           company.includes('anonymous') ||
1032:           company.includes('undisclosed') ||
1033:           company.includes('various') ||
1034:           company.includes('multiple') ||
1035:           company.includes('private') ||
1036:           company.includes('stealth') ||
1037:           company.includes('hidden') ||
1038:           company.includes('tbd') ||
1039:           company.includes('n/a') ||
1040:           company === '' ||
1041:           company.length < 3
1042:         
1043:         if (isConfidential) {
1044:           return false
1045:         }
1046:         return true
1047:       })
1048:       
1049:       // Filtered confidential postings
1050:       
1051:       // Enhance with board metadata
1052:       const enhanced = filtered.map((job: unknown) => {
1053:         const jobObj = job as Record<string, unknown>
1054:         return {
1055:           ...jobObj,
1056:           metadata: {
1057:             searchedBoards: targetBoards.length,
1058:             canadianPriority: includeCanadianOnly,
1059:             extractedAt: new Date().toISOString(),
1060:             confidentialFiltered: arr.length - filtered.length
1061:           }
1062:         }
1063:       })
1064:       
1065:       // FIXED: Only cache if we have good success rate (at least 80%)
1066:       const successRate = enhanced.length / limit
1067:       if (enhanced.length > 0 && successRate >= 0.8) {
1068:         setCache(key, enhanced)
1069:         // Cached jobs
1070:       } else if (enhanced.length > 0) {
1071:         // Skipping cache - low success rate
1072:       }
1073:       return enhanced
1074:     } catch (error) {
1075:       console.error('[PERPLEXITY] Job listings failed:', error)
1076:       return []
1077:     }
1078:   }
1079: 
1080:   // Fast SEARCH API for raw listings from specific domains (outside of template strings)
1081:   static async jobQuickSearch(query: string, domains: string[] = [], maxResults: number = 20, recency: 'day'|'week'|'month'|'year' = 'month'): Promise<QuickSearchItem[]> {
1082:     const key = makeKey('ppx:search', { query, domains, maxResults, recency })
1083:     const cached = getCache(key) as QuickSearchItem[] | undefined
1084:     if (cached) return cached
1085:     try {
1086:       const resp = await fetch('https://api.perplexity.ai/search', {
1087:         method: 'POST',
1088:         headers: {
1089:           'Authorization': `Bearer ${process.env.PERPLEXITY_API_KEY || ''}`,
1090:           'Content-Type': 'application/json'
1091:         },
1092:         body: JSON.stringify({
1093:           query,
1094:           max_results: Math.max(5, Math.min(25, maxResults)),
1095:           ...(domains.length ? { search_domain_filter: domains } : {}),
1096:           search_recency_filter: recency
1097:         })
1098:       })
1099:       if (!resp.ok) throw new Error('ppx search failed')
1100:       const data = await resp.json() as unknown
1101:       const asRecord = data as Record<string, unknown>
1102:       const arr = (Array.isArray(asRecord?.results) ? (asRecord.results as unknown[]) : (Array.isArray(data as unknown[]) ? (data as unknown[]) : []))
1103:       const mapped: QuickSearchItem[] = arr.map((raw: unknown) => {
1104:         const it = (raw || {}) as Record<string, unknown>
1105:         const title = typeof it.title === 'string' ? it.title : (typeof it.snippet === 'string' ? String(it.snippet) : '')
1106:         const url = typeof it.url === 'string' ? it.url : (typeof it.link === 'string' ? String(it.link) : '')
1107:         const snippet = typeof it.snippet === 'string' ? String(it.snippet) : (typeof it.summary === 'string' ? String(it.summary) : '')
1108:         const source = typeof it.domain === 'string' ? String(it.domain) : (typeof it.source === 'string' ? String(it.source) : '')
1109:         const publishedTime = it.published_time
1110:         const dateField = it.date
1111:         const published = (typeof publishedTime === 'string' ? publishedTime : (typeof dateField === 'string' ? dateField : undefined))
1112:         return { title, url, snippet, source, postedDate: published }
1113:       })
1114:       setCache(key, mapped)
1115:       return mapped
1116:     } catch {
1117:       return []
1118:     }
1119:   }
1120: 
1121:   // REMOVED: jobMarketAnalysis wrapper - Use jobMarketAnalysisV2 directly
1122:   /**
1123:    * V2: Enhanced job market analysis with options and ranking
1124:    * Now integrated with 25+ Canadian and global job boards
1125:    */
1126:   static async jobMarketAnalysisV2(
1127:     location: string, 
1128:     resumeText: string, 
1129:     options: { 
1130:       roleHint?: string
1131:       workType?: 'remote'|'hybrid'|'onsite'|'any'
1132:       salaryMin?: number
1133:       experienceLevel?: 'entry'|'mid'|'senior'|'executive'
1134:       maxResults?: number
1135:       boards?: string[] // Specify which boards to prioritize
1136:     } = {}
1137:   ): Promise<EnhancedResponse<JobListing[]>> {
1138:     const requestId = generateRequestId()
1139:     const started = Date.now()
1140:     const key = makeKey('ppx:jobmarket:v2', { location, resume: resumeText.slice(0,1000), options })
1141:     const cached = getCache(key) as JobListing[] | undefined
1142:     if (cached) return { success: true, data: cached, metadata: { requestId, timestamp: started, duration: Date.now() - started }, cached: true }
1143: 
1144:     // Determine if location is Canadian for prioritization
1145:     const isCanadian = /canada|canadian|toronto|vancouver|montreal|calgary|ottawa|edmonton|quebec|winnipeg|halifax/i.test(location)
1146:     const targetBoards = options.boards || (isCanadian 
1147:       ? DISCOVERY_PRIORITY_ORDER.filter(b => CANADIAN_JOB_BOARDS[b]).concat(['linkedin', 'indeed', 'glassdoor'])
1148:       : DISCOVERY_PRIORITY_ORDER.slice(0, 15)
1149:     )
1150: 
1151:     try {
1152:       const out = await withRetry(async () => {
1153:         const client = createClient()
1154:         const prompt = `Find ${options.maxResults || 25} relevant job opportunities in ${location} matching this profile.
1155: 
1156: RESUME:
1157: ${resumeText}
1158: 
1159: FILTERS:
1160: - Role: ${options.roleHint || '(infer from resume)'}
1161: - Work Type: ${options.workType || 'any'}
1162: - Experience: ${options.experienceLevel || 'any'}
1163: - Min Salary: ${options.salaryMin ? ('$' + options.salaryMin + '+') : 'any'}
1164: 
1165: PRIORITY JOB BOARDS (use site: search for each):
1166: ${targetBoards.slice(0, 12).map((board, i) => {
1167:   const config = CANADIAN_JOB_BOARDS[board] || MAJOR_JOB_BOARDS[board] || OPEN_API_BOARDS[board] || ATS_PLATFORMS[board]
1168:   const baseUrl = config?.scrapingConfig?.baseUrl || ''
1169:   const domain = baseUrl ? baseUrl.replace(/https?:\/\//, '').replace(/\/$/, '') : board
1170:   return `${i + 1}. site:${domain} "${options.roleHint || 'jobs'}" "${location}"`
1171: }).join('\n')}
1172: 
1173: ${isCanadian ? `
1174: CANADIAN ATS PLATFORMS - Check these tech companies:
1175: - Greenhouse: Shopify, Hootsuite, Wealthsimple, Faire, Thinkific, Lightspeed, Jobber
1176: - Lever: Slack, Bench, Clio, Clearco, League, ApplyBoard, Ritual
1177: - Workable: FreshBooks, Visier, Unbounce, Axonify, TouchBistro
1178: - Recruitee: Ecobee, Geotab, Auvik, Wave, KOHO, SkipTheDishes
1179: - Ashby: Faire, Clearco, Maple, Borrowell, Shakepay, Wealthsimple
1180: ` : ''}
1181: 
1182: REQUIREMENTS:
1183: 1. **CRITICAL**: Use real-time web search to find ACTUAL job postings from MULTIPLE boards
1184: 2. **PRIORITIZE LINKEDIN**: Search "site:linkedin.com/jobs ${options.roleHint || 'jobs'} ${location}" FIRST and get at least 15-20 LinkedIn jobs
1185: 3. Search other boards: "site:indeed.${isCanadian ? 'ca' : 'com'}", "site:glassdoor.${isCanadian ? 'ca' : 'com'}", etc.
1186: 4. Extract: title, company, location, URL (MUST be actual job posting URL), summary (at least 100 chars), posted date
1187: 5. **MANDATORY**: Return AT LEAST 30-40 jobs total. LinkedIn should be 40-50% of results.
1188: 6. **IMPORTANT**: Include jobs even if some fields are missing (use null for missing data)
1189: 7. Match resume skills to job requirements (estimate 0-100%)
1190: 8. If company is "Confidential", try to find real name from posting
1191: 9. **LINKEDIN URLS**: Must be format "https://www.linkedin.com/jobs/view/[job-id]" or "https://linkedin.com/jobs/collections/recommended/?currentJobId=[id]"
1192: 
1193: OUTPUT STRICT JSON ARRAY (no markdown, no wrapper object):
1194: [{
1195:   "title": "Job Title",
1196:   "company": "Company Name",
1197:   "location": "${location}",
1198:   "url": "https://...",
1199:   "source": "indeed",
1200:   "summary": "Brief description",
1201:   "postedDate": "2025-10-24",
1202:   "salary": "$50,000-$70,000" or null,
1203:   "skillMatchPercent": 75,
1204:   "skills": ["skill1", "skill2"],
1205:   "workType": "remote" or "hybrid" or "onsite",
1206:   "experienceLevel": "mid"
1207: }]
1208: 
1209: **CRITICAL**: Return the JSON array directly. Do NOT wrap in markdown. Return AT LEAST 25 jobs.`
1210: 
1211:         const res = await client.makeRequest(SYSTEM, prompt, { 
1212:           temperature: 0.2, // Slightly higher for more variety
1213:           maxTokens: 20000, // Increased to allow more jobs
1214:           model: 'sonar' // Use faster model for job search
1215:         })
1216:         if (!res.content?.trim()) throw new Error('Empty job analysis')
1217:         
1218:         console.log('[JOB_SEARCH_V2] Perplexity response received:', {
1219:           contentLength: res.content.length,
1220:           preview: res.content.slice(0, 500)
1221:         })
1222:         
1223:         return res
1224:       })
1225: 
1226:       console.log('[JOB_SEARCH_V2] Parsing response...')
1227:       let parsed: JobListing[] = []
1228:       
1229:       try {
1230:         let rawContent = out.content.trim()
1231:         console.log('[JOB_SEARCH_V2] Raw content preview:', rawContent.slice(0, 200))
1232:         
1233:         // CRITICAL FIX: Strip markdown code blocks
1234:         rawContent = rawContent.replace(/^```json\s*/i, '').replace(/```\s*$/i, '')
1235:         
1236:         // Try to extract JSON array if wrapped in object
1237:         const jsonMatch = rawContent.match(/\[[\s\S]*\]/)
1238:         if (jsonMatch) {
1239:           rawContent = jsonMatch[0]
1240:         }
1241:         
1242:         parsed = JSON.parse(rawContent) as JobListing[]
1243:         
1244:         console.log('[JOB_SEARCH_V2] Parsed jobs:', {
1245:           isArray: Array.isArray(parsed),
1246:           count: Array.isArray(parsed) ? parsed.length : 0,
1247:           firstJob: parsed[0] ? { title: parsed[0].title, company: parsed[0].company } : null
1248:         })
1249:       } catch (parseError) {
1250:         console.error('[JOB_SEARCH_V2] JSON parse error:', {
1251:           error: (parseError as Error).message,
1252:           contentPreview: out.content.slice(0, 500)
1253:         })
1254:         // Return empty array on parse error
1255:         parsed = []
1256:       }
1257:       
1258:       parsed = Array.isArray(parsed) ? parsed.slice(0, options.maxResults || 25) : []
1259:       
1260:       if (parsed.length === 0) {
1261:         console.warn('[JOB_SEARCH_V2] ⚠️ WARNING: Perplexity returned 0 jobs. This might indicate:')
1262:         console.warn('  1. No jobs found for this search')
1263:         console.warn('  2. Perplexity did not perform web search')
1264:         console.warn('  3. Response format is incorrect')
1265:         console.warn('  Content received:', out.content.slice(0, 1000))
1266:       }
1267:       
1268:       // CRITICAL FIX: Enrich jobs with short descriptions by scraping URLs
1269:       const enriched = await Promise.all(
1270:         parsed.map(async (job) => {
1271:           if (job.summary && job.summary.length < 150 && job.url) {
1272:             if (process.env.PPX_DEBUG === 'true') {
1273:               console.log(`[ENRICH] Scraping ${job.url} for full description...`)
1274:             }
1275:             const fullDescription = await this.scrapeJobURL(job.url)
1276:             if (fullDescription) {
1277:               return { ...job, summary: fullDescription }
1278:             }
1279:           }
1280:           return job
1281:         })
1282:       )
1283:       
1284:       // CRITICAL FIX: Validate job listings after enrichment
1285:       parsed = this.validateJobListings(enriched, options.maxResults || 25)
1286:       
1287:       // Enhance and normalize
1288:       parsed = parsed.map(j => ({
1289:         ...j,
1290:         skills: normalizeSkills(j.skills || []),
1291:         skillMatchPercent: Math.max(0, Math.min(100, j.skillMatchPercent || 0)),
1292:         workType: j.workType || 'onsite',
1293:         experienceLevel: j.experienceLevel || 'mid',
1294:         source: j.source || (typeof j.url === 'string' ? (new URL(j.url)).hostname.replace(/^www\./,'') : undefined),
1295:         benefits: j.benefits || [],
1296:         requirements: j.requirements || [],
1297:         metadata: {
1298:           searchedBoards: targetBoards.length,
1299:           isCanadianSearch: isCanadian,
1300:           extractedAt: new Date().toISOString()
1301:         }
1302:       }))
1303: 
1304:       // Sort by match quality, then recency
1305:       parsed.sort((a,b)=>{
1306:         if (Math.abs(a.skillMatchPercent - b.skillMatchPercent) > 5) {
1307:           return b.skillMatchPercent - a.skillMatchPercent
1308:         }
1309:         return new Date(b.postedDate).getTime() - new Date(a.postedDate).getTime()
1310:       })
1311: 
1312:       setCache(key, parsed)
1313:       return { 
1314:         success: true, 
1315:         data: parsed,
1316:         metadata: { 
1317:           requestId, 
1318:           timestamp: started, 
1319:           duration: Date.now() - started,
1320:           boardsSearched: targetBoards.length,
1321:           resultsCount: parsed.length
1322:         }, 
1323:         cached: false 
1324:       }
1325:     } catch (e) {
1326:       console.error('[JOB_SEARCH_ERROR] Job search failed:', {
1327:         error: (e as Error).message,
1328:         stack: (e as Error).stack,
1329:         location,
1330:         roleHint: options.roleHint,
1331:         boards: targetBoards.slice(0, 5)
1332:       })
1333:       
1334:       return { 
1335:         success: false, 
1336:         data: [], 
1337:         metadata: { 
1338:           requestId, 
1339:           timestamp: started, 
1340:           duration: Date.now() - started, 
1341:           error: (e as Error).message 
1342:         }, 
1343:         cached: false 
1344:       }
1345:     }
1346:   }
1347: 
1348:   // V2: Enhanced hiring contacts with email enrichment and discovery
1349:   static async hiringContactsV2(companyName: string): Promise<EnhancedResponse<HiringContact[]>> {
1350:     const requestId = generateRequestId()
1351:     const started = Date.now()
1352:     const key = makeKey('ppx:contacts:v2', { companyName })
1353:     const cached = getCache(key) as HiringContact[] | undefined
1354:     if (cached) return { success: true, data: cached, metadata: { requestId, timestamp: started, duration: Date.now() - started }, cached: true }
1355:     try {
1356:       const out = await withRetry(async () => {
1357:         const client = createClient()
1358:         
1359:         // PERPLEXITY AUDIT FIX: Use optimal configuration
1360:         const { getPerplexityConfig } = await import('./config/perplexity-configs')
1361:         const config = getPerplexityConfig('hiringContacts')
1362:         
1363:         // ULTRA-AGGRESSIVE: Multi-platform exhaustive contact scraping
1364:         const prompt = `Find ALL public hiring contacts for ${companyName} using exhaustive web and social media research.
1365: 
1366: MANDATORY SEARCH LOCATIONS (check ALL of these):
1367: 
1368: 🌐 OFFICIAL WEBSITE (VISIT AND SCRAPE):
1369: 1. **VISIT** ${companyName} official website /contact page - EXTRACT all emails
1370: 2. **VISIT** ${companyName} official website /careers page - EXTRACT contact info
1371: 3. **VISIT** ${companyName} official website /about page - EXTRACT team emails
1372: 4. **VISIT** ${companyName} official website /team page - EXTRACT individual emails
1373: 5. **VISIT** Website footer - EXTRACT contact emails
1374: 6. Look for: careers@, hr@, jobs@, recruiting@, talent@, info@, contact@, hello@
1375: 
1376: 🔍 GOOGLE SEARCHES (FOLLOW TOP 3 RESULTS):
1377: - "${companyName} HR email" - **VISIT top results and EXTRACT emails**
1378: - "${companyName} careers contact" - **VISIT and EXTRACT**
1379: - "${companyName} recruiter email" - **VISIT and EXTRACT**
1380: - "${companyName} talent acquisition contact" - **VISIT and EXTRACT**
1381: - "${companyName} hiring manager" - **VISIT and EXTRACT**
1382: 
1383: 🔗 LINKEDIN (VISIT PROFILES):
1384: - Search: site:linkedin.com/in/ "${companyName}" recruiter
1385: - Search: site:linkedin.com/in/ "${companyName}" HR
1386: - Search: site:linkedin.com/in/ "${companyName}" talent acquisition
1387: - **VISIT** Company LinkedIn page: linkedin.com/company/${companyName.toLowerCase().replace(/\s+/g, '-')}
1388: - **VISIT** individual LinkedIn profiles of HR employees
1389: - Extract REAL names, titles, and profile URLs
1390: 
1391: 🐦 TWITTER/X (VISIT PAGES):
1392: - Search: site:twitter.com "${companyName}" careers
1393: - **VISIT** Company Twitter bio for contact info
1394: 
1395: 📘 FACEBOOK (VISIT PAGES):
1396: - Search: site:facebook.com "${companyName}" jobs
1397: - **VISIT** Company Facebook page About section
1398: 
1399: 📷 INSTAGRAM (VISIT BIO):
1400: - **VISIT** Company Instagram bio for contact email
1401: 
1402: 💼 JOB BOARDS (VISIT POSTINGS):
1403: - Search: site:indeed.com "${companyName}" contact
1404: - Search: site:glassdoor.com "${companyName}" contact
1405: - **VISIT** Job postings and EXTRACT direct contact info
1406: 
1407: 📧 CONTACTOUT / HUNTER.IO:
1408: - Search: site:contactout.com "${companyName}"
1409: - **VISIT** any ContactOut pages and EXTRACT verified emails
1410: 
1411: EXTRACT ONLY VERIFIED PUBLIC INFORMATION:
1412: ✅ Email addresses you SEE on websites (careers@, hr@, jobs@, recruiting@, talent@)
1413: ✅ Direct employee emails found on LinkedIn/website (firstname.lastname@domain)
1414: ✅ Phone numbers for HR/recruiting
1415: ✅ LinkedIn profile URLs of recruiters/HR with REAL names
1416: ✅ Company careers page URL
1417: 
1418: STRICT RULES:
1419: 🚫 Do NOT infer or generate any email addresses
1420: 🚫 Do NOT guess email patterns
1421: 🚫 ONLY return information you can SEE on public pages
1422: 🚫 Do NOT include personal emails (gmail, yahoo, hotmail)
1423: 🚫 Do NOT make up names or contacts
1424: 
1425: RETURN FORMAT (JSON array):
1426: [
1427:   {
1428:     "name": "Sarah Johnson",
1429:     "title": "Senior Recruiter",
1430:     "email": "sarah.johnson@company.com",
1431:     "phone": "+1-888-742-6417",
1432:     "linkedinUrl": "https://linkedin.com/in/sarahjohnson",
1433:     "source": "LinkedIn profile",
1434:     "platform": "LinkedIn"
1435:   },
1436:   {
1437:     "name": "HR Department",
1438:     "title": "Human Resources",
1439:     "email": "careers@company.com",
1440:     "source": "Company website",
1441:     "platform": "Website"
1442:   }
1443: ]
1444: 
1445: IF ZERO VERIFIED CONTACTS FOUND, return empty array: []
1446: 
1447: IMPORTANT: Search ALL platforms listed above. Return ONLY verified contacts you actually found.`
1448: 
1449:         // PERPLEXITY AUDIT FIX: Use optimal token limits + sonar-pro for research
1450:         return client.makeRequest(SYSTEM, prompt, { 
1451:           temperature: config.temperature, 
1452:           maxTokens: config.maxTokens,
1453:           model: 'sonar-pro' // Use research model for multi-source search
1454:         })
1455:       })
1456:       
1457:       // CRITICAL DEBUG: Log raw Perplexity output (Perplexity recommendation)
1458:       if (process.env.PPX_DEBUG === 'true') {
1459:         console.log('[PERPLEXITY RAW]', {
1460:           method: 'hiringContactsV2',
1461:           company: companyName,
1462:           contentLength: out.content.length,
1463:           contentPreview: out.content.slice(0, 500)
1464:         })
1465:       }
1466:       
1467:       // Parse and clean Perplexity response - ENTERPRISE-GRADE JSON EXTRACTION
1468:       let cleanedContent = out.content.trim()
1469:       
1470:       // Step 1: Remove markdown code blocks
1471:       cleanedContent = cleanedContent.replace(/^```(?:json)?\s*/gm, '').replace(/```\s*$/gm, '')
1472:       
1473:       // Step 2: Extract JSON array from any surrounding text
1474:       const jsonMatch = cleanedContent.match(/\[[\s\S]*?\]/);
1475:       if (jsonMatch) {
1476:         cleanedContent = jsonMatch[0]
1477:       } else {
1478:         // Step 3: If no array found, check for explanatory text with JSON after it
1479:         const afterTextMatch = cleanedContent.match(/(?:Here|I found|Below|Results?)[\s\S]*?(\[[\s\S]*?\])/i);
1480:         if (afterTextMatch) {
1481:           cleanedContent = afterTextMatch[1]
1482:         } else {
1483:           console.warn('[HIRING_CONTACTS] No JSON array found in response, returning empty array')
1484:           return { success: false, data: [], metadata: { requestId, timestamp: started, duration: Date.now() - started, error: 'No JSON array in response' }, cached: false }
1485:         }
1486:       }
1487:       
1488:       // PERPLEXITY AUDIT FIX: Use enterprise-grade JSON extraction
1489:       const { extractEnterpriseJSON } = await import('./utils/enterprise-json-extractor')
1490:       const extractionResult = extractEnterpriseJSON(cleanedContent)
1491:       
1492:       if (!extractionResult.success) {
1493:         console.error('[HIRING_CONTACTS] Enterprise JSON extraction failed:', extractionResult.error)
1494:         console.error('[HIRING_CONTACTS] Attempted cleanups:', extractionResult.attemptedCleanups)
1495:         console.error('[HIRING_CONTACTS] Raw content preview:', out.content.slice(0, 500))
1496:         return { 
1497:           success: false, 
1498:           data: [], 
1499:           metadata: { 
1500:             requestId, 
1501:             timestamp: started, 
1502:             duration: Date.now() - started, 
1503:             error: `Enterprise JSON extraction failed: ${extractionResult.error}`,
1504:             attemptedCleanups: extractionResult.attemptedCleanups
1505:           }, 
1506:           cached: false 
1507:         }
1508:       }
1509:       
1510:       // CRITICAL FIX: ALWAYS ensure we have an array (never undefined/null)
1511:       let parsed: HiringContact[] = []
1512:       
1513:       if (Array.isArray(extractionResult.data)) {
1514:         parsed = extractionResult.data.slice(0, 8)
1515:       } else if (extractionResult.data && typeof extractionResult.data === 'object') {
1516:         // Handle case where AI returns single object instead of array
1517:         parsed = [extractionResult.data]
1518:       }
1519:       
1520:       // Enterprise extraction succeeded
1521:       
1522:       // CRITICAL: Validate and filter contacts - reject fake/personal emails
1523:       const personalDomains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'aol.com', 'icloud.com', 'protonmail.com']
1524:       parsed = parsed.filter(contact => {
1525:         // Must have at least one contact method
1526:         if (!contact.email && !contact.phone && !contact.linkedinUrl) {
1527:           console.warn(`[HIRING_CONTACTS] Rejected contact with no contact method: ${contact.name}`)
1528:           return false
1529:         }
1530:         
1531:         // Reject inferred/template emails
1532:         if (contact.email?.includes('[') || 
1533:             contact.email?.includes('example.') || 
1534:             contact.email?.includes('domain.') ||
1535:             contact.email?.includes('VISIT_WEBSITE')) {
1536:           console.warn(`[HIRING_CONTACTS] Rejected template email: ${contact.email}`)
1537:           return false
1538:         }
1539:         
1540:         // Reject personal emails
1541:         if (contact.email && personalDomains.some(d => contact.email!.toLowerCase().endsWith(d))) {
1542:           console.warn(`[HIRING_CONTACTS] Rejected personal email: ${contact.email}`)
1543:           return false
1544:         }
1545:         
1546:         // Reject LinkedIn profiles without proper URL
1547:         if (contact.linkedinUrl && !contact.linkedinUrl.includes('linkedin.com/')) {
1548:           console.warn(`[HIRING_CONTACTS] Rejected invalid LinkedIn URL: ${contact.linkedinUrl}`)
1549:           return false
1550:         }
1551:         
1552:         return true
1553:       })
1554:       
1555:       // Validation complete
1556:       
1557:       // Enhance each contact with metadata
1558:       parsed = parsed.map(c => {
1559:         const domain = `${companyName.toLowerCase().replace(/\s+/g,'').replace(/[^a-z0-9]/g,'')}.com`
1560:         const inferred = c.name ? inferEmails(c.name, domain) : []
1561:         
1562:         return { 
1563:           ...c, 
1564:           confidence: Math.max(0, Math.min(1, c.confidence || 0.5)), 
1565:           alternativeEmails: c.alternativeEmails || inferred, 
1566:           emailType: (c.email ? c.emailType : 'pattern') as 'public'|'inferred'|'pattern',
1567:           discoveryMethod: c.discoveryMethod || (c.email ? 'Direct lookup' : 'Pattern inference')
1568:         }
1569:       })
1570:       
1571:       // Final result prepared
1572:       
1573:       // CRITICAL FIX: Validate contacts before returning
1574:       const validated = this.validateHiringContacts(parsed)
1575:       
1576:       // CRITICAL FIX: NO INFERRED EMAILS - return empty if none verified
1577:       // User should visit company website or use LinkedIn instead of contacting fake emails
1578:       const finalContacts = validated
1579:       
1580:       // Cache the result (even if empty)
1581:       setCache(key, finalContacts)
1582:       
1583:       return { 
1584:         success: validated.length > 0, 
1585:         data: finalContacts, 
1586:         metadata: { 
1587:           requestId, 
1588:           timestamp: started, 
1589:           duration: Date.now() - started,
1590:           contactsFound: finalContacts.length,
1591:           withEmails: finalContacts.filter(c => c.email).length,
1592:           error: validated.length === 0 
1593:             ? `No verified hiring contacts found for ${companyName}. Visit company website or use LinkedIn InMail.` 
1594:             : undefined
1595:         }, 
1596:         cached: false 
1597:       }
1598:     } catch (e) {
1599:       console.error('[HIRING_CONTACTS] Error:', e)
1600:       return { success: false, data: [], metadata: { requestId, timestamp: started, duration: Date.now() - started, error: (e as Error).message }, cached: false }
1601:     }
1602:   }
1603: 
1604:   // ... (rest of the code remains the same)
1605: 
1606:   // Extract normalized keywords and location from resume (STRICT JSON)
1607:   static async extractResumeSignals(
1608:     resumeText: string,
1609:     maxKeywords: number = 50
1610:   ): Promise<{ keywords: string[]; location?: string; locations?: string[]; personalInfo?: { name?: string; email?: string; phone?: string } }> {
1611:     const key = makeKey('ppx:resume:signals:v3', { t: resumeText.slice(0, 3000), maxKeywords })
1612:     const cached = getCache(key) as { keywords: string[]; location?: string; locations?: string[] } | undefined
1613:     if (cached) return cached
1614: 
1615:     try {
1616:       const client = createClient()
1617:       
1618:       // ENTERPRISE PROMPT - WEIGHTED KEYWORD EXTRACTION WITH TIME-BASED RELEVANCE
1619:       const prompt = `CRITICAL TASK: Extract weighted keywords, location, and personal info from this resume.
1620: 
1621: RESUME TEXT:
1622: ${resumeText}
1623: 
1624: KEYWORD EXTRACTION WITH TIME-BASED WEIGHTING:
1625: 1. Extract ALL relevant skills, technologies, and competencies (up to 50)
1626: 2. WEIGHT keywords based on:
1627:    - Years of experience using that skill (more years = higher priority)
1628:    - Recency (recent roles = higher weight than old roles or education)
1629:    - Frequency of mention across work experience
1630: 3. ORDER keywords by weighted relevance (most important first)
1631: 4. Skills from work experience should be weighted HIGHER than skills from education only
1632: 5. Calculate weight as: (years using skill / total career years) * recency_multiplier
1633: 
1634: LOCATION EXTRACTION RULES:
1635: 1. Find ANY city/province/state mentioned (email header, address, work experience)
1636: 2. Look for patterns like "City, PROVINCE" or "City, STATE"
1637: 3. Check contact information section first
1638: 4. If multiple locations, use the FIRST one found (likely primary)
1639: 5. Return EXACTLY as found (e.g., "Edmonton, AB" not "Edmonton, Alberta")
1640: 
1641: PERSONAL INFORMATION EXTRACTION:
1642: 1. Extract full name (usually at the top of resume)
1643: 2. Extract email address (look for @ symbol)
1644: 3. Extract phone number (look for phone patterns)
1645: 4. If not found, return null for that field
1646: 
1647: RETURN STRICT JSON (no explanation, no markdown):
1648: {
1649:   "keywords": ["Most Important Skill", "Second Most Important", "...", "50th skill"],
1650:   "location": "City, PROVINCE",
1651:   "personalInfo": {
1652:     "name": "Full Name",
1653:     "email": "email@example.com",
1654:     "phone": "555-1234"
1655:   }
1656: }
1657: 
1658: IMPORTANT: 
1659: - Order keywords by weighted importance (years of experience + recency)
1660: - If NO location found after thorough search, return "location": null (do NOT guess or default)
1661: - If personal info not found, return null for those fields`
1662: 
1663:       // Processing resume signals
1664: 
1665:       const response = await client.makeRequest(
1666:         'You extract keywords and locations from resumes. Return only JSON.',
1667:         prompt,
1668:         { temperature: 0.2, maxTokens: 2000, model: 'sonar-pro' } // CRITICAL FIX: Increased from 800 to handle 50 keywords
1669:       )
1670: 
1671:       if (process.env.PPX_DEBUG === 'true') {
1672:         console.log('[SIGNALS] Raw response:', response.content?.slice(0, 400))
1673:       }
1674: 
1675:       // ENTERPRISE FIX: Strip markdown code blocks that Perplexity sometimes adds
1676:       let cleanedContent = response.content.trim()
1677:       
1678:       // Remove markdown code fences (```json ... ``` or ``` ... ```)
1679:       cleanedContent = cleanedContent.replace(/^```(?:json)?\s*/gm, '').replace(/```\s*$/gm, '')
1680:       
1681:       // Extract JSON array/object if wrapped in explanatory text
1682:       const jsonMatch = cleanedContent.match(/(\{[\s\S]*\}|\[[\s\S]*\])/);
1683:       if (jsonMatch) {
1684:         cleanedContent = jsonMatch[0]
1685:       }
1686: 
1687:       const parsed = JSON.parse(cleanedContent) as { keywords: string[]; location?: string; locations?: string[]; personalInfo?: { name?: string; email?: string; phone?: string } }
1688:       
1689:       if (process.env.PPX_DEBUG === 'true') {
1690:         console.log('[SIGNALS] Parsed:', {
1691:           keywordCount: parsed.keywords?.length,
1692:           location: parsed.location,
1693:           hasLocations: !!parsed.locations,
1694:           personalInfo: parsed.personalInfo
1695:         })
1696:       }
1697: 
1698:       setCache(key, parsed)
1699:       return parsed
1700:     } catch (error) {
1701:       console.error('═══════════════════════════════════════════════════════')
1702:       console.error('[EXTRACT SIGNALS] ❌ PERPLEXITY EXTRACTION FAILED')
1703:       console.error('═══════════════════════════════════════════════════════')
1704:       console.error('[EXTRACT SIGNALS] Error:', (error as Error).message)
1705:       console.error('[EXTRACT SIGNALS] Resume text length:', resumeText.length, 'chars')
1706:       console.error('[EXTRACT SIGNALS] First 300 chars of resume:')
1707:       console.error(resumeText.substring(0, 300))
1708:       console.error('═══════════════════════════════════════════════════════')
1709:       
1710:       // CRITICAL: Don't return fake data - throw error so upload route can handle it
1711:       throw new Error(`Failed to extract resume signals: ${(error as Error).message}. Resume may be missing contact information or is corrupted.`)
1712:     }
1713:   }
1714: 
1715:   // ... (rest of the code remains the same)
1716: 
1717:   /**
1718:    * ONE-SHOT COMPREHENSIVE RESEARCH
1719:    * Replaces multiple API calls with a single comprehensive prompt
1720:    * Returns: Job Analysis + Company Research + Hiring Contacts + News + Reviews
1721:    * 
1722:    * @param params - Job and resume details
1723:    * @returns Complete research data for all Career Finder pages
1724:    */
1725:   static async comprehensiveJobResearch(params: {
1726:     jobTitle: string
1727:     company: string
1728:     jobDescription: string
1729:     location?: string
1730:     resumeText: string
1731:     resumeSkills?: string[]
1732:   }): Promise<EnhancedResponse<ComprehensiveJobResearchData | null>> {
1733:     const requestId = generateRequestId()
1734:     const started = Date.now()
1735: 
1736:     try {
1737:       const client = createClient()
1738: 
1739:       const prompt = `COMPREHENSIVE JOB APPLICATION RESEARCH
1740: 
1741: - Position: ${params.jobTitle}
1742: - Company: ${params.company}
1743: - Location: ${params.location || 'Not specified'}
1744: - Description: ${params.jobDescription.slice(0, 1000)}
1745: 
1746: CANDIDATE SKILLS: ${params.resumeSkills ? params.resumeSkills.slice(0, 20).join(', ') : 'Extract from resume below'}
1747: 
1748: RESUME TEXT (First 2000 chars):
1749: ${params.resumeText.slice(0, 2000)}
1750: 
1751: ---
1752: 
1753: YOUR MISSION: Conduct a comprehensive research report covering ALL of the following sections. This is a ONE-TIME research call, so be thorough and detailed. Include clickable URLs wherever possible.
1754: 
1755: OUTPUT FORMAT (Valid JSON ONLY):
1756: \`\`\`json
1757: {
1758:   "jobAnalysis": {
1759:     "matchScore": 85,
1760:     "matchingSkills": ["skill1", "skill2"],
1761:     "missingSkills": ["skill3", "skill4"],
1762:     "skillsToHighlight": ["top skill to emphasize"],
1763:     "recommendations": ["specific action 1", "specific action 2"],
1764:     "estimatedFit": "Excellent|Good|Moderate|Poor"
1765:   },
1766:   "companyIntel": {
1767:     "company": "${params.company}",
1768:     "description": "detailed company overview (minimum 200 chars)",
1769:     "size": "employee count or range",
1770:     "revenue": "annual revenue if public",
1771:     "industry": "primary industry",
1772:     "founded": "year",
1773:     "headquarters": "city, state/country",
1774:     "website": "https://company.com",
1775:     "marketPosition": "market leader|challenger|niche player",
1776:     "generalEmail": "ONLY include if found on company website or LinkedIn - DO NOT GUESS. Leave empty if not found.",
1777:     "careersPage": "https://company.com/careers"
1778:   },
1779:   "companyPsychology": {
1780:     "culture": "detailed culture description based on reviews and public info",
1781:     "values": ["value1", "value2", "value3"],
1782:     "managementStyle": "hierarchical|flat|hybrid",
1783:     "workEnvironment": "remote-friendly|hybrid|office-centric"
1784:   },
1785:   "hiringContacts": [
1786:     {
1787:       "name": "Real Person Name - ONLY if found on LinkedIn or company website",
1788:       "title": "Talent Acquisition Manager",
1789:       "department": "Human Resources",
1790:       "email": "ONLY include if verified from LinkedIn or company website - DO NOT GUESS. Leave empty if not found.",
1791:       "linkedinUrl": "https://linkedin.com/in/person - ONLY if found",
1792:       "authority": "decision maker",
1793:       "confidence": 0.9
1794:     }
1795:   ],
1796:   "CRITICAL_INSTRUCTION": "DO NOT GUESS EMAILS. Only include emails that are explicitly found on the company website, LinkedIn profiles, or other verified sources. If no email is found, leave the field empty or set to null. NEVER construct emails like info@company.com or careers@company.com unless they are explicitly listed on official sources.",
1797:   "marketIntelligence": {
1798:     "competitivePosition": "how company compares to competitors",
1799:     "industryTrends": "relevant industry trends affecting this role",
1800:     "financialStability": "financial health assessment",
1801:     "recentPerformance": "last 12 months highlights"
1802:   },
1803:   "news": [
1804:     {
1805:       "title": "Recent news headline",
1806:       "summary": "Brief summary of the article",
1807:       "url": "https://newsource.com/article",
1808:       "date": "2024-01-15",
1809:       "source": "TechCrunch",
1810:       "impact": "positive|neutral|negative for employment"
1811:     }
1812:   ],
1813:   "reviews": [
1814:     {
1815:       "platform": "Glassdoor",
1816:       "rating": 4.2,
1817:       "summary": "Overall employee sentiment summary",
1818:       "url": "https://glassdoor.com/company-reviews",
1819:       "pros": ["pro1", "pro2"],
1820:       "cons": ["con1", "con2"]
1821:     }
1822:   ],
1823:   "compensation": {
1824:     "salaryRange": "$XX,000 - $YY,000 for ${params.jobTitle}",
1825:     "benefits": "typical benefits package"
1826:   },
1827:   "strategicRecommendations": {
1828:     "applicationStrategy": "specific advice on how to apply",
1829:     "contactStrategy": "who to contact first and how",
1830:     "interviewPrep": ["prepare for X", "research Y", "practice Z"]
1831:   },
1832:   "sources": ["https://source1.com", "https://source2.com", "https://source3.com"],
1833:   "confidenceLevel": 0.85
1834: }
1835: \`\`\`
1836: 
1837: CRITICAL REQUIREMENTS:
1838: 1. Job Analysis: Compare resume skills to job requirements, calculate match score
1839: 2. Company Intel: Search company website, LinkedIn, Crunchbase, Wikipedia for REAL data
1840:    - MUST find general company email (careers@, hr@, jobs@, info@, contact@)
1841:    - Check company website contact page, footer, careers page
1842:    - If no email found, generate likely addresses based on domain
1843: 3. Hiring Contacts: **CRITICAL - MUST FIND CONTACTS**
1844:    - Search LinkedIn, Twitter, Facebook, Instagram, company website
1845:    - Minimum 2-3 REAL hiring contacts if company has 10+ employees
1846:    - Include verified LinkedIn URLs and emails where possible
1847:    - DO NOT return fake/placeholder names
1848:    - **MANDATORY FALLBACK**: If no hiring contacts found, extract company general inbox:
1849:      * Check: careers@, hr@, jobs@, info@, hello@, contact@, support@
1850:      * Return as: {"name":"General Inbox","title":"Company Contact","email":"found@company.com"}
1851:    - NEVER return empty contacts array - app is useless without contact info
1852: 4. News: Find 2-5 recent news articles about the company with clickable URLs
1853: 5. Reviews: Search Glassdoor, Indeed, Comparably for employee reviews with clickable URLs
1854: 6. Market Intelligence: Research industry trends, competitive landscape
1855: 7. Strategic Recommendations: Provide actionable, company-specific advice
1856: 
1857: IMPORTANT:
1858: - Return ONLY valid JSON (no markdown, no explanations)
1859: - All URLs must be real and clickable
1860: - If data not found after searching, use "Not available" but ALWAYS try multiple sources first
1861: - Focus on actionable intelligence, not generic advice`
1862: 
1863:       const out = await withRetry(async () => {
1864:         return client.makeRequest(
1865:           'You are an elite corporate intelligence analyst providing comprehensive job application research. Return detailed JSON with all requested fields.',
1866:           prompt,
1867:           {
1868:             temperature: 0.2,
1869:             maxTokens: 8000,
1870:             model: 'sonar-pro'
1871:           }
1872:         )
1873:       })
1874: 
1875:       if (process.env.PPX_DEBUG === 'true') {
1876:         console.log('[COMPREHENSIVE_RESEARCH] Raw response length:', out.content.length)
1877:       }
1878: 
1879:       // Parse response
1880:       let cleanedContent = out.content.trim()
1881:       
1882:       // Remove markdown code blocks
1883:       cleanedContent = cleanedContent.replace(/^```(?:json)?\s*/gm, '').replace(/```\s*$/gm, '')
1884:       
1885:       // Extract JSON object
1886:       const jsonMatch = cleanedContent.match(/\{[\s\S]*\}/)
1887:       if (jsonMatch) {
1888:         cleanedContent = jsonMatch[0]
1889:       }
1890: 
1891:       const parsed = JSON.parse(cleanedContent) as Partial<ComprehensiveJobResearchData>
1892: 
1893:       // Construct with fallbacks
1894:       const data: ComprehensiveJobResearchData = {
1895:         jobAnalysis: {
1896:           matchScore: parsed.jobAnalysis?.matchScore ?? 0,
1897:           matchingSkills: parsed.jobAnalysis?.matchingSkills ?? [],
1898:           missingSkills: parsed.jobAnalysis?.missingSkills ?? [],
1899:           skillsToHighlight: parsed.jobAnalysis?.skillsToHighlight ?? [],
1900:           recommendations: parsed.jobAnalysis?.recommendations ?? [],
1901:           estimatedFit: parsed.jobAnalysis?.estimatedFit ?? 'Unknown'
1902:         },
1903:         companyIntel: {
1904:           company: parsed.companyIntel?.company ?? params.company,
1905:           description: parsed.companyIntel?.description ?? 'No description available',
1906:           size: parsed.companyIntel?.size ?? 'Unknown',
1907:           revenue: parsed.companyIntel?.revenue,
1908:           industry: parsed.companyIntel?.industry ?? 'Unknown',
1909:           founded: parsed.companyIntel?.founded,
1910:           headquarters: parsed.companyIntel?.headquarters,
1911:           website: parsed.companyIntel?.website,
1912:           marketPosition: parsed.companyIntel?.marketPosition
1913:         },
1914:         companyPsychology: {
1915:           culture: parsed.companyPsychology?.culture ?? 'No information available',
1916:           values: parsed.companyPsychology?.values ?? [],
1917:           managementStyle: parsed.companyPsychology?.managementStyle,
1918:           workEnvironment: parsed.companyPsychology?.workEnvironment
1919:         },
1920:         hiringContacts: Array.isArray(parsed.hiringContacts)
1921:           ? parsed.hiringContacts
1922:               .map(contact => ({
1923:                 name: contact.name,
1924:                 title: contact.title,
1925:                 department: contact.department,
1926:                 email: contact.email,
1927:                 linkedinUrl: contact.linkedinUrl,
1928:                 authority: contact.authority ?? 'manager',
1929:                 confidence: contact.confidence ?? 0,
1930:                 contactMethod: contact.contactMethod
1931:               }))
1932:               .filter(contact => !!contact?.name && contact?.title)
1933:           : [],
1934:         marketIntelligence: {
1935:           competitivePosition: parsed.marketIntelligence?.competitivePosition,
1936:           industryTrends: parsed.marketIntelligence?.industryTrends,
1937:           financialStability: parsed.marketIntelligence?.financialStability,
1938:           recentPerformance: parsed.marketIntelligence?.recentPerformance
1939:         },
1940:         news: Array.isArray(parsed.news)
1941:           ? parsed.news
1942:               .map(item => (item?.title && item?.summary && item?.url
1943:                 ? {
1944:                     title: item.title,
1945:                     summary: item.summary,
1946:                     url: item.url,
1947:                     date: item.date,
1948:                     source: item.source,
1949:                     impact: item.impact
1950:                   }
1951:                 : undefined))
1952:               .filter((item): item is NonNullable<typeof item> => !!item)
1953:           : [],
1954:         reviews: Array.isArray(parsed.reviews)
1955:           ? parsed.reviews
1956:               .map(item => (item?.platform && item?.summary && item?.url
1957:                 ? {
1958:                     platform: item.platform,
1959:                     rating: item.rating,
1960:                     summary: item.summary,
1961:                     url: item.url,
1962:                     pros: item.pros,
1963:                     cons: item.cons
1964:                   }
1965:                 : undefined))
1966:               .filter((item): item is NonNullable<typeof item> => !!item)
1967:           : [],
1968:         compensation: parsed.compensation ?? {},
1969:         strategicRecommendations: {
1970:           applicationStrategy: parsed.strategicRecommendations?.applicationStrategy ?? 'Apply through company website',
1971:           contactStrategy: parsed.strategicRecommendations?.contactStrategy ?? 'Reach out to HR via LinkedIn',
1972:           interviewPrep: parsed.strategicRecommendations?.interviewPrep ?? []
1973:         },
1974:         sources: Array.isArray(parsed.sources)
1975:           ? parsed.sources.filter((source): source is string => typeof source === 'string')
1976:           : [],
1977:         confidenceLevel: parsed.confidenceLevel ?? 0.5
1978:       }
1979: 
1980:       if (process.env.PPX_DEBUG === 'true') {
1981:         console.log('[COMPREHENSIVE_RESEARCH] Complete -', 
1982:           'matchScore:', data.jobAnalysis.matchScore, 
1983:           'contacts:', data.hiringContacts.length, 
1984:           'news:', data.news.length, 
1985:           'reviews:', data.reviews.length, 
1986:           'confidence:', data.confidenceLevel
1987:         )
1988:       }
1989: 
1990:       return {
1991:         success: true,
1992:         data,
1993:         metadata: { requestId, timestamp: started, duration: Date.now() - started },
1994:         cached: false
1995:       }
1996:     } catch (error) {
1997:       console.error('[COMPREHENSIVE_RESEARCH] Error:', error)
1998:       return {
1999:         success: false,
2000:         data: null,
2001:         metadata: { 
2002:           requestId, 
2003:           timestamp: started, 
2004:           duration: Date.now() - started,
2005:           error: (error as Error).message 
2006:         },
2007:         cached: false
2008:       }
2009:     }
2010:   }
2011: 
2012:   // Resume Optimizer: Generate tailored resume variants
2013:   static async generateResumeVariants(params: {
2014:     resumeText: string
2015:     jobTitle: string
2016:     jobRequirements: string[]
2017:     companyInsights: { culture: string; values: string[]; industry: string }
2018:     template?: string
2019:   }): Promise<EnhancedResponse<{
2020:     variantA: string
2021:     variantB: string
2022:     recommendations: string[]
2023:   }>> {
2024:     const requestId = generateRequestId()
2025:     const started = Date.now()
2026:     const cacheKey = makeKey('resume-variants', params)
2027:     
2028:     const cached = getCache(cacheKey)
2029:     if (cached) {
2030:       return {
2031:         success: true,
2032:         data: cached as { variantA: string; variantB: string; recommendations: string[] },
2033:         metadata: { requestId, timestamp: started, duration: 0 },
2034:         cached: true
2035:       }
2036:     }
2037: 
2038:     try {
2039:       const client = createClient()
2040:       const systemPrompt = 'You are a professional resume optimization expert. Return only valid JSON with properly formatted resume text.'
2041:       
2042:       // Build template-specific instructions
2043:       const templateInstructions = {
2044:         modern: 'Use a contemporary style with visual hierarchy. Emphasize innovation and forward-thinking achievements.',
2045:         professional: 'Use traditional, formal language. Focus on stability, reliability, and proven track record.',
2046:         creative: 'Use dynamic language and unique phrasing. Highlight creativity, innovation, and out-of-the-box thinking.',
2047:         tech: 'Use technical terminology and emphasize projects, technologies, and technical achievements.',
2048:         minimal: 'Use simple, direct language. Focus on facts and quantifiable results. Maximum ATS compatibility.',
2049:         executive: 'Use leadership language. Emphasize strategic impact, team leadership, and business results.'
2050:       }
2051:       
2052:       const templateStyle = templateInstructions[params.template as keyof typeof templateInstructions] || templateInstructions.modern
2053:       
2054:       const userPrompt = `Analyze this resume and create TWO tailored variants for the target role using the ${params.template} template style.
2055: 
2056: **Resume:**
2057: ${params.resumeText}
2058: 
2059: **Target Role:** ${params.jobTitle}
2060: 
2061: **Key Requirements:**
2062: ${params.jobRequirements.map((req, i) => `${i + 1}. ${req}`).join('\n')}
2063: 
2064: **Company Culture:** ${params.companyInsights.culture}
2065: **Company Values:** ${params.companyInsights.values.join(', ')}
2066: **Industry:** ${params.companyInsights.industry}
2067: 
2068: **Template Style (${params.template}):** ${templateStyle}
2069: 
2070: Generate TWO resume variants:
2071: 1. **Variant A (Achievement-Focused):** Emphasize quantifiable achievements and metrics. ${templateStyle}
2072: 2. **Variant B (Skills-Focused):** Highlight technical skills and competencies. ${templateStyle}
2073: 
2074: CRITICAL FORMATTING REQUIREMENTS:
2075: - Use proper line breaks (\\n\\n for sections, \\n for lines)
2076: - DO NOT include name, email, phone, or address in the resume body
2077: - Personal contact info will be added separately by the template
2078: - Start directly with PROFESSIONAL SUMMARY or first section
2079: - Use clear section headers (PROFESSIONAL SUMMARY, EXPERIENCE, EDUCATION, SKILLS)
2080: - Format each job entry with: Title\\nCompany | Location | Dates\\n• Achievement 1\\n• Achievement 2
2081: - Keep bullet points aligned with • symbol
2082: - Ensure proper spacing between sections
2083: - NO markdown formatting (no **, no #, no _)
2084: - Plain text only with line breaks
2085: - INCLUDE ALL job history from original resume
2086: 
2087: CRITICAL - PERSONAL INFO:
2088: - DO NOT include the person's name anywhere in the resume body
2089: - DO NOT include email address in the resume body
2090: - DO NOT include phone number in the resume body
2091: - DO NOT include physical address in the resume body
2092: - These will be added by the template header automatically
2093: - Start the resume body with the PROFESSIONAL SUMMARY section
2094: 
2095: For each variant, rewrite the resume to:
2096: - Match keywords from job requirements
2097: - Align with company culture and values
2098: - Use industry-specific terminology appropriate for ${params.template} template
2099: - Optimize for ATS (Applicant Tracking Systems)
2100: - Keep formatting clean and professional
2101: - Apply ${params.template} template style throughout
2102: - NEVER duplicate personal contact information
2103: 
2104: Also provide 3-5 strategic recommendations for improving the resume.
2105: 
2106: Return ONLY valid JSON:
2107: {
2108:   "variantA": "Full resume text WITHOUT personal info (starts with PROFESSIONAL SUMMARY)...",
2109:   "variantB": "Full resume text WITHOUT personal info (starts with PROFESSIONAL SUMMARY)...",
2110:   "recommendations": ["Recommendation 1", "Recommendation 2", ...]
2111: }`
2112: 
2113:       const response = await withRetry(
2114:         () => client.makeRequest(systemPrompt, userPrompt, { temperature: 0.2, maxTokens: 4000, model: 'sonar-pro' }),
2115:         MAX_RETRY_ATTEMPTS
2116:       )
2117: 
2118:       const parsed = parseAIResponse<{
2119:         variantA: string
2120:         variantB: string
2121:         recommendations: string[]
2122:       }>(response.content)
2123: 
2124:       const data = {
2125:         variantA: parsed.variantA || params.resumeText,
2126:         variantB: parsed.variantB || params.resumeText,
2127:         recommendations: Array.isArray(parsed.recommendations) ? parsed.recommendations : []
2128:       }
2129: 
2130:       setCache(cacheKey, data)
2131: 
2132:       return {
2133:         success: true,
2134:         data,
2135:         metadata: { requestId, timestamp: started, duration: Date.now() - started },
2136:         cached: false
2137:       }
2138:     } catch (error) {
2139:       console.error('[RESUME_VARIANTS] Error:', error)
2140:       return {
2141:         success: false,
2142:         data: {
2143:           variantA: params.resumeText,
2144:           variantB: params.resumeText,
2145:           recommendations: []
2146:         },
2147:         metadata: { 
2148:           requestId, 
2149:           timestamp: started, 
2150:           duration: Date.now() - started,
2151:           error: (error as Error).message 
2152:         },
2153:         cached: false
2154:       }
2155:     }
2156:   }
2157: 
2158:   // Cover Letter Generator: Create personalized cover letters using templates
2159:   static async generateCoverLetters(params: {
2160:     jobTitle: string
2161:     company: string
2162:     jobRequirements: string[]
2163:     resumeText: string
2164:     companyInsights: {
2165:       culture: string
2166:       values: string[]
2167:       recentNews: Array<{ title: string; summary: string }>
2168:     }
2169:     hiringManager?: { name: string; title: string }
2170:     userName?: string
2171:     templateId?: string
2172:   }): Promise<EnhancedResponse<{
2173:     variantA: string
2174:     variantB: string
2175:     personalization: string[]
2176:   }>> {
2177:     const requestId = generateRequestId()
2178:     const started = Date.now()
2179:     const cacheKey = makeKey('cover-letters', params)
2180:     
2181:     const cached = getCache(cacheKey)
2182:     if (cached) {
2183:       return {
2184:         success: true,
2185:         data: cached as { variantA: string; variantB: string; personalization: string[] },
2186:         metadata: { requestId, timestamp: started, duration: 0 },
2187:         cached: true
2188:       }
2189:     }
2190: 
2191:     try {
2192:       // CRITICAL FIX: Calculate years of experience to prevent hallucinations
2193:       const yearsExperience = calculateYearsFromResume(params.resumeText)
2194:       if (process.env.PPX_DEBUG === 'true') {
2195:         console.log('[COVER_LETTERS] Calculated experience:', yearsExperience, 'years')
2196:       }
2197: 
2198:       // Get templates - use professional and modern as defaults
2199:       const templateA = getCoverLetterTemplateById(params.templateId || 'professional')
2200:       const templateB = getCoverLetterTemplateById('modern')
2201: 
2202:       const client = createClient()
2203:       const systemPrompt = `You are an expert cover letter writer. Use the provided templates as structure guides and fill them with personalized content from the candidate's resume.
2204: 
2205: CRITICAL EXPERIENCE CONSTRAINT:
2206: - Candidate has EXACTLY ${yearsExperience} years of total work experience
2207: - DO NOT say "decades", "38 years", or any number higher than ${yearsExperience}
2208: - If ${yearsExperience} < 10, say "several years" or "${yearsExperience} years"
2209: - If ${yearsExperience} >= 10 && ${yearsExperience} < 20, say "${yearsExperience} years" or "over a decade"
2210: - If ${yearsExperience} >= 20, say "${yearsExperience} years" or "two decades"
2211: - NEVER invent or exaggerate experience duration
2212: - Use ONLY the experience data provided in the resume
2213: 
2214: Return only valid JSON.`
2215: 
2216:       const userPrompt = `Create TWO personalized cover letter variants using these templates as guides:
2217: 
2218: **TEMPLATE A (${templateA.name}):**
2219: ${templateA.template}
2220: 
2221: **TEMPLATE B (${templateB.name}):**
2222: ${templateB.template}
2223: 
2224: **Job Details:**
2225: - Job Title: ${params.jobTitle}
2226: - Company: ${params.company}
2227: - Hiring Manager: ${params.hiringManager?.name || 'Hiring Manager'}
2228: - Applicant: ${params.userName || '[Your Name]'}
2229: 
2230: **Key Requirements:**
2231: ${params.jobRequirements.map((req, i) => `${i + 1}. ${req}`).join('\n')}
2232: 
2233: **Resume Content (${yearsExperience} years experience):**
2234: ${params.resumeText.slice(0, 1500)}
2235: 
2236: **Company Research:**
2237: - Culture: ${params.companyInsights.culture}
2238: - Values: ${params.companyInsights.values.join(', ')}
2239: - Recent News: ${params.companyInsights.recentNews.map(n => n.title).join(', ')}
2240: 
2241: **Instructions:**
2242: 1. Fill in ALL placeholders in the templates with actual data
2243: 2. Replace [X years] with "${yearsExperience} years" (EXACT number)
2244: 3. Use real achievements from resume with metrics
2245: 4. Reference specific company news/values
2246: 5. Keep the template structure but personalize content
2247: 6. Variant A: Use Template A structure
2248: 7. Variant B: Use Template B structure
2249: 
2250: CRITICAL RULES:
2251: - Experience: EXACTLY ${yearsExperience} years (no more, no less)
2252: - NO generic phrases like "proven track record" without specifics
2253: - NO casual language like "Here's what most people don't realize"
2254: - ALL achievements must come from the actual resume
2255: - Keep professional and mature tone
2256: 
2257: Return ONLY valid JSON:
2258: {
2259:   "variantA": "Full cover letter text using Template A structure...",
2260:   "variantB": "Full cover letter text using Template B structure...",
2261:   "personalization": ["Tip 1", "Tip 2", "Tip 3"]
2262: }`
2263: 
2264:       const response = await withRetry(
2265:         () => client.makeRequest(systemPrompt, userPrompt, { temperature: 0.3, maxTokens: 4000, model: 'sonar-pro' }),
2266:         MAX_RETRY_ATTEMPTS
2267:       )
2268: 
2269:       const parsed = parseAIResponse<{
2270:         variantA: string
2271:         variantB: string
2272:         personalization: string[]
2273:       }>(response.content)
2274: 
2275:       const data = {
2276:         variantA: parsed.variantA || 'Cover letter generation failed',
2277:         variantB: parsed.variantB || 'Cover letter generation failed',
2278:         personalization: Array.isArray(parsed.personalization) ? parsed.personalization : []
2279:       }
2280: 
2281:       setCache(cacheKey, data)
2282: 
2283:       return {
2284:         success: true,
2285:         data,
2286:         metadata: { requestId, timestamp: started, duration: Date.now() - started },
2287:         cached: false
2288:       }
2289:     } catch (error) {
2290:       console.error('[COVER_LETTERS] Error:', error)
2291:       return {
2292:         success: false,
2293:         data: {
2294:           variantA: 'Cover letter generation failed',
2295:           variantB: 'Cover letter generation failed',
2296:           personalization: []
2297:         },
2298:         metadata: { 
2299:           requestId, 
2300:           timestamp: started, 
2301:           duration: Date.now() - started,
2302:           error: (error as Error).message 
2303:         },
2304:         cached: false
2305:       }
2306:     }
2307:   }
2308: 
2309:   // Email Outreach Generator: Create personalized email templates
2310:   static async generateEmailOutreach(params: {
2311:     hiringContact: { name: string; title: string; email?: string }
2312:     jobTitle: string
2313:     company: string
2314:     resumeHighlights: string[]
2315:   }): Promise<EnhancedResponse<{
2316:     subjects: string[]
2317:     templates: Array<{ type: 'formal' | 'conversational'; body: string }>
2318:     mailtoLink: string
2319:   }>> {
2320:     const requestId = generateRequestId()
2321:     const started = Date.now()
2322:     const cacheKey = makeKey('email-outreach', params)
2323:     
2324:     const cached = getCache(cacheKey)
2325:     if (cached) {
2326:       return {
2327:         success: true,
2328:         data: cached as { subjects: string[]; templates: Array<{ type: 'formal' | 'conversational'; body: string }>; mailtoLink: string },
2329:         metadata: { requestId, timestamp: started, duration: 0 },
2330:         cached: true
2331:       }
2332:     }
2333: 
2334:     try {
2335:       const client = createClient()
2336:       const systemPrompt = 'You are an expert at professional networking and cold email outreach. Return only valid JSON.'
2337:       const userPrompt = `Create personalized email outreach templates for contacting a hiring manager.
2338: 
2339: **Hiring Contact:** ${params.hiringContact.name}, ${params.hiringContact.title}
2340: **Job Title:** ${params.jobTitle}
2341: **Company:** ${params.company}
2342: 
2343: **Resume Highlights:**
2344: ${params.resumeHighlights.map((h, i) => `${i + 1}. ${h}`).join('\n')}
2345: 
2346: Generate:
2347: 1. **3 email subject lines** (varied approaches: direct, curious, value-focused)
2348: 2. **2 email templates:**
2349:    - Formal: Professional, respectful tone
2350:    - Conversational: Friendly, engaging tone
2351: 
2352: Each template should:
2353: - Be concise (150-200 words)
2354: - Reference the hiring manager by name
2355: - Show genuine interest in the role/company
2356: - Highlight 1-2 relevant achievements
2357: - Include a clear call-to-action
2358: - Be personalized, not generic
2359: 
2360: Return ONLY valid JSON:
2361: {
2362:   "subjects": ["Subject 1", "Subject 2", "Subject 3"],
2363:   "templates": [
2364:     { "type": "formal", "body": "Email body..." },
2365:     { "type": "conversational", "body": "Email body..." }
2366:   ]
2367: }`
2368: 
2369:       const response = await withRetry(
2370:         () => client.makeRequest(systemPrompt, userPrompt, { temperature: 0.4, maxTokens: 3000, model: 'sonar-pro' }),
2371:         MAX_RETRY_ATTEMPTS
2372:       )
2373: 
2374:       const parsed = parseAIResponse<{
2375:         subjects: string[]
2376:         templates: Array<{ type: 'formal' | 'conversational'; body: string }>
2377:       }>(response.content)
2378: 
2379:       const mailtoLink = params.hiringContact.email 
2380:         ? `mailto:${params.hiringContact.email}?subject=${encodeURIComponent(parsed.subjects?.[0] || 'Inquiry about ' + params.jobTitle)}`
2381:         : ''
2382: 
2383:       const data = {
2384:         subjects: Array.isArray(parsed.subjects) ? parsed.subjects : [],
2385:         templates: Array.isArray(parsed.templates) ? parsed.templates : [],
2386:         mailtoLink
2387:       }
2388: 
2389:       setCache(cacheKey, data)
2390: 
2391:       return {
2392:         success: true,
2393:         data,
2394:         metadata: { requestId, timestamp: started, duration: Date.now() - started },
2395:         cached: false
2396:       }
2397:     } catch (error) {
2398:       console.error('[EMAIL_OUTREACH] Error:', error)
2399:       return {
2400:         success: false,
2401:         data: {
2402:           subjects: [],
2403:           templates: [],
2404:           mailtoLink: ''
2405:         },
2406:         metadata: { 
2407:           requestId, 
2408:           timestamp: started, 
2409:           duration: Date.now() - started,
2410:           error: (error as Error).message 
2411:         },
2412:         cached: false
2413:       }
2414:     }
2415:   }
2416: 
2417:   /**
2418:    * AGENT-POWERED: Job search with 95%+ reliability
2419:    * Uses NEW orchestrator-based agent system with Perplexity web_search + Cheerio fallback
2420:    * Searches 15+ job boards in parallel
2421:    */
2422:   static async jobListingsWithAgent(
2423:     jobTitle: string,
2424:     location: string,
2425:     options?: { maxResults?: number; workType?: 'remote'|'hybrid'|'onsite'|'any' }
2426:   ): Promise<EnhancedResponse<JobListing[]>> {
2427:     const started = Date.now()
2428:     const requestId = generateRequestId()
2429: 
2430:     console.log('🤖 [INTELLIGENCE] Starting NEW agent-powered job search...')
2431:     console.log(`📋 [INTELLIGENCE] Job: "${jobTitle}" in "${location}"`)
2432:     console.log(`🎯 [INTELLIGENCE] Max results: ${options?.maxResults || 30}`)
2433: 
2434:     try {
2435:       const { AgentOrchestrator } = await import('./agents/agent-orchestrator')
2436:       
2437:       const orchestrator = new AgentOrchestrator()
2438: 
2439:       const task = {
2440:         id: requestId,
2441:         type: 'job_search' as const,
2442:         input: { 
2443:           jobTitle, 
2444:           location, 
2445:           maxResults: options?.maxResults || 30,
2446:           workType: options?.workType
2447:         },
2448:         priority: 1 as const
2449:       }
2450: 
2451:       const result = await orchestrator.executeTask(task)
2452: 
2453:       if (!result.success || !result.data || result.data.length === 0) {
2454:         console.warn('⚠️ [INTELLIGENCE] Agent found no jobs, using fallback method')
2455:         return await this.jobMarketAnalysisV2(location, '', {
2456:           roleHint: jobTitle,
2457:           maxResults: options?.maxResults,
2458:           workType: options?.workType
2459:         })
2460:       }
2461: 
2462:       console.log(`✅ [INTELLIGENCE] Agent found ${result.data.length} jobs`)
2463:       console.log(`📊 [INTELLIGENCE] Confidence: ${result.confidence}, Method: ${result.method}`)
2464: 
2465:       return {
2466:         success: true,
2467:         data: result.data,
2468:         metadata: {
2469:           requestId,
2470:           timestamp: started,
2471:           duration: result.duration,
2472:           reasoning: result.reasoning,
2473:           confidence: result.confidence,
2474:           method: result.method,
2475:           sources: result.sources.length
2476:         },
2477:         cached: false
2478:       }
2479:     } catch (error) {
2480:       console.error('❌ [INTELLIGENCE] Agent system failed:', error)
2481:       console.log('🔄 [INTELLIGENCE] Falling back to standard method...')
2482:       
2483:       return await this.jobMarketAnalysisV2(location, '', {
2484:         roleHint: jobTitle,
2485:         maxResults: options?.maxResults,
2486:         workType: options?.workType
2487:       })
2488:     }
2489:   }
2490: 
2491:   /**
2492:    * AGENT-POWERED: Hiring contacts with 95%+ reliability
2493:    * Uses NEW orchestrator-based agent system with Perplexity + Hunter.io verification
2494:    * Returns empty array if no verified contacts (NO GUESSING)
2495:    */
2496:   static async hiringContactsWithAgent(
2497:     companyName: string,
2498:     companyDomain?: string
2499:   ): Promise<EnhancedResponse<HiringContact[]>> {
2500:     const started = Date.now()
2501:     const requestId = generateRequestId()
2502: 
2503:     console.log('🤖 [INTELLIGENCE] Starting NEW agent-powered contact research...')
2504:     console.log(`🏢 [INTELLIGENCE] Company: "${companyName}"`)
2505:     console.log(`🌐 [INTELLIGENCE] Domain: ${companyDomain || 'auto-detect'}`)
2506: 
2507:     try {
2508:       const { AgentOrchestrator } = await import('./agents/agent-orchestrator')
2509:       
2510:       const orchestrator = new AgentOrchestrator()
2511: 
2512:       const task = {
2513:         id: requestId,
2514:         type: 'contact_research' as const,
2515:         input: { 
2516:           companyName,
2517:           companyDomain
2518:         },
2519:         priority: 1 as const
2520:       }
2521: 
2522:       const result = await orchestrator.executeTask(task)
2523: 
2524:       if (!result.success || !result.data || result.data.length === 0) {
2525:         console.warn('⚠️ [INTELLIGENCE] No verified contacts found')
2526:         return {
2527:           success: false,
2528:           data: [],
2529:           metadata: {
2530:             requestId,
2531:             timestamp: started,
2532:             duration: result.duration,
2533:             error: `No verified hiring contacts found for ${companyName}. Visit company website or use LinkedIn InMail.`,
2534:             reasoning: result.reasoning
2535:           },
2536:           cached: false
2537:         }
2538:       }
2539: 
2540:       console.log(`✅ [INTELLIGENCE] Found ${result.data.length} verified contacts`)
2541:       console.log(`📊 [INTELLIGENCE] Confidence: ${result.confidence}`)
2542: 
2543:       return {
2544:         success: true,
2545:         data: result.data,
2546:         metadata: {
2547:           requestId,
2548:           timestamp: started,
2549:           duration: result.duration,
2550:           reasoning: result.reasoning,
2551:           confidence: result.confidence,
2552:           method: result.method,
2553:           sources: result.sources.length
2554:         },
2555:         cached: false
2556:       }
2557:     } catch (error) {
2558:       console.error('❌ [INTELLIGENCE] Contact agent system failed:', error)
2559:       console.log('🔄 [INTELLIGENCE] Falling back to standard method...')
2560:       return await this.hiringContactsV2(companyName)
2561:     }
2562:   }
2563: 
2564:   /**
2565:    * Clear cache entries (admin utility)
2566:    * @param prefix - Optional prefix to clear specific cache entries
2567:    * @returns Number of entries cleared
2568:    */
2569:   static clearCache(prefix?: string): number {
2570:     if (!prefix) {
2571:       const size = cache.size
2572:       cache.clear()
2573:       return size
2574:     }
2575:     
2576:     let cleared = 0
2577:     for (const key of cache.keys()) {
2578:       if (key.startsWith(prefix)) {
2579:         cache.delete(key)
2580:         cleared++
2581:       }
2582:     }
2583:     return cleared
2584:   }
2585: 
2586:   /**
2587:    * Get cache statistics (admin utility)
2588:    * @returns Cache stats including size, hit counts, and breakdown by prefix
2589:    */
2590:   static getCacheStats(): {
2591:     totalEntries: number
2592:     totalHits: number
2593:     breakdown: Record<string, { count: number; hits: number }>
2594:   } {
2595:     const breakdown: Record<string, { count: number; hits: number }> = {}
2596:     let totalHits = 0
2597: 
2598:     for (const [key, record] of cache.entries()) {
2599:       const prefix = key.split(':')[0] || 'unknown'
2600:       if (!breakdown[prefix]) {
2601:         breakdown[prefix] = { count: 0, hits: 0 }
2602:       }
2603:       breakdown[prefix].count++
2604:       breakdown[prefix].hits += record.metadata.hitCount
2605:       totalHits += record.metadata.hitCount
2606:     }
2607: 
2608:     return {
2609:       totalEntries: cache.size,
2610:       totalHits,
2611:       breakdown
2612:     }
2613:   }
2614: 
2615:   /**
2616:    * Custom query to Perplexity API (flexible utility)
2617:    * @param options - Query options including prompts and parameters
2618:    * @returns API response content
2619:    */
2620:   static async customQuery(options: {
2621:     systemPrompt: string
2622:     userPrompt: string
2623:     temperature?: number
2624:     maxTokens?: number
2625:     model?: 'sonar' | 'sonar-pro'
2626:   }): Promise<{ content: string }> {
2627:     const client = createClient()
2628:     const response = await client.makeRequest(
2629:       options.systemPrompt,
2630:       options.userPrompt,
2631:       {
2632:         temperature: options.temperature || 0.2,
2633:         maxTokens: options.maxTokens || 4000,
2634:         model: options.model || 'sonar-pro'
2635:       }
2636:     )
2637:     return { content: response.content }
2638:   }
2639: 
2640:   /**
2641:    * Get recommended job boards based on location
2642:    * @param location - User's location (e.g., "Toronto", "Canada", "USA")
2643:    * @returns Array of recommended job board names
2644:    */
2645:   static getRecommendedBoards(location: string): string[] {
2646:     const lowerLocation = location.toLowerCase()
2647:     const isCanadian = lowerLocation.includes('canada') || 
2648:                        lowerLocation.includes('toronto') || 
2649:                        lowerLocation.includes('vancouver') || 
2650:                        lowerLocation.includes('montreal') ||
2651:                        lowerLocation.includes('calgary') ||
2652:                        lowerLocation.includes('ottawa')
2653: 
2654:     if (isCanadian) {
2655:       return [
2656:         'Indeed Canada',
2657:         'Workopolis',
2658:         'Job Bank (Canada)',
2659:         'LinkedIn',
2660:         'Glassdoor',
2661:         'Monster Canada',
2662:         'CareerBuilder Canada',
2663:         'Eluta.ca',
2664:         'CharityVillage (Non-profit)',
2665:         'TechTO (Tech jobs)'
2666:       ]
2667:     }
2668: 
2669:     // Default US/International boards
2670:     return [
2671:       'Indeed',
2672:       'LinkedIn',
2673:       'Glassdoor',
2674:       'Monster',
2675:       'CareerBuilder',
2676:       'ZipRecruiter',
2677:       'SimplyHired',
2678:       'Dice (Tech)',
2679:       'AngelList (Startups)',
2680:       'RemoteOK (Remote)'
2681:     ]
2682:   }
2683: 
2684:   /**
2685:    * Get list of available job boards
2686:    * @returns Array of job board objects with name and URL
2687:    */
2688:   static getAvailableJobBoards(): Array<{ name: string; url: string; region: string }> {
2689:     return [
2690:       { name: 'Indeed', url: 'https://www.indeed.com', region: 'Global' },
2691:       { name: 'LinkedIn', url: 'https://www.linkedin.com/jobs', region: 'Global' },
2692:       { name: 'Glassdoor', url: 'https://www.glassdoor.com', region: 'Global' },
2693:       { name: 'Monster', url: 'https://www.monster.com', region: 'Global' },
2694:       { name: 'CareerBuilder', url: 'https://www.careerbuilder.com', region: 'US' },
2695:       { name: 'ZipRecruiter', url: 'https://www.ziprecruiter.com', region: 'US' },
2696:       { name: 'SimplyHired', url: 'https://www.simplyhired.com', region: 'US' },
2697:       { name: 'Dice', url: 'https://www.dice.com', region: 'US (Tech)' },
2698:       { name: 'Indeed Canada', url: 'https://ca.indeed.com', region: 'Canada' },
2699:       { name: 'Workopolis', url: 'https://www.workopolis.com', region: 'Canada' },
2700:       { name: 'Job Bank', url: 'https://www.jobbank.gc.ca', region: 'Canada' },
2701:       { name: 'Eluta', url: 'https://www.eluta.ca', region: 'Canada' },
2702:       { name: 'AngelList', url: 'https://angel.co/jobs', region: 'Startups' },
2703:       { name: 'RemoteOK', url: 'https://remoteok.com', region: 'Remote' },
2704:       { name: 'We Work Remotely', url: 'https://weworkremotely.com', region: 'Remote' }
2705:     ]
2706:   }
2707: 
2708:   /**
2709:    * Extract career timeline from resume
2710:    * @param resumeText - Resume text content
2711:    * @returns Career timeline with industries and experience
2712:    */
2713:   static async extractCareerTimeline(resumeText: string): Promise<{
2714:     industries: Array<{ name: string; percentage: number; years: number }>
2715:     totalYears: number
2716:     primaryIndustry: string
2717:   }> {
2718:     const client = createClient()
2719:     const prompt = `Analyze this resume and extract the career timeline:
2720: 
2721: ${resumeText.slice(0, 3000)}
2722: 
2723: Return ONLY valid JSON with this structure:
2724: {
2725:   "industries": [
2726:     { "name": "Industry Name", "percentage": 40, "years": 5 },
2727:     { "name": "Another Industry", "percentage": 30, "years": 3 }
2728:   ],
2729:   "totalYears": 8,
2730:   "primaryIndustry": "Most relevant industry"
2731: }
2732: 
2733: Rules:
2734: - List all industries worked in
2735: - Calculate percentage of time in each
2736: - Count years of experience per industry
2737: - Identify primary/dominant industry`
2738: 
2739:     const response = await client.makeRequest(
2740:       'You are a career analyst. Extract career timeline data. Return ONLY valid JSON.',
2741:       prompt,
2742:       { temperature: 0.2, maxTokens: 1000, model: 'sonar-pro' }
2743:     )
2744: 
2745:     try {
2746:       const parsed = parseAIResponse<{
2747:         industries: Array<{ name: string; percentage: number; years: number }>
2748:         totalYears: number
2749:         primaryIndustry: string
2750:       }>(response.content)
2751: 
2752:       return {
2753:         industries: parsed.industries || [],
2754:         totalYears: parsed.totalYears || 0,
2755:         primaryIndustry: parsed.primaryIndustry || (parsed.industries?.[0]?.name || 'Unknown')
2756:       }
2757:     } catch {
2758:       // Fallback if parsing fails
2759:       return {
2760:         industries: [{ name: 'General', percentage: 100, years: 0 }],
2761:         totalYears: 0,
2762:         primaryIndustry: 'General'
2763:       }
2764:     }
2765:   }
2766: 
2767:   /**
2768:    * Enhanced company research with comprehensive data
2769:    * @param params - Company name, job title, location
2770:    * @returns Enhanced company research data
2771:    */
2772:   static async enhancedCompanyResearch(params: {
2773:     companyName: string
2774:     jobTitle?: string
2775:     location?: string
2776:   }): Promise<EnhancedResponse<IntelligenceResponse>> {
2777:     // Use existing researchCompanyV2 as the base
2778:     return await this.researchCompanyV2({
2779:       company: params.companyName,
2780:       role: params.jobTitle,
2781:       geo: params.location
2782:     })
2783:   }
2784: }
</file>

</files>
