This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/app/api/resume/upload/route.ts, src/lib/profile-mapper.ts, src/lib/enhanced-resume-extractor.ts, src/app/api/jobs/search/route.ts, src/app/api/jobs/search-by-resume/route.ts, src/lib/job-aggregator.ts, src/lib/keyword-extraction.ts, src/app/career-finder/search/page.tsx, src/app/api/interview-prep/generate/route.ts, src/app/api/company/research/route.ts, src/app/api/applications/create/route.ts, src/app/api/follow-ups/generate/route.ts, src/app/api/cover-letter/generate/route.ts, src/app/api/salary/generate/route.ts, src/models/UserProfile.ts, src/models/Application.ts, src/types/supabase.ts
- Files matching these patterns are excluded: node_modules/**, .next/**, *.test.ts, *.test.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/app/api/applications/create/route.ts
src/app/api/company/research/route.ts
src/app/api/cover-letter/generate/route.ts
src/app/api/interview-prep/generate/route.ts
src/app/api/jobs/search-by-resume/route.ts
src/app/api/jobs/search/route.ts
src/app/api/resume/upload/route.ts
src/app/api/salary/generate/route.ts
src/app/career-finder/search/page.tsx
src/lib/enhanced-resume-extractor.ts
src/lib/job-aggregator.ts
src/lib/keyword-extraction.ts
src/lib/profile-mapper.ts
src/models/Application.ts
src/models/UserProfile.ts
src/types/supabase.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/api/applications/create/route.ts">
 1: import { NextRequest, NextResponse } from 'next/server'
 2: import { getServerSession } from 'next-auth'
 3: import { authOptions } from '@/lib/auth'
 4: import dbConnect from '@/lib/mongodb'
 5: import Application from '@/models/Application'
 6: 
 7: export async function POST(req: NextRequest) {
 8:   try {
 9:     const session = await getServerSession(authOptions)
10:     if (!session?.user?.id) {
11:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
12:     }
13: 
14:     const { jobId, company, jobTitle, location, salary, recipient } = await req.json()
15:     
16:     if (!company || !jobTitle) {
17:       return NextResponse.json({ error: 'Company and job title are required' }, { status: 400 })
18:     }
19: 
20:     await dbConnect()
21: 
22:     const application = await Application.create({
23:       userId: session.user.id,
24:       jobId,
25:       company,
26:       jobTitle,
27:       location,
28:       salary,
29:       recipient: recipient || 'hiring@' + company.toLowerCase().replace(/\s+/g, '') + '.com',
30:       status: 'applied',
31:       appliedAt: new Date(),
32:       attachments: [],
33:       metadata: {}
34:     })
35: 
36:     console.log('[APPLICATIONS] ✅ Created application:', application._id, 'for', company)
37: 
38:     return NextResponse.json({ 
39:       success: true, 
40:       application: {
41:         id: application._id,
42:         company: application.company,
43:         jobTitle: application.jobTitle,
44:         status: application.status,
45:         appliedAt: application.appliedAt
46:       }
47:     })
48:   } catch (error) {
49:     console.error('[APPLICATIONS] ❌ Error creating application:', error)
50:     return NextResponse.json({ 
51:       error: 'Failed to create application',
52:       details: error instanceof Error ? error.message : 'Unknown error'
53:     }, { status: 500 })
54:   }
55: }
</file>

<file path="src/app/api/company/research/route.ts">
 1: import { NextRequest, NextResponse } from 'next/server'
 2: import { getServerSession } from 'next-auth/next'
 3: import { authOptions } from '@/lib/auth'
 4: import connectToDatabase from '@/lib/mongodb'
 5: import { PerplexityIntelligenceService } from '@/lib/perplexity-intelligence'
 6: 
 7: export const runtime = 'nodejs'
 8: export const dynamic = 'force-dynamic'
 9: 
10: export async function POST(req: NextRequest) {
11:   try {
12:     const session = await getServerSession(authOptions)
13:     if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
14:     await connectToDatabase()
15: 
16:     const body = await req.json().catch(()=>({})) as any
17:     let company = (body.company || body.companyName || '').toString().trim()
18:     if (!company) return NextResponse.json({ error: 'company required' }, { status: 400 })
19:     
20:     // CRITICAL FIX: Sanitize company name (remove noise from PDF extraction)
21:     const originalCompany = company
22:     company = company
23:       .replace(/\s*\(.*?\)\s*/g, '') // Remove text in parentheses
24:       .replace(/\s*-.*$/g, '') // Remove everything after dash
25:       .replace(/\s+/g, ' ') // Normalize spaces
26:       .trim()
27:       .split(/\s+/)
28:       .slice(0, 5) // Max 5 words
29:       .join(' ')
30:     
31:     console.log('[COMPANY_RESEARCH] Sanitized:', {
32:       original: originalCompany,
33:       sanitized: company,
34:       changed: originalCompany !== company
35:     })
36: 
37:     const intel = await PerplexityIntelligenceService.researchCompanyV2({ company })
38:     const contacts = await PerplexityIntelligenceService.hiringContactsV2(company)
39: 
40:     // Normalize contacts with mailto links
41:     const contactList = (contacts.data || []).map(c => ({
42:       name: c.name,
43:       title: c.title,
44:       department: c.department,
45:       linkedinUrl: c.linkedinUrl || null,
46:       email: c.email || null,
47:       emailType: c.emailType || 'inferred',
48:       mailto: c.email ? `mailto:${c.email}` : null,
49:       altEmails: c.alternativeEmails || [],
50:       source: c.source,
51:       confidence: c.confidence
52:     }))
53: 
54:     return NextResponse.json({ success: intel.success && contacts.success, company: intel.data, contacts: contactList, meta: { cached: intel.cached && contacts.cached } })
55:   } catch (e) {
56:     return NextResponse.json({ error: 'company research failed' }, { status: 500 })
57:   }
58: }
</file>

<file path="src/app/api/cover-letter/generate/route.ts">
  1: import { NextRequest, NextResponse } from 'next/server';
  2: import { getServerSession } from 'next-auth/next';
  3: import connectToDatabase from '@/lib/mongodb';
  4: import Resume from '@/models/Resume';
  5: import CompanyData from '@/models/CompanyData';
  6: import { authOptions } from '@/lib/auth';
  7: import { generateCoverLetter } from '@/lib/cover-letter-generator';
  8: import CoverLetter from '@/models/CoverLetter';
  9: import { isRateLimited } from '@/lib/rate-limit';
 10: import { coverLetterRawSchema } from '@/lib/validators';
 11: import { getOrCreateRequestId, logRequestStart, logRequestEnd, now, durationMs } from '@/lib/observability'
 12: 
 13: export const runtime = 'nodejs'
 14: export const dynamic = 'force-dynamic'
 15: 
 16: // NOTE: calculateYearsFromResume moved to cover-letter-generator.ts
 17: // This function is no longer needed here
 18: 
 19: // DEPRECATED: Keeping for reference, but not used
 20: function calculateYearsFromResumeOLD(resumeText: string): number {
 21:   // Extract only the work experience section to avoid counting education dates
 22:   const experienceSection = extractExperienceSection(resumeText)
 23:   
 24:   // Match date ranges in various formats
 25:   const dateRegex = /(\w+\s+\d{4}|(\d{1,2}\/\d{4}))\s*[-–—]\s*(\w+\s+\d{4}|Present|Current|(\d{1,2}\/\d{4}))/gi
 26:   const matches = Array.from(experienceSection.matchAll(dateRegex))
 27:   
 28:   // Parse all date ranges into start/end pairs
 29:   const periods: Array<{ start: Date; end: Date }> = []
 30:   for (const match of matches) {
 31:     try {
 32:       const startStr = match[1]
 33:       const endStr = match[3]
 34:       
 35:       const startDate = new Date(startStr)
 36:       const endDate = endStr.match(/Present|Current/i) ? new Date() : new Date(endStr)
 37:       
 38:       // Validate dates are reasonable (not in future, not before 1970)
 39:       if (startDate.getFullYear() < 1970 || startDate.getFullYear() > new Date().getFullYear()) continue
 40:       if (endDate.getFullYear() < 1970 || endDate.getFullYear() > new Date().getFullYear() + 1) continue
 41:       if (startDate > endDate) continue // Skip invalid ranges
 42:       
 43:       const months = (endDate.getFullYear() - startDate.getFullYear()) * 12 + 
 44:                     (endDate.getMonth() - startDate.getMonth())
 45:       
 46:       // Sanity check: skip periods longer than 50 years or negative
 47:       if (months > 0 && months < 600) {
 48:         periods.push({ start: startDate, end: endDate })
 49:       }
 50:     } catch (e) {
 51:       // Skip invalid dates
 52:       continue
 53:     }
 54:   }
 55:   
 56:   // If no valid periods found, return 0
 57:   if (periods.length === 0) return 0
 58:   
 59:   // Sort periods by start date
 60:   periods.sort((a, b) => a.start.getTime() - b.start.getTime())
 61:   
 62:   // Merge overlapping periods to avoid double-counting
 63:   const merged: Array<{ start: Date; end: Date }> = []
 64:   let current = periods[0]
 65:   
 66:   for (let i = 1; i < periods.length; i++) {
 67:     const next = periods[i]
 68:     
 69:     // If periods overlap or are adjacent, merge them
 70:     if (next.start <= current.end) {
 71:       current.end = new Date(Math.max(current.end.getTime(), next.end.getTime()))
 72:     } else {
 73:       // No overlap, push current and start new period
 74:       merged.push(current)
 75:       current = next
 76:     }
 77:   }
 78:   merged.push(current)
 79:   
 80:   // Calculate total months from merged periods
 81:   let totalMonths = 0
 82:   for (const period of merged) {
 83:     const months = (period.end.getFullYear() - period.start.getFullYear()) * 12 + 
 84:                   (period.end.getMonth() - period.start.getMonth())
 85:     totalMonths += months
 86:   }
 87:   
 88:   const years = Math.round(totalMonths / 12)
 89:   
 90:   // CRITICAL FIX: Cap at realistic maximum
 91:   // Assume candidate started working at age 18, max age 65
 92:   // Most candidates are 25-45, so cap at 25 years to be safe
 93:   const maxRealisticYears = 25
 94:   const cappedYears = Math.min(years, maxRealisticYears)
 95:   
 96:   // If calculated years seem unrealistic (>25), round down to nearest 5
 97:   if (cappedYears > 15) {
 98:     return Math.floor(cappedYears / 5) * 5
 99:   }
100:   
101:   return cappedYears
102: }
103: 
104: // Extract work experience section from resume to avoid counting education dates
105: function extractExperienceSection(resumeText: string): string {
106:   const text = resumeText.toLowerCase()
107:   
108:   // Find work experience section markers
109:   const experienceMarkers = [
110:     'work experience',
111:     'professional experience',
112:     'employment history',
113:     'experience',
114:     'work history',
115:     'career history'
116:   ]
117:   
118:   // Find education section markers to exclude
119:   const educationMarkers = [
120:     'education',
121:     'academic background',
122:     'academic history',
123:     'degrees'
124:   ]
125:   
126:   let experienceStart = -1
127:   let experienceMarker = ''
128:   
129:   // Find the earliest experience marker
130:   for (const marker of experienceMarkers) {
131:     const index = text.indexOf(marker)
132:     if (index !== -1 && (experienceStart === -1 || index < experienceStart)) {
133:       experienceStart = index
134:       experienceMarker = marker
135:     }
136:   }
137:   
138:   // If no experience section found, use entire resume (fallback)
139:   if (experienceStart === -1) return resumeText
140:   
141:   // Find where experience section ends (usually at education or end of document)
142:   let experienceEnd = resumeText.length
143:   for (const marker of educationMarkers) {
144:     const index = text.indexOf(marker, experienceStart + experienceMarker.length)
145:     if (index !== -1 && index < experienceEnd) {
146:       experienceEnd = index
147:     }
148:   }
149:   
150:   return resumeText.substring(experienceStart, experienceEnd)
151: }
152: 
153: export async function POST(request: NextRequest) {
154:   try {
155:     if (!process.env.PERPLEXITY_API_KEY) return NextResponse.json({ error: 'AI temporarily unavailable (missing PERPLEXITY_API_KEY)' }, { status: 503 })
156:     const requestId = getOrCreateRequestId(request.headers as any)
157:     const startedAt = now()
158:     const routeKey = 'cover-letter:generate'
159:     logRequestStart(routeKey, requestId)
160:     // Check authentication
161:     const session = await getServerSession(authOptions);
162:     if (!session?.user?.email) {
163:       return NextResponse.json(
164:         { error: 'Unauthorized' },
165:         { status: 401 }
166:       );
167:     }
168: 
169:     const body = await request.json();
170:     const { jobApplicationId, resumeId, tone = 'professional', length = 'medium', raw, save, psychology: psychologyFromBody } = body;
171: 
172:     const rl = await isRateLimited((session.user as any).id, 'cover-letter');
173:     if (rl) {
174:       return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 });
175:     }
176: 
177:     // RAW INPUT MODE: allow direct inputs without DB lookups
178:     if (!jobApplicationId && !resumeId && raw === true) {
179:       // Extract and validate required fields BEFORE Zod validation
180:       const { jobTitle, companyName, resumeText, template } = body;
181:       let { jobDescription } = body;
182:       
183:       // Allow empty jobDescription - use generic text (BEFORE validation)
184:       if (!jobDescription || jobDescription.trim() === '') {
185:         jobDescription = `Position at ${companyName} for ${jobTitle} role.`
186:         console.log('[COVER_LETTER] No job description provided, using generic text')
187:       }
188:       
189:       // Now validate with Zod (jobDescription is already set)
190:       const parsed = coverLetterRawSchema.safeParse({ ...body, jobDescription });
191:       if (!parsed.success) {
192:         console.error('[COVER_LETTER] Validation failed:', parsed.error.issues)
193:         return NextResponse.json({ error: 'Invalid input', details: parsed.error.issues }, { status: 400 });
194:       }
195:       
196:       if (!jobTitle || !companyName || !resumeText) {
197:         console.error('[COVER_LETTER] Missing required fields:', { jobTitle: !!jobTitle, companyName: !!companyName, resumeText: !!resumeText })
198:         return NextResponse.json(
199:           { error: 'Missing required fields: jobTitle, companyName, resumeText' },
200:           { status: 400 }
201:         );
202:       }
203: 
204:       // Get candidate info
205:       const candidateName = session.user.name || ''
206:       const candidateEmail = session.user.email || ''
207:       
208:       // Get hiring contact if available
209:       let hiringContact = ''
210:       try {
211:         const ja = (await import('@/models/JobApplication')).default
212:         const recent = await ja.findOne({ userId: session.user.id }).sort({ createdAt: -1 })
213:         if (recent?.context?.hiringContactName) hiringContact = recent.context.hiringContactName
214:       } catch {}
215: 
216:       // Use shared cover letter generator
217:       const result = await generateCoverLetter({
218:         resumeText,
219:         jobTitle,
220:         companyName,
221:         jobDescription,
222:         candidateName,
223:         candidateEmail,
224:         hiringContactName: hiringContact,
225:         templateId: template || 'modern',
226:         tone,
227:         psychology: psychologyFromBody,
228:       })
229:       
230:       const { coverLetter, authenticity: report, wordCount, preview } = result
231:       const keyPoints: string[] = []
232:       
233:       console.log('[COVER_LETTER] Generated:', wordCount, 'words, authenticity score:', report.authenticityScore)
234: 
235:       if (save === true) {
236:         await connectToDatabase();
237:         await CoverLetter.create({
238:           userId: session.user.id,
239:           jobTitle,
240:           companyName,
241:           jobDescription,
242:           resumeSnapshot: (resumeText as string).slice(0, 4000),
243:           content: coverLetter,
244:           tone,
245:           length,
246:         })
247:       }
248:       const resp = NextResponse.json({
249:         success: true,
250:         coverLetter,
251:         keyPoints,
252:         authenticity: report,
253:         wordCount,
254:         preview
255:       });
256:       resp.headers.set('x-request-id', requestId)
257:       logRequestEnd(routeKey, requestId, 200, durationMs(startedAt))
258:       return resp
259:     }
260: 
261:     if (!jobApplicationId || !resumeId) {
262:       return NextResponse.json(
263:         { error: 'Missing required fields: jobApplicationId, resumeId' },
264:         { status: 400 }
265:       );
266:     }
267: 
268:     // Connect to database
269:     await connectToDatabase();
270: 
271:     // Find the resume
272:     const resume = await Resume.findOne({
273:       _id: resumeId,
274:       userId: session.user.id
275:     });
276: 
277:     if (!resume) {
278:       return NextResponse.json(
279:         { error: 'Resume not found' },
280:         { status: 404 }
281:       );
282:     }
283: 
284:     // Find the job application
285:     const JobApplication = (await import('@/models/JobApplication')).default;
286:     const jobApplication = await JobApplication.findOne({
287:       _id: jobApplicationId,
288:       userId: session.user.id
289:     });
290: 
291:     if (!jobApplication) {
292:       return NextResponse.json(
293:         { error: 'Job application not found' },
294:         { status: 404 }
295:       );
296:     }
297: 
298:     // Get company research data
299:     let companyPsychology: Record<string, unknown> | undefined = undefined;
300:     if (jobApplication.companyResearch) {
301:       const companyData = await CompanyData.findById(jobApplication.companyResearch);
302:       if (companyData) companyPsychology = companyData;
303:     }
304:     // Merge stored context (psychology) if present
305:     if (!companyPsychology && jobApplication.context?.companyData) {
306:       companyPsychology = jobApplication.context.companyData;
307:     }
308: 
309:     // Get candidate info
310:     const candidateName = session.user.name || ''
311:     const hiringContactName = jobApplication.context?.hiringContactName || ''
312:     
313:     // Use shared cover letter generator (SECOND PATH - now using shared code!)
314:     const result2 = await generateCoverLetter({
315:       resumeText: resume.extractedText || '',
316:       jobTitle: jobApplication.jobTitle,
317:       companyName: jobApplication.companyName,
318:       jobDescription: jobApplication.jobDescription,
319:       candidateName,
320:       hiringContactName,
321:       templateId: (body.template as string) || 'modern',
322:       tone,
323:       psychology: companyPsychology,
324:     })
325:     
326:     const { coverLetter, authenticity: report, wordCount, preview: preview2 } = result2
327:     const keyPoints: string[] = []
328:     
329:     console.log('[COVER_LETTER] Generated (DB path):', wordCount, 'words, authenticity score:', report.authenticityScore)
330: 
331:     if (save === true) {
332:       await CoverLetter.create({
333:         userId: session.user.id,
334:         applicationId: jobApplication._id,
335:         jobTitle: jobApplication.jobTitle,
336:         companyName: jobApplication.companyName,
337:         jobDescription: jobApplication.jobDescription,
338:         resumeSnapshot: (resume.extractedText || '').slice(0, 4000),
339:       content: coverLetter,
340:         tone,
341:         length,
342:       })
343:     }
344: 
345:     const resp2 = NextResponse.json({
346:       success: true,
347:       coverLetter,
348:       keyPoints,
349:       authenticity: report,
350:       wordCount,
351:       preview: preview2
352:     });
353:     resp2.headers.set('x-request-id', requestId)
354:     logRequestEnd(routeKey, requestId, 200, durationMs(startedAt))
355:     return resp2
356: 
357:   } catch (error) {
358:     console.error('Cover letter generation error:', error);
359:     return NextResponse.json(
360:       { error: 'Failed to generate cover letter' },
361:       { status: 500 }
362:     );
363:   }
364: }
</file>

<file path="src/app/api/interview-prep/generate/route.ts">
  1: import { NextRequest, NextResponse } from 'next/server'
  2: import { getServerSession } from 'next-auth'
  3: import { authOptions } from '@/lib/auth'
  4: import dbConnect from '@/lib/mongodb'
  5: import Application from '@/models/Application'
  6: import { PerplexityIntelligenceService } from '@/lib/perplexity-intelligence'
  7: 
  8: export async function POST(req: NextRequest) {
  9:   try {
 10:     const session = await getServerSession(authOptions)
 11:     if (!session?.user?.id) {
 12:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
 13:     }
 14: 
 15:     const { applicationId, resumeText, companyResearch } = await req.json()
 16:     
 17:     if (!applicationId) {
 18:       return NextResponse.json({ error: 'Application ID required' }, { status: 400 })
 19:     }
 20: 
 21:     await dbConnect()
 22: 
 23:     const application = await Application.findOne({ 
 24:       _id: applicationId, 
 25:       userId: session.user.id 
 26:     })
 27: 
 28:     if (!application) {
 29:       return NextResponse.json({ error: 'Application not found' }, { status: 404 })
 30:     }
 31: 
 32:     console.log('[INTERVIEW_PREP] 🎯 Generating prep for:', application.company, '-', application.jobTitle)
 33: 
 34:     // Generate AI interview questions
 35:     const prompt = `Generate a comprehensive interview preparation guide for this job application:
 36: 
 37: COMPANY: ${application.company}
 38: ROLE: ${application.jobTitle}
 39: LOCATION: ${application.location || 'Not specified'}
 40: 
 41: ${companyResearch ? `COMPANY INSIGHTS:
 42: ${JSON.stringify(companyResearch, null, 2)}` : ''}
 43: 
 44: ${resumeText ? `CANDIDATE BACKGROUND:
 45: ${resumeText.slice(0, 2000)}` : ''}
 46: 
 47: Generate a JSON response with:
 48: {
 49:   "questions": [
 50:     "5 role-specific technical/behavioral questions",
 51:     "3 company-specific questions based on recent news/culture",
 52:     "2 situational questions aligned with core competencies"
 53:   ],
 54:   "companyInsights": "Brief summary of company culture, values, and what they look for in candidates",
 55:   "talkingPoints": [
 56:     "3-5 key achievements or skills to highlight",
 57:     "How to position your experience for this role",
 58:     "Questions to ask the interviewer"
 59:   ]
 60: }
 61: 
 62: Make questions realistic and specific to the role and company.`
 63: 
 64:     const response = await PerplexityIntelligenceService.customQuery({
 65:       systemPrompt: 'You are an expert career coach helping candidates prepare for interviews. Return valid JSON only.',
 66:       userPrompt: prompt,
 67:       temperature: 0.7,
 68:       maxTokens: 2000
 69:     })
 70: 
 71:     let prepData
 72:     try {
 73:       prepData = JSON.parse(response.content)
 74:     } catch {
 75:       // Fallback if JSON parsing fails
 76:       prepData = {
 77:         questions: [
 78:           `Tell me about your experience with ${application.jobTitle}`,
 79:           `Why do you want to work at ${application.company}?`,
 80:           'What are your greatest strengths and weaknesses?',
 81:           'Describe a challenging project you worked on',
 82:           'Where do you see yourself in 5 years?'
 83:         ],
 84:         companyInsights: `${application.company} is looking for candidates who align with their values and can contribute to their mission.`,
 85:         talkingPoints: [
 86:           'Highlight relevant technical skills',
 87:           'Emphasize cultural fit',
 88:           'Show enthusiasm for the role'
 89:         ]
 90:       }
 91:     }
 92: 
 93:     // Save to application
 94:     application.interviewPrep = {
 95:       questions: prepData.questions,
 96:       companyInsights: prepData.companyInsights,
 97:       talkingPoints: prepData.talkingPoints,
 98:       preparedAt: new Date()
 99:     }
100:     await application.save()
101: 
102:     console.log('[INTERVIEW_PREP] ✅ Generated', prepData.questions.length, 'questions')
103: 
104:     return NextResponse.json({
105:       success: true,
106:       prep: {
107:         questions: prepData.questions,
108:         companyInsights: prepData.companyInsights,
109:         talkingPoints: prepData.talkingPoints,
110:         company: application.company,
111:         jobTitle: application.jobTitle
112:       }
113:     })
114:   } catch (error) {
115:     console.error('[INTERVIEW_PREP] ❌ Error:', error)
116:     return NextResponse.json({ 
117:       error: 'Failed to generate interview prep',
118:       details: error instanceof Error ? error.message : 'Unknown error'
119:     }, { status: 500 })
120:   }
121: }
</file>

<file path="src/app/api/jobs/search-by-resume/route.ts">
  1: /**
  2:  * Job Search by Resume Keywords API
  3:  * 
  4:  * Uses multi-layer caching and aggregation:
  5:  * 1. Redis cache (instant)
  6:  * 2. MongoDB cache (fast, shared across users)
  7:  * 3. Perplexity sonar-pro (costs money)
  8:  * 4. Puppeteer scrapers (free, slower)
  9:  */
 10: 
 11: import { NextRequest, NextResponse } from 'next/server'
 12: import { getServerSession } from 'next-auth/next'
 13: import { authOptions } from '@/lib/auth'
 14: import Resume from '@/models/Resume'
 15: import { dbService } from '@/lib/database'
 16: import { JobAggregator } from '@/lib/job-aggregator'
 17: import { ProfileMapper } from '@/lib/profile-mapper'
 18: 
 19: export const runtime = 'nodejs'
 20: export const dynamic = 'force-dynamic'
 21: export const maxDuration = 60 // 60 seconds for scraping
 22: 
 23: export async function POST(request: NextRequest) {
 24:   const startTime = Date.now()
 25:   
 26:   try {
 27:     await dbService.connect()
 28: 
 29:     const session = await getServerSession(authOptions)
 30:     if (!session?.user?.id) {
 31:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
 32:     }
 33: 
 34:     const body = await request.json()
 35:     const { resumeId, radiusKm = 70, maxResults = 100 } = body
 36: 
 37:     if (!resumeId) {
 38:       return NextResponse.json({ error: 'Resume ID required' }, { status: 400 })
 39:     }
 40: 
 41:     console.log('[JOB_SEARCH_API] Starting search:', {
 42:       userId: session.user.id,
 43:       resumeId,
 44:       radiusKm,
 45:       maxResults
 46:     })
 47: 
 48:     // Get resume with keywords and location
 49:     const resume = await Resume.findOne({
 50:       _id: resumeId,
 51:       userId: session.user.id
 52:     })
 53: 
 54:     if (!resume) {
 55:       return NextResponse.json({ error: 'Resume not found' }, { status: 404 })
 56:     }
 57: 
 58:     // Get profile data (REQUIRED - no fallback to old resume signals)
 59:     const profileData = await ProfileMapper.getProfileForJobSearch(session.user.id)
 60:     
 61:     if (!profileData) {
 62:       return NextResponse.json({
 63:         error: 'Profile not found',
 64:         details: 'Please upload your resume to create your profile. Your resume will be analyzed and your profile will be created automatically.'
 65:       }, { status: 404 })
 66:     }
 67: 
 68:     const keywords = profileData.keywords
 69:     const location = profileData.location
 70:     
 71:     console.log('[JOB_SEARCH_API] Using profile data:', {
 72:       keywords: keywords.slice(0, 10),
 73:       location,
 74:       experienceLevel: profileData.experienceLevel,
 75:       totalKeywords: keywords.length
 76:     })
 77: 
 78:     // Search jobs using aggregator
 79:     const aggregator = JobAggregator.getInstance()
 80:     const result = await aggregator.searchByResumeKeywords(
 81:       keywords,
 82:       location,
 83:       radiusKm,
 84:       maxResults
 85:     )
 86: 
 87:     const duration = Date.now() - startTime
 88: 
 89:     console.log('[JOB_SEARCH_API] Search complete:', {
 90:       jobsFound: result.jobs.length,
 91:       source: result.source,
 92:       cached: result.cached,
 93:       duration: `${duration}ms`
 94:     })
 95: 
 96:     return NextResponse.json({
 97:       success: true,
 98:       jobs: result.jobs,
 99:       metadata: {
100:         source: result.source,
101:         cached: result.cached,
102:         timestamp: result.timestamp,
103:         searchCount: result.searchCount,
104:         duration,
105:         keywords: keywords.slice(0, 10),
106:         location,
107:         radiusKm
108:       }
109:     })
110: 
111:   } catch (error) {
112:     console.error('[JOB_SEARCH_API] Error:', error)
113:     return NextResponse.json({
114:       error: 'Job search failed',
115:       details: error instanceof Error ? error.message : 'Unknown error'
116:     }, { status: 500 })
117:   }
118: }
119: 
120: /**
121:  * Get cache statistics
122:  */
123: export async function GET() {
124:   try {
125:     const session = await getServerSession(authOptions)
126:     if (!session?.user?.id) {
127:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
128:     }
129: 
130:     const aggregator = JobAggregator.getInstance()
131:     const stats = await aggregator.getCacheStats()
132: 
133:     return NextResponse.json({
134:       success: true,
135:       stats
136:     })
137: 
138:   } catch (error) {
139:     console.error('[JOB_SEARCH_API] Stats error:', error)
140:     return NextResponse.json({
141:       error: 'Failed to get stats',
142:       details: error instanceof Error ? error.message : 'Unknown error'
143:     }, { status: 500 })
144:   }
145: }
</file>

<file path="src/app/api/resume/upload/route.ts">
  1: /**
  2:  * Resume Upload API Route
  3:  * @description Handles PDF resume uploads with AI-powered text extraction
  4:  * @route POST /api/resume/upload
  5:  */
  6: import { NextRequest, NextResponse } from 'next/server'
  7: import { getServerSession } from 'next-auth/next'
  8: import { authOptions } from '@/lib/auth'
  9: import Resume from '@/models/Resume'
 10: import { dbService } from '@/lib/database'
 11: import { isRateLimited } from '@/lib/rate-limit'
 12: import path from 'path'
 13: import { cleanPDFExtraction } from '@/lib/utils/pdf-cleaner'
 14: 
 15: function cleanExtractedText(text: string): string {
 16:   // Use comprehensive PDF cleaner first
 17:   let cleaned = cleanPDFExtraction(text)
 18:   
 19:   // Additional cleaning for resume-specific content
 20:   cleaned = cleaned
 21:     .replace(/https?:\/\/[^\s]+/gi, '') // URLs
 22:     .replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi, '') // Emails (during parsing)
 23:     .replace(/\s+/g, ' ') // Whitespace
 24:     .trim()
 25:   
 26:   return cleaned
 27: }
 28: 
 29: const MIN_VALID_PDF_TEXT_LENGTH = Number(process.env.RESUME_MIN_TEXT_LENGTH || 150)
 30: const ASCII_FALLBACK_CONFIDENCE = 0.3
 31: 
 32: // AI-based OCR fallback using base64 encoding
 33: async function extractTextWithAI(buffer: Buffer): Promise<string> {
 34:   try {
 35:     console.log('[PDF_PARSE] Attempting AI-based extraction')
 36:     const { PerplexityIntelligenceService } = await import('@/lib/perplexity-intelligence')
 37:     
 38:     // Convert PDF to base64
 39:     const base64 = buffer.toString('base64')
 40:     
 41:     const result = await PerplexityIntelligenceService.customQuery({
 42:       systemPrompt: 'You are a resume text extractor. Extract ALL text from the provided PDF resume. Return ONLY the extracted text, no formatting, no markdown, no explanations.',
 43:       userPrompt: `Extract all text from this PDF resume (base64 encoded, first 1000 chars): ${base64.slice(0, 1000)}...\n\nReturn the complete resume text.`,
 44:       temperature: 0.1,
 45:       maxTokens: 4000
 46:     })
 47:     
 48:     if (result.content && result.content.length > MIN_VALID_PDF_TEXT_LENGTH) {
 49:       console.log('[PDF_PARSE] ✅ AI extraction SUCCESS:', result.content.length, 'chars')
 50:       return result.content
 51:     }
 52:     
 53:     throw new Error('AI extraction returned insufficient text')
 54:   } catch (error) {
 55:     console.error('[PDF_PARSE] ❌ AI extraction failed:', error)
 56:     throw error
 57:   }
 58: }
 59: 
 60: async function extractTextFromPDF(buffer: Buffer): Promise<{ text: string; method: string; confidence?: number }> {
 61:   console.log('[PDF_PARSE] ==========================================')
 62:   console.log('[PDF_PARSE] Starting extraction')
 63:   console.log('[PDF_PARSE] Buffer size:', buffer.length, 'bytes')
 64:   console.log('[PDF_PARSE] Buffer type:', typeof buffer)
 65:   console.log('[PDF_PARSE] Is Buffer:', Buffer.isBuffer(buffer))
 66:   console.log('[PDF_PARSE] ==========================================')
 67:   
 68:   // Try Method 1: pdf-parse-debugging-disabled (MOST RELIABLE)
 69:   try {
 70:     console.log('[PDF_PARSE] 🔄 Method 1: pdf-parse-debugging-disabled')
 71:     const pdfParse = await import('pdf-parse-debugging-disabled')
 72:     console.log('[PDF_PARSE] Module loaded:', !!pdfParse, 'default:', !!pdfParse.default)
 73:     
 74:     const data = await pdfParse.default(buffer, { 
 75:       max: 0, // Parse all pages
 76:       version: 'v2.0.550' // Specify version
 77:     })
 78:     
 79:     console.log('[PDF_PARSE] Raw result:', {
 80:       hasData: !!data,
 81:       hasText: !!data?.text,
 82:       textLength: data?.text?.length || 0,
 83:       numpages: data?.numpages,
 84:       numrender: data?.numrender,
 85:       info: data?.info,
 86:       metadata: data?.metadata
 87:     })
 88:     
 89:     if (data?.text) {
 90:       console.log('[PDF_PARSE] Raw text preview (first 500 chars):', data.text.slice(0, 500))
 91:       console.log('[PDF_PARSE] Raw text preview (last 200 chars):', data.text.slice(-200))
 92:       
 93:       const cleanedText = cleanExtractedText(data.text)
 94:       console.log('[PDF_PARSE] After cleaning:', {
 95:         rawLength: data.text.length,
 96:         cleanedLength: cleanedText.length,
 97:         preview: cleanedText.slice(0, 300)
 98:       })
 99:       
100:       if (cleanedText.length >= 50) {
101:         const confidence = cleanedText.length >= MIN_VALID_PDF_TEXT_LENGTH ? 0.95 : 0.6
102:         console.log('[PDF_PARSE] ✅✅✅ Method 1 SUCCESS - confidence:', confidence)
103:         return {
104:           text: cleanedText,
105:           method: 'pdf-parse',
106:           confidence
107:         }
108:       } else {
109:         console.log('[PDF_PARSE] ⚠️ Method 1 extracted text but too short:', cleanedText.length, 'chars')
110:       }
111:     } else {
112:       console.log('[PDF_PARSE] ⚠️ Method 1 returned no text')
113:     }
114:   } catch (error: any) {
115:     console.error('[PDF_PARSE] ❌ Method 1 FAILED')
116:     console.error('[PDF_PARSE] Error type:', error?.constructor?.name)
117:     console.error('[PDF_PARSE] Error message:', error?.message)
118:     console.error('[PDF_PARSE] Error stack:', error?.stack)
119:   }
120: 
121:   // Try Method 2: pdfjs-dist fallback (BETTER for complex PDFs)
122:   try {
123:     console.log('[PDF_PARSE] 🔄 Method 2: pdfjs-dist')
124:     const pdfjsLib = await import('pdfjs-dist')
125:     console.log('[PDF_PARSE] pdfjs-dist module loaded')
126:     
127:     // Load the PDF document with proper TypeScript types
128:     const loadingTask = pdfjsLib.getDocument({
129:       data: new Uint8Array(buffer),
130:       verbosity: 0,
131:       useSystemFonts: true,
132:       disableFontFace: false,
133:       standardFontDataUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/standard_fonts/'
134:     })
135:     
136:     const pdfDoc = await loadingTask.promise
137:     console.log('[PDF_PARSE] Document loaded successfully')
138:     console.log('[PDF_PARSE] Pages:', pdfDoc.numPages)
139:     console.log('[PDF_PARSE] Fingerprints:', pdfDoc.fingerprints)
140:     
141:     let fullText = ''
142:     let totalChars = 0
143:     
144:     // Extract text from each page
145:     for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
146:       try {
147:         const page = await pdfDoc.getPage(pageNum)
148:         const textContent = await page.getTextContent()
149:         
150:         // Better text extraction with spacing
151:         const pageText = textContent.items
152:           .map((item: any) => {
153:             if ('str' in item && item.str) {
154:               return item.str
155:             }
156:             return ''
157:           })
158:           .filter(Boolean)
159:           .join(' ')
160:         
161:         fullText += pageText + '\n\n'
162:         totalChars += pageText.length
163:         console.log(`[PDF_PARSE] Page ${pageNum}/${pdfDoc.numPages}: ${pageText.length} chars (total: ${totalChars})`)
164:       } catch (pageError) {
165:         console.error(`[PDF_PARSE] Error on page ${pageNum}:`, pageError)
166:       }
167:     }
168:     
169:     console.log('[PDF_PARSE] Raw extraction complete:', fullText.length, 'chars')
170:     console.log('[PDF_PARSE] Raw text preview:', fullText.slice(0, 500))
171:     
172:     const cleanedText = cleanExtractedText(fullText.trim())
173:     console.log('[PDF_PARSE] After cleaning:', {
174:       rawLength: fullText.length,
175:       cleanedLength: cleanedText.length,
176:       preview: cleanedText.slice(0, 300)
177:     })
178:     
179:     if (cleanedText.length >= 50) {
180:       const confidence = cleanedText.length >= MIN_VALID_PDF_TEXT_LENGTH ? 0.9 : 0.6
181:       console.log('[PDF_PARSE] ✅✅✅ Method 2 SUCCESS - confidence:', confidence)
182:       return {
183:         text: cleanedText,
184:         method: 'pdfjs-dist',
185:         confidence
186:       }
187:     } else {
188:       console.log('[PDF_PARSE] ⚠️ Method 2 extracted text but too short:', cleanedText.length, 'chars')
189:     }
190:   } catch (error: any) {
191:     console.error('[PDF_PARSE] ❌ Method 2 FAILED')
192:     console.error('[PDF_PARSE] Error type:', error?.constructor?.name)
193:     console.error('[PDF_PARSE] Error message:', error?.message)
194:     console.error('[PDF_PARSE] Error stack:', error?.stack)
195:   }
196: 
197:   // Try Method 3: AI-based extraction (BEST for scanned/image PDFs)
198:   try {
199:     console.log('[PDF_PARSE] Attempting Method 3: AI extraction')
200:     const aiText = await extractTextWithAI(buffer)
201:     
202:     if (aiText && aiText.length >= MIN_VALID_PDF_TEXT_LENGTH) {
203:       const cleanedText = cleanExtractedText(aiText)
204:       console.log('[PDF_PARSE] ✅ Method 3 SUCCESS (AI extraction):', cleanedText.length, 'chars')
205:       
206:       return {
207:         text: cleanedText,
208:         method: 'ai-extraction',
209:         confidence: 0.8
210:       }
211:     }
212:   } catch (error) {
213:     console.error('[PDF_PARSE] ❌ Method 3 failed:', error)
214:   }
215: 
216:   // All methods failed
217:   console.error('[PDF_PARSE] ❌❌❌ ALL EXTRACTION METHODS FAILED')
218:   return {
219:     text: '',
220:     method: 'all-methods-failed',
221:     confidence: 0
222:   }
223: }
224: 
225: export const runtime = 'nodejs'
226: export const dynamic = 'force-dynamic'
227: 
228: export async function POST(request: NextRequest) {
229:   const startTime = Date.now()
230:   console.log('[RESUME_UPLOAD] ========== NEW UPLOAD REQUEST ==========')
231:   
232:   try {
233:     await dbService.connect()
234: 
235:     const session = await getServerSession(authOptions)
236:     if (!session?.user?.id) {
237:       console.log('[RESUME_UPLOAD] ❌ Unauthorized')
238:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
239:     }
240:     
241:     console.log('[RESUME_UPLOAD] User:', session.user.id, session.user.email)
242: 
243:     if (await isRateLimited(session.user.id, 'resume:upload')) {
244:       console.log('[RESUME_UPLOAD] ❌ Rate limited')
245:       return NextResponse.json({ error: 'Rate limited' }, { status: 429 })
246:     }
247: 
248:     const data = await request.formData()
249:     const file = data.get('file') as File
250:     const pastedText = data.get('pastedText') as string
251:     
252:     console.log('[RESUME_UPLOAD] Upload type:', {
253:       hasFile: !!file,
254:       fileSize: file?.size,
255:       fileName: file?.name,
256:       hasPastedText: !!pastedText,
257:       pastedTextLength: pastedText?.length
258:     })
259: 
260:     if (!file && !pastedText) {
261:       console.log('[RESUME_UPLOAD] ❌ No file or text provided')
262:       return NextResponse.json({ error: 'No file or text provided' }, { status: 400 })
263:     }
264: 
265:     let extractedText = ''
266:     let extractionMethod = ''
267:     let extractionError = ''
268:     let extractionConfidence = 0.95
269: 
270:     if (file && file.size > 0) {
271:       // Validate file size and type
272:       if (file.size > 10 * 1024 * 1024) {
273:         return NextResponse.json({ error: 'File too large' }, { status: 400 })
274:       }
275: 
276:       const buffer = Buffer.from(await file.arrayBuffer())
277:       const filename = file.name || 'resume.pdf'
278: 
279:       if (path.extname(filename).toLowerCase() === '.pdf') {
280:         try {
281:           const { text, method, confidence } = await extractTextFromPDF(buffer)
282:           extractedText = text
283:           extractionMethod = method
284:           extractionConfidence = confidence || 0.95
285:           
286:           // Enhanced logging
287:           console.log('🔍 PDF Processing Result:', {
288:             filename,
289:             method: extractionMethod,
290:             textLength: extractedText?.length,
291:             confidence: extractionConfidence,
292:             firstWords: extractedText?.slice(0, 100)
293:           })
294:           
295:           if (!text || text.length < MIN_VALID_PDF_TEXT_LENGTH) {
296:             extractionError = 'PDF text extraction was incomplete. Please paste your resume content instead.'
297:           }
298:         } catch (pdfError) {
299:           console.error('PDF processing failed completely:', pdfError)
300:           extractionError = 'PDF processing failed. Please paste your resume text or try a different file format.'
301:           extractionMethod = 'pdf-failed'
302:         }
303:       } else {
304:         extractedText = await file.text()
305:         extractionMethod = 'direct_text'
306:         extractionConfidence = 1.0
307:       }
308:     } else if (pastedText) {
309:       extractedText = pastedText
310:       extractionMethod = 'pasted_text'
311:     }
312: 
313:     extractedText = cleanExtractedText(extractedText || '')
314: 
315:     const asciiFallbackUsed = extractionMethod === 'ascii-fallback'
316: 
317:     if (asciiFallbackUsed) {
318:       extractionError = extractionError || 'PDF could not be reliably processed (ASCII fallback). Please paste your resume text instead.'
319:       extractionConfidence = Math.min(extractionConfidence, ASCII_FALLBACK_CONFIDENCE)
320:     }
321: 
322:     if (!extractedText || extractedText.length < MIN_VALID_PDF_TEXT_LENGTH) {
323:       return NextResponse.json({ 
324:         error: 'No readable content', 
325:         details: extractionError || 'Could not extract text from the file. Please paste your resume text instead.',
326:         extractionMethod 
327:       }, { status: 400 })
328:     }
329: 
330:     if (asciiFallbackUsed) {
331:       return NextResponse.json({
332:         error: 'Resume quality too low',
333:         details: extractionError,
334:         extractionMethod,
335:         confidence: extractionConfidence
336:       }, { status: 400 })
337:     }
338: 
339:     // CRITICAL FIX: Extract location and keywords from resume text
340:     console.log('═══════════════════════════════════════════════════════')
341:     console.log('[PDF UPLOAD] EXTRACTING RESUME SIGNALS (Location + Keywords)')
342:     console.log('═══════════════════════════════════════════════════════')
343:     console.log('[PDF UPLOAD] Resume text length:', extractedText.length, 'chars')
344:     console.log('[PDF UPLOAD] First 300 chars:', extractedText.substring(0, 300))
345:     console.log('─────────────────────────────────────────────────────────')
346: 
347:     // NOTE: Old signal extraction removed - now handled by EnhancedResumeExtractor in ProfileMapper
348:     // This provides better weighting, confidence scores, and structured data
349:     console.log('[PDF UPLOAD] Resume text ready, profile will be created after save...')
350: 
351:     const resume = new Resume({
352:       userId: session.user.id,
353:       originalFileName: file?.name || 'pasted-resume.txt',
354:       filename: file?.name || 'pasted-resume.txt',
355:       extractedText,
356:       extractionMethod,
357:       extractionError: extractionError || undefined,
358:       uploadedAt: new Date()
359:     })
360: 
361:     await resume.save()
362:     
363:     // Create/update user profile from resume
364:     try {
365:       const { ProfileMapper } = await import('@/lib/profile-mapper')
366:       const profileResult = await ProfileMapper.mapResumeToProfile(
367:         session.user.id,
368:         resume._id.toString()
369:       )
370:       
371:       if (profileResult.success) {
372:         console.log('[RESUME_UPLOAD] ✅ Profile created/updated:', {
373:           completeness: profileResult.profile?.profileCompleteness,
374:           location: profileResult.profile?.location,
375:           warnings: profileResult.warnings
376:         })
377:       } else {
378:         console.error('[RESUME_UPLOAD] ⚠️ Profile creation failed:', profileResult.errors)
379:       }
380:     } catch (profileError) {
381:       // Don't fail the upload if profile creation fails
382:       console.error('[RESUME_UPLOAD] ⚠️ Profile mapping error:', profileError)
383:     }
384:     
385:     const duration = Date.now() - startTime
386:     console.log('[RESUME_UPLOAD] ✅ SUCCESS:', {
387:       resumeId: resume._id.toString(),
388:       textLength: extractedText.length,
389:       method: extractionMethod,
390:       confidence: extractionConfidence,
391:       durationMs: duration
392:     })
393: 
394:     return NextResponse.json({
395:       success: true,
396:       resume: {
397:         _id: resume._id.toString(),
398:         userId: resume.userId,
399:         originalFileName: resume.originalFileName,
400:         filename: resume.filename,
401:         extractedText: resume.extractedText,
402:         extractionMethod: resume.extractionMethod,
403:         uploadedAt: resume.uploadedAt,
404:         metadata: resume.metadata
405:       },
406:       resumeId: resume._id,
407:       extractedText: extractedText.substring(0, 500) + (extractedText.length > 500 ? '...' : ''),
408:       extractionMethod,
409:       extractionError,
410:       confidence: extractionConfidence,
411:       // Profile will be created automatically with enhanced extraction
412:       message: 'Resume uploaded successfully. Profile is being created with enhanced extraction.'
413:     })
414:   } catch (error) {
415:     console.error('Upload error:', error)
416:     const errorMessage = error instanceof Error ? error.message : 'Internal server error'
417:     
418:     // Provide helpful error messages based on error type
419:     let userMessage = 'Failed to process resume'
420:     let helpText = 'Please try again or paste your resume text directly.'
421:     
422:     if (errorMessage.includes('validation')) {
423:       userMessage = 'Invalid resume data'
424:       helpText = 'Please ensure your resume contains valid text.'
425:     } else if (errorMessage.includes('database') || errorMessage.includes('mongo')) {
426:       userMessage = 'Database connection error'
427:       helpText = 'Please try again in a moment.'
428:     } else if (errorMessage.includes('memory') || errorMessage.includes('heap')) {
429:       userMessage = 'File too complex to process'
430:       helpText = 'Try a simpler PDF or paste your text instead.'
431:     }
432:     
433:     return NextResponse.json({ 
434:       error: userMessage,
435:       details: helpText,
436:       technical: process.env.NODE_ENV === 'development' ? errorMessage : undefined
437:     }, { status: 500 })
438:   }
439: }
</file>

<file path="src/app/api/salary/generate/route.ts">
  1: import { NextRequest, NextResponse } from 'next/server'
  2: import { getServerSession } from 'next-auth'
  3: import { authOptions } from '@/lib/auth'
  4: import dbConnect from '@/lib/mongodb'
  5: import Application from '@/models/Application'
  6: import { PerplexityIntelligenceService } from '@/lib/perplexity-intelligence'
  7: 
  8: export async function POST(req: NextRequest) {
  9:   try {
 10:     const session = await getServerSession(authOptions)
 11:     if (!session?.user?.id) {
 12:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
 13:     }
 14: 
 15:     const { applicationId, yearsExperience } = await req.json()
 16:     
 17:     if (!applicationId) {
 18:       return NextResponse.json({ error: 'Application ID required' }, { status: 400 })
 19:     }
 20: 
 21:     await dbConnect()
 22: 
 23:     const application = await Application.findOne({ 
 24:       _id: applicationId, 
 25:       userId: session.user.id 
 26:     })
 27: 
 28:     if (!application) {
 29:       return NextResponse.json({ error: 'Application not found' }, { status: 404 })
 30:     }
 31: 
 32:     console.log('[SALARY] 💰 Generating salary data for:', application.company, '-', application.jobTitle)
 33: 
 34:     // Generate salary benchmarks using AI
 35:     const prompt = `Provide current market salary data for this role:
 36: 
 37: ROLE: ${application.jobTitle}
 38: COMPANY: ${application.company}
 39: LOCATION: ${application.location || 'United States'}
 40: EXPERIENCE: ${yearsExperience || 5} years
 41: 
 42: Return JSON with:
 43: {
 44:   "marketMin": 75000,
 45:   "marketMedian": 95000,
 46:   "marketMax": 120000,
 47:   "negotiationTips": [
 48:     "Research shows the market range for ${application.jobTitle} in ${application.location || 'this area'} is $X-$Y",
 49:     "Based on your X years of experience, you should target the upper end of the range",
 50:     "Emphasize your unique skills: [specific skills]",
 51:     "Wait for them to give the first number",
 52:     "Consider total compensation: equity, bonuses, benefits"
 53:   ],
 54:   "factors": "Explanation of what influences this salary range"
 55: }
 56: 
 57: Use real market data from 2024-2025. Be specific to the location and seniority level.`
 58: 
 59:     const response = await PerplexityIntelligenceService.customQuery({
 60:       systemPrompt: 'You are a salary negotiation expert providing market data. Return valid JSON only.',
 61:       userPrompt: prompt,
 62:       temperature: 0.3,
 63:       maxTokens: 1500
 64:     })
 65: 
 66:     let salaryData
 67:     try {
 68:       salaryData = JSON.parse(response.content)
 69:     } catch {
 70:       // Fallback with estimated data
 71:       const baseMin = 60000
 72:       const baseMedian = 85000
 73:       const baseMax = 110000
 74:       
 75:       salaryData = {
 76:         marketMin: baseMin,
 77:         marketMedian: baseMedian,
 78:         marketMax: baseMax,
 79:         negotiationTips: [
 80:           `Research shows the market range for ${application.jobTitle} is $${baseMin.toLocaleString()}-$${baseMax.toLocaleString()}`,
 81:           'Emphasize your unique skills and achievements',
 82:           'Wait for them to give the first number',
 83:           'Consider total compensation: equity, bonuses, benefits',
 84:           'Be prepared to justify your target with market data'
 85:         ],
 86:         factors: 'Based on industry standards and location'
 87:       }
 88:     }
 89: 
 90:     // Calculate user target (aim for 75th percentile)
 91:     const userTarget = Math.round(salaryData.marketMedian * 1.15)
 92: 
 93:     // Save to application
 94:     application.salaryData = {
 95:       marketMin: salaryData.marketMin,
 96:       marketMedian: salaryData.marketMedian,
 97:       marketMax: salaryData.marketMax,
 98:       userTarget,
 99:       negotiationTips: salaryData.negotiationTips,
100:       preparedAt: new Date()
101:     }
102:     await application.save()
103: 
104:     console.log('[SALARY] ✅ Generated salary range:', salaryData.marketMin, '-', salaryData.marketMax)
105: 
106:     return NextResponse.json({
107:       success: true,
108:       salary: {
109:         marketMin: salaryData.marketMin,
110:         marketMedian: salaryData.marketMedian,
111:         marketMax: salaryData.marketMax,
112:         userTarget,
113:         negotiationTips: salaryData.negotiationTips,
114:         factors: salaryData.factors,
115:         company: application.company,
116:         jobTitle: application.jobTitle,
117:         location: application.location
118:       }
119:     })
120:   } catch (error) {
121:     console.error('[SALARY] ❌ Error:', error)
122:     return NextResponse.json({ 
123:       error: 'Failed to generate salary data',
124:       details: error instanceof Error ? error.message : 'Unknown error'
125:     }, { status: 500 })
126:   }
127: }
</file>

<file path="src/lib/enhanced-resume-extractor.ts">
  1: /**
  2:  * Enhanced Resume Extractor with Intelligent Weighting
  3:  * 
  4:  * Extracts and weights:
  5:  * - Skills (by recency, frequency, and context)
  6:  * - Location (with fallbacks and validation)
  7:  * - Work experience (with duration weighting)
  8:  * - Education (with relevance scoring)
  9:  * - Keywords (with TF-IDF-like scoring)
 10:  */
 11: 
 12: import { PerplexityIntelligenceService } from './perplexity-intelligence'
 13: 
 14: export interface WeightedSkill {
 15:   skill: string
 16:   weight: number
 17:   sources: ('work_experience' | 'education' | 'certifications' | 'summary')[]
 18:   yearsUsed?: number
 19:   lastUsed?: Date
 20:   frequency: number
 21: }
 22: 
 23: export interface ExtractedWorkExperience {
 24:   company: string
 25:   title: string
 26:   location?: string
 27:   startDate: Date
 28:   endDate?: Date
 29:   isCurrent: boolean
 30:   description: string
 31:   achievements: string[]
 32:   skills: string[]
 33:   durationYears: number
 34:   recencyScore: number // 0-1, higher = more recent
 35: }
 36: 
 37: export interface ExtractedEducation {
 38:   institution: string
 39:   degree: string
 40:   field: string
 41:   startDate: Date
 42:   endDate?: Date
 43:   relevanceScore: number // 0-1, based on field match to target roles
 44: }
 45: 
 46: export interface EnhancedResumeData {
 47:   // Personal Info
 48:   name: string
 49:   email: string
 50:   phone?: string
 51:   linkedin?: string
 52:   
 53:   // Location (with confidence)
 54:   location: {
 55:     city: string
 56:     province: string
 57:     country: string
 58:     confidence: number // 0-1
 59:     source: 'header' | 'work_experience' | 'inferred'
 60:   }
 61:   
 62:   // Weighted Skills
 63:   skills: WeightedSkill[]
 64:   topSkills: string[] // Top 20 by weight
 65:   
 66:   // Work Experience (sorted by recency)
 67:   workExperience: ExtractedWorkExperience[]
 68:   totalYearsExperience: number
 69:   
 70:   // Education
 71:   education: ExtractedEducation[]
 72:   
 73:   // Career Summary
 74:   currentRole?: string
 75:   targetRoles: string[]
 76:   industries: string[]
 77:   
 78:   // Metadata
 79:   extractionQuality: number // 0-1
 80:   warnings: string[]
 81: }
 82: 
 83: export class EnhancedResumeExtractor {
 84:   /**
 85:    * Extract and weight all resume data
 86:    */
 87:   static async extract(resumeText: string): Promise<EnhancedResumeData> {
 88:     console.log('[ENHANCED_EXTRACTOR] Starting extraction...')
 89:     
 90:     const warnings: string[] = []
 91:     
 92:     // Use Perplexity with enhanced prompt
 93:     const extracted = await this.extractWithPerplexity(resumeText)
 94:     
 95:     // Calculate skill weights
 96:     const weightedSkills = this.calculateSkillWeights(
 97:       extracted.skills,
 98:       extracted.workExperience,
 99:       extracted.education
100:     )
101:     
102:     // Calculate recency scores for work experience
103:     const scoredExperience = this.scoreWorkExperience(extracted.workExperience)
104:     
105:     // Validate and score location
106:     const location = this.validateLocation(extracted.location, scoredExperience)
107:     if (location.confidence < 0.7) {
108:       warnings.push(`Location confidence low (${Math.round(location.confidence * 100)}%)`)
109:     }
110:     
111:     // Calculate total years of experience
112:     const totalYears = scoredExperience.reduce((sum, exp) => sum + exp.durationYears, 0)
113:     
114:     // Score education relevance
115:     const scoredEducation = this.scoreEducation(extracted.education, weightedSkills)
116:     
117:     // Infer target roles from experience
118:     const targetRoles = this.inferTargetRoles(scoredExperience, weightedSkills)
119:     
120:     // Extract industries
121:     const industries = this.extractIndustries(scoredExperience)
122:     
123:     // Calculate extraction quality
124:     const quality = this.calculateExtractionQuality({
125:       hasName: !!extracted.name,
126:       hasEmail: !!extracted.email,
127:       hasLocation: location.confidence > 0.5,
128:       workExpCount: scoredExperience.length,
129:       educationCount: scoredEducation.length,
130:       skillCount: weightedSkills.length
131:     })
132:     
133:     if (quality < 0.7) {
134:       warnings.push(`Extraction quality low (${Math.round(quality * 100)}%)`)
135:     }
136:     
137:     console.log('[ENHANCED_EXTRACTOR] Extraction complete:', {
138:       skills: weightedSkills.length,
139:       topSkills: weightedSkills.slice(0, 20).map(s => s.skill),
140:       workExp: scoredExperience.length,
141:       education: scoredEducation.length,
142:       location: `${location.city}, ${location.province}`,
143:       locationConfidence: Math.round(location.confidence * 100) + '%',
144:       quality: Math.round(quality * 100) + '%'
145:     })
146:     
147:     return {
148:       name: extracted.name,
149:       email: extracted.email,
150:       phone: extracted.phone,
151:       linkedin: extracted.linkedin,
152:       location,
153:       skills: weightedSkills,
154:       topSkills: weightedSkills.slice(0, 20).map(s => s.skill),
155:       workExperience: scoredExperience,
156:       totalYearsExperience: totalYears,
157:       education: scoredEducation,
158:       currentRole: scoredExperience.find(e => e.isCurrent)?.title,
159:       targetRoles,
160:       industries,
161:       extractionQuality: quality,
162:       warnings
163:     }
164:   }
165:   
166:   /**
167:    * Extract data using Perplexity with enhanced prompt
168:    */
169:   private static async extractWithPerplexity(resumeText: string): Promise<any> {
170:     const prompt = `ANALYZE THIS RESUME AND EXTRACT ALL DATA WITH CONTEXT
171: 
172: RESUME TEXT:
173: ${resumeText}
174: 
175: EXTRACT:
176: 
177: 1. PERSONAL INFO:
178:    - Full name
179:    - Email
180:    - Phone
181:    - LinkedIn URL
182: 
183: 2. LOCATION (CRITICAL):
184:    - Look in: header, contact section, current address
185:    - Format: "City, PROVINCE" (e.g., "Edmonton, AB")
186:    - If only country found, mark confidence as low
187:    - If multiple locations, use most recent
188: 
189: 3. WORK EXPERIENCE (for each job):
190:    - Company name
191:    - Job title
192:    - Location
193:    - Start date (YYYY-MM format)
194:    - End date (YYYY-MM or "Present")
195:    - Description (full text)
196:    - Key achievements (bullet points)
197:    - Skills used (extract from description)
198:    - Calculate duration in years
199: 
200: 4. EDUCATION (for each degree):
201:    - Institution
202:    - Degree type
203:    - Field of study
204:    - Start date
205:    - End date (or "Present")
206: 
207: 5. SKILLS:
208:    - Technical skills
209:    - Soft skills
210:    - Languages
211:    - Tools/platforms
212:    - Certifications
213: 
214: RETURN STRICT JSON:
215: {
216:   "name": "Full Name",
217:   "email": "email@example.com",
218:   "phone": "555-1234",
219:   "linkedin": "linkedin.com/in/username",
220:   "location": {
221:     "city": "Edmonton",
222:     "province": "AB",
223:     "country": "Canada",
224:     "confidence": 0.9
225:   },
226:   "workExperience": [
227:     {
228:       "company": "Company Name",
229:       "title": "Job Title",
230:       "location": "City, Province",
231:       "startDate": "2020-01",
232:       "endDate": "2023-06",
233:       "isCurrent": false,
234:       "description": "Full description...",
235:       "achievements": ["Achievement 1", "Achievement 2"],
236:       "skills": ["Skill 1", "Skill 2"]
237:     }
238:   ],
239:   "education": [
240:     {
241:       "institution": "University Name",
242:       "degree": "Bachelor of Science",
243:       "field": "Computer Science",
244:       "startDate": "2016-09",
245:       "endDate": "2020-05"
246:     }
247:   ],
248:   "skills": {
249:     "technical": ["JavaScript", "Python"],
250:     "soft": ["Leadership", "Communication"],
251:     "languages": ["English", "French"],
252:     "tools": ["Git", "Docker"]
253:   }
254: }`
255: 
256:     const response = await PerplexityIntelligenceService.customQuery({
257:       systemPrompt: 'You are a resume parser. Extract ALL data from the resume. Return ONLY valid JSON.',
258:       userPrompt: prompt,
259:       temperature: 0.1,
260:       maxTokens: 4000
261:     })
262:     
263:     // Parse JSON
264:     let cleaned = response.content.trim()
265:     cleaned = cleaned.replace(/^```(?:json)?\s*/gm, '').replace(/```\s*$/gm, '')
266:     const jsonMatch = cleaned.match(/(\{[\s\S]*\})/)
267:     if (jsonMatch) cleaned = jsonMatch[0]
268:     
269:     return JSON.parse(cleaned)
270:   }
271:   
272:   /**
273:    * Calculate skill weights based on recency, frequency, and context
274:    */
275:   private static calculateSkillWeights(
276:     skills: any,
277:     workExperience: any[],
278:     education: any[]
279:   ): WeightedSkill[] {
280:     const skillMap = new Map<string, WeightedSkill>()
281:     
282:     // Weight from work experience (highest weight)
283:     workExperience.forEach((exp, index) => {
284:       const recencyWeight = 1 - (index * 0.1) // More recent = higher weight
285:       const durationWeight = Math.min(exp.durationYears / 5, 1) // Cap at 5 years
286:       
287:       exp.skills?.forEach((skill: string) => {
288:         const existing = skillMap.get(skill.toLowerCase())
289:         if (existing) {
290:           existing.weight += recencyWeight * durationWeight * 10
291:           existing.frequency++
292:           existing.sources.push('work_experience')
293:           if (!existing.yearsUsed) existing.yearsUsed = 0
294:           existing.yearsUsed += exp.durationYears
295:         } else {
296:           skillMap.set(skill.toLowerCase(), {
297:             skill,
298:             weight: recencyWeight * durationWeight * 10,
299:             sources: ['work_experience'],
300:             yearsUsed: exp.durationYears,
301:             lastUsed: exp.isCurrent ? new Date() : new Date(exp.endDate),
302:             frequency: 1
303:           })
304:         }
305:       })
306:     })
307:     
308:     // Weight from education (medium weight)
309:     education.forEach(edu => {
310:       const eduSkills = [edu.field, edu.degree]
311:       eduSkills.forEach(skill => {
312:         if (!skill) return
313:         const existing = skillMap.get(skill.toLowerCase())
314:         if (existing) {
315:           existing.weight += 3
316:           existing.frequency++
317:           existing.sources.push('education')
318:         } else {
319:           skillMap.set(skill.toLowerCase(), {
320:             skill,
321:             weight: 3,
322:             sources: ['education'],
323:             frequency: 1
324:           })
325:         }
326:       })
327:     })
328:     
329:     // Add technical/soft skills (base weight)
330:     Object.entries(skills || {}).forEach(([category, skillList]: [string, any]) => {
331:       (skillList || []).forEach((skill: string) => {
332:         const existing = skillMap.get(skill.toLowerCase())
333:         if (existing) {
334:           existing.weight += 1
335:           existing.frequency++
336:         } else {
337:           skillMap.set(skill.toLowerCase(), {
338:             skill,
339:             weight: 1,
340:             sources: [category as any],
341:             frequency: 1
342:           })
343:         }
344:       })
345:     })
346:     
347:     // Sort by weight
348:     return Array.from(skillMap.values())
349:       .sort((a, b) => b.weight - a.weight)
350:   }
351:   
352:   /**
353:    * Score work experience by recency
354:    */
355:   private static scoreWorkExperience(experiences: any[]): ExtractedWorkExperience[] {
356:     return experiences.map((exp, index) => {
357:       const start = new Date(exp.startDate)
358:       const end = exp.endDate ? new Date(exp.endDate) : new Date()
359:       const durationYears = (end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24 * 365)
360:       
361:       // Recency score: 1.0 for current, decreasing for older roles
362:       const recencyScore = exp.isCurrent ? 1.0 : Math.max(0.1, 1 - (index * 0.15))
363:       
364:       return {
365:         ...exp,
366:         startDate: start,
367:         endDate: exp.endDate ? end : undefined,
368:         durationYears: Math.round(durationYears * 10) / 10,
369:         recencyScore
370:       }
371:     }).sort((a, b) => b.recencyScore - a.recencyScore)
372:   }
373:   
374:   /**
375:    * Validate and score location
376:    */
377:   private static validateLocation(location: any, workExperience: ExtractedWorkExperience[]): any {
378:     if (!location) {
379:       // Try to infer from most recent work experience
380:       const recentExp = workExperience.find(e => e.location)
381:       if (recentExp?.location) {
382:         const match = recentExp.location.match(/([^,]+),\s*([A-Z]{2})/)
383:         if (match) {
384:           return {
385:             city: match[1],
386:             province: match[2],
387:             country: 'Canada',
388:             confidence: 0.6,
389:             source: 'work_experience'
390:           }
391:         }
392:       }
393:       return {
394:         city: 'Unknown',
395:         province: 'Unknown',
396:         country: 'Canada',
397:         confidence: 0.1,
398:         source: 'inferred'
399:       }
400:     }
401:     
402:     return {
403:       ...location,
404:       confidence: location.confidence || 0.9,
405:       source: 'header'
406:     }
407:   }
408:   
409:   /**
410:    * Score education by relevance to skills
411:    */
412:   private static scoreEducation(education: any[], skills: WeightedSkill[]): ExtractedEducation[] {
413:     return education.map(edu => {
414:       // Check if education field matches top skills
415:       const relevantSkills = skills.filter(s => 
416:         s.skill.toLowerCase().includes(edu.field?.toLowerCase()) ||
417:         edu.field?.toLowerCase().includes(s.skill.toLowerCase())
418:       )
419:       
420:       const relevanceScore = Math.min(relevantSkills.length / 5, 1)
421:       
422:       return {
423:         ...edu,
424:         startDate: new Date(edu.startDate),
425:         endDate: edu.endDate ? new Date(edu.endDate) : undefined,
426:         relevanceScore
427:       }
428:     })
429:   }
430:   
431:   /**
432:    * Infer target roles from experience
433:    */
434:   private static inferTargetRoles(experience: ExtractedWorkExperience[], skills: WeightedSkill[]): string[] {
435:     const roles = new Set<string>()
436:     
437:     // Add current/most recent role
438:     if (experience[0]) {
439:       roles.add(experience[0].title)
440:     }
441:     
442:     // Add senior version of current role
443:     if (experience[0] && !experience[0].title.toLowerCase().includes('senior')) {
444:       roles.add(`Senior ${experience[0].title}`)
445:     }
446:     
447:     return Array.from(roles)
448:   }
449:   
450:   /**
451:    * Extract industries from work experience
452:    */
453:   private static extractIndustries(experience: ExtractedWorkExperience[]): string[] {
454:     // This would ideally use a company-to-industry mapping
455:     // For now, return unique company names
456:     return [...new Set(experience.map(e => e.company))]
457:   }
458:   
459:   /**
460:    * Calculate overall extraction quality
461:    */
462:   private static calculateExtractionQuality(metrics: {
463:     hasName: boolean
464:     hasEmail: boolean
465:     hasLocation: boolean
466:     workExpCount: number
467:     educationCount: number
468:     skillCount: number
469:   }): number {
470:     let score = 0
471:     
472:     if (metrics.hasName) score += 0.2
473:     if (metrics.hasEmail) score += 0.2
474:     if (metrics.hasLocation) score += 0.2
475:     if (metrics.workExpCount > 0) score += 0.2
476:     if (metrics.educationCount > 0) score += 0.1
477:     if (metrics.skillCount >= 10) score += 0.1
478:     
479:     return score
480:   }
481: }
482: 
483: export default EnhancedResumeExtractor
</file>

<file path="src/lib/keyword-extraction.ts">
  1: /**
  2:  * Enhanced Keyword Extraction with Multi-Factor Weighting
  3:  * Extracts 50+ keywords and applies recency, tenure, industry, and seniority multipliers
  4:  */
  5: 
  6: export interface WeightedKeyword {
  7:   keyword: string
  8:   weight: number
  9:   sources: string[] // Which roles it came from
 10:   recency: number // How recent (0.5x - 2x)
 11:   tenure: number // Years in roles using this skill
 12: }
 13: 
 14: export interface ResumeRole {
 15:   title: string
 16:   company: string
 17:   startDate: Date
 18:   endDate: Date | null
 19:   duration: number // years
 20:   description: string
 21:   industry: string
 22:   isCurrent: boolean
 23: }
 24: 
 25: export interface KeywordExtractionResult {
 26:   keywords: WeightedKeyword[]
 27:   topKeywords: string[] // Top 18 for search
 28:   allKeywords: string[] // All 50+ for reference
 29:   metadata: {
 30:     totalKeywords: number
 31:     primaryIndustry: string
 32:     experienceYears: number
 33:     dominantSkills: string[]
 34:     rolesAnalyzed: number
 35:   }
 36: }
 37: 
 38: /**
 39:  * Extract and weight keywords from resume
 40:  */
 41: export async function extractWeightedKeywords(
 42:   resumeText: string
 43: ): Promise<KeywordExtractionResult> {
 44:   console.log('[KEYWORD_EXTRACTION] Starting extraction, resume length:', resumeText.length)
 45:   
 46:   // 1. Parse resume structure to identify roles and tenure
 47:   const resumeStructure = parseResumeStructure(resumeText)
 48:   
 49:   console.log('[KEYWORD_EXTRACTION] Resume structure:', {
 50:     roles: resumeStructure.roles.length,
 51:     totalYears: resumeStructure.totalExperienceYears,
 52:     primaryIndustry: resumeStructure.primaryIndustry
 53:   })
 54:   
 55:   // 2. Extract raw keywords (simple frequency-based for now, can enhance with AI later)
 56:   const rawKeywords = extractRawKeywords(resumeText, resumeStructure)
 57:   
 58:   console.log('[KEYWORD_EXTRACTION] Raw keywords extracted:', rawKeywords.length)
 59:   
 60:   // 3. Weight keywords by multiple factors
 61:   const weightedKeywords = rawKeywords.map((keyword) => {
 62:     // Base weight from frequency
 63:     const baseWeight = 1.0
 64:     
 65:     // Recency multiplier (most recent role = 2x, oldest = 0.5x)
 66:     const recencyMultiplier = calculateRecencyMultiplier(keyword, resumeStructure)
 67:     
 68:     // Tenure multiplier (3+ years = 1.5x, < 1 year = 0.8x)
 69:     const tenureMultiplier = calculateTenureMultiplier(keyword, resumeStructure)
 70:     
 71:     // Industry multiplier (primary industry = 1.25x)
 72:     const industryMultiplier = calculateIndustryMultiplier(keyword, resumeStructure)
 73:     
 74:     // Role seniority multiplier (senior/lead roles = 1.2x)
 75:     const seniorityMultiplier = calculateSeniorityMultiplier(keyword, resumeStructure)
 76:     
 77:     // Final weight
 78:     const weight = baseWeight * recencyMultiplier * tenureMultiplier * industryMultiplier * seniorityMultiplier
 79:     
 80:     return {
 81:       keyword,
 82:       weight,
 83:       sources: findKeywordSources(keyword, resumeStructure),
 84:       recency: recencyMultiplier,
 85:       tenure: calculateKeywordTenure(keyword, resumeStructure)
 86:     }
 87:   })
 88:   
 89:   // 4. Sort by weight (descending)
 90:   weightedKeywords.sort((a, b) => b.weight - a.weight)
 91:   
 92:   console.log('[KEYWORD_EXTRACTION] Top 10 weighted keywords:')
 93:   weightedKeywords.slice(0, 10).forEach((kw, i) => {
 94:     console.log(`  ${i + 1}. ${kw.keyword} (weight: ${kw.weight.toFixed(2)}, recency: ${kw.recency.toFixed(2)}x)`)
 95:   })
 96:   
 97:   // 5. Select top 18 for search
 98:   const topKeywords = weightedKeywords.slice(0, 18).map(kw => kw.keyword)
 99:   
100:   // 6. Prepare metadata
101:   const metadata = {
102:     totalKeywords: weightedKeywords.length,
103:     primaryIndustry: resumeStructure.primaryIndustry,
104:     experienceYears: resumeStructure.totalExperienceYears,
105:     dominantSkills: weightedKeywords.slice(0, 5).map(kw => kw.keyword),
106:     rolesAnalyzed: resumeStructure.roles.length
107:   }
108:   
109:   return {
110:     keywords: weightedKeywords,
111:     topKeywords,
112:     allKeywords: weightedKeywords.map(kw => kw.keyword),
113:     metadata
114:   }
115: }
116: 
117: /**
118:  * Parse resume to identify roles, tenure, industries
119:  */
120: interface ResumeStructure {
121:   roles: ResumeRole[]
122:   totalExperienceYears: number
123:   primaryIndustry: string
124: }
125: 
126: function parseResumeStructure(resumeText: string): ResumeStructure {
127:   const roles: ResumeRole[] = []
128:   
129:   // Common date patterns
130:   const datePatterns = [
131:     /(\w+\s+\d{4})\s*[-–—]\s*(\w+\s+\d{4}|Present|Current)/gi,
132:     /(\d{4})\s*[-–—]\s*(\d{4}|Present|Current)/gi,
133:     /(\d{1,2}\/\d{4})\s*[-–—]\s*(\d{1,2}\/\d{4}|Present|Current)/gi
134:   ]
135:   
136:   // Split by common section headers
137:   const sections = resumeText.split(/(?:EXPERIENCE|WORK HISTORY|EMPLOYMENT|PROFESSIONAL EXPERIENCE)/i)
138:   const experienceSection = sections.length > 1 ? sections[1] : resumeText
139:   
140:   // Extract roles (simple heuristic)
141:   const lines = experienceSection.split('\n')
142:   let currentRole: Partial<ResumeRole> | null = null
143:   
144:   for (let i = 0; i < lines.length; i++) {
145:     const line = lines[i].trim()
146:     if (!line) continue
147:     
148:     // Check if this line contains a date range
149:     let dateMatch: RegExpMatchArray | null = null
150:     for (const pattern of datePatterns) {
151:       dateMatch = line.match(pattern)
152:       if (dateMatch) break
153:     }
154:     
155:     if (dateMatch) {
156:       // This might be a role header
157:       const [fullMatch, startStr, endStr] = dateMatch
158:       const startDate = parseDate(startStr)
159:       const endDate = endStr.match(/Present|Current/i) ? null : parseDate(endStr)
160:       const duration = calculateYearsBetween(startDate, endDate || new Date())
161:       
162:       // Extract title and company from the line
163:       const parts = line.replace(fullMatch, '').split(/[|,]/).map(p => p.trim()).filter(Boolean)
164:       
165:       if (currentRole && currentRole.title) {
166:         roles.push(currentRole as ResumeRole)
167:       }
168:       
169:       currentRole = {
170:         title: parts[0] || line.split(/[|,]/)[0]?.trim() || 'Unknown',
171:         company: parts[1] || 'Unknown',
172:         startDate,
173:         endDate,
174:         duration,
175:         description: '',
176:         industry: 'General',
177:         isCurrent: !endDate
178:       }
179:     } else if (currentRole) {
180:       // Add to current role description
181:       currentRole.description = (currentRole.description || '') + ' ' + line
182:     }
183:   }
184:   
185:   // Add last role
186:   if (currentRole && currentRole.title) {
187:     roles.push(currentRole as ResumeRole)
188:   }
189:   
190:   // Infer industries
191:   roles.forEach(role => {
192:     role.industry = inferIndustry(role.company, role.description)
193:   })
194:   
195:   // Calculate total experience
196:   const totalExperienceYears = roles.reduce((sum, role) => sum + role.duration, 0)
197:   
198:   // Identify primary industry (most time spent)
199:   const industryMap = new Map<string, number>()
200:   roles.forEach(role => {
201:     const current = industryMap.get(role.industry) || 0
202:     industryMap.set(role.industry, current + role.duration)
203:   })
204:   
205:   const primaryIndustry = Array.from(industryMap.entries())
206:     .sort((a, b) => b[1] - a[1])
207:     .map(([industry]) => industry)[0] || 'General'
208:   
209:   return {
210:     roles,
211:     totalExperienceYears,
212:     primaryIndustry
213:   }
214: }
215: 
216: /**
217:  * Extract raw keywords from resume text
218:  */
219: function extractRawKeywords(resumeText: string, structure: ResumeStructure): string[] {
220:   const keywords = new Set<string>()
221:   
222:   // Common skill keywords
223:   const skillPatterns = [
224:     /\b(Business Development|Sales|Marketing|Finance|Accounting|Engineering|Software|Development|Management|Leadership|Project Management|Operations|Strategy|Analytics|Data|CRM|ERP|SQL|Python|JavaScript|React|Node|AWS|Azure|Cloud|DevOps|Agile|Scrum|Lean|Six Sigma|Quality|Compliance|Risk|Audit|Legal|HR|Recruiting|Training|Customer Service|Support|Technical|Communication|Negotiation|Problem Solving|Team Building|Coaching|Mentoring|Planning|Budgeting|Forecasting|Reporting|Analysis|Research|Design|Architecture|Infrastructure|Security|Testing|QA|Documentation|Presentation|Public Speaking|Writing|Editing|Translation|Multilingual|Bilingual)\b/gi
225:   ]
226:   
227:   skillPatterns.forEach(pattern => {
228:     const matches = resumeText.matchAll(pattern)
229:     for (const match of matches) {
230:       keywords.add(match[1])
231:     }
232:   })
233:   
234:   // Extract from role titles
235:   structure.roles.forEach((role: ResumeRole) => {
236:     const titleWords = role.title.split(/\s+/)
237:     titleWords.forEach((word: string) => {
238:       if (word.length > 3 && !/^(the|and|for|with|from)$/i.test(word)) {
239:         keywords.add(word)
240:       }
241:     })
242:   })
243:   
244:   // Industry-specific terms
245:   if (structure.primaryIndustry.includes('Finance') || structure.primaryIndustry.includes('Lending')) {
246:     ['Commercial Lending', 'Loan Approval', 'Credit Analysis', 'Financial Analysis', 'Deal Structuring', 'Risk Assessment'].forEach(kw => keywords.add(kw))
247:   }
248:   
249:   if (structure.primaryIndustry.includes('Tech') || structure.primaryIndustry.includes('Software')) {
250:     ['Software Development', 'API Integration', 'Database Design', 'Cloud Architecture', 'CI/CD', 'Microservices'].forEach(kw => keywords.add(kw))
251:   }
252:   
253:   return Array.from(keywords)
254: }
255: 
256: /**
257:  * Calculate recency multiplier
258:  */
259: function calculateRecencyMultiplier(keyword: string, structure: ResumeStructure): number {
260:   const rolesWithKeyword = structure.roles.filter((role: ResumeRole) => 
261:     role.description.toLowerCase().includes(keyword.toLowerCase()) ||
262:     role.title.toLowerCase().includes(keyword.toLowerCase())
263:   )
264:   
265:   if (rolesWithKeyword.length === 0) return 1.0
266:   
267:   // Get most recent role with this keyword
268:   const mostRecentRole = rolesWithKeyword[0]
269:   const yearsSinceRole = calculateYearsBetween(mostRecentRole.startDate, new Date())
270:   
271:   // Recency decay
272:   if (mostRecentRole.isCurrent || yearsSinceRole < 1) return 2.0
273:   if (yearsSinceRole < 3) return 1.5
274:   if (yearsSinceRole < 5) return 1.0
275:   if (yearsSinceRole < 10) return 0.7
276:   return 0.5
277: }
278: 
279: /**
280:  * Calculate tenure multiplier
281:  */
282: function calculateTenureMultiplier(keyword: string, structure: ResumeStructure): number {
283:   const rolesWithKeyword = structure.roles.filter((role: ResumeRole) => 
284:     role.description.toLowerCase().includes(keyword.toLowerCase()) ||
285:     role.title.toLowerCase().includes(keyword.toLowerCase())
286:   )
287:   
288:   const totalTenure = rolesWithKeyword.reduce((sum: number, role: ResumeRole) => sum + role.duration, 0)
289:   
290:   if (totalTenure >= 5) return 1.5
291:   if (totalTenure >= 3) return 1.3
292:   if (totalTenure >= 1) return 1.0
293:   return 0.8
294: }
295: 
296: /**
297:  * Calculate industry multiplier
298:  */
299: function calculateIndustryMultiplier(keyword: string, structure: ResumeStructure): number {
300:   const primaryIndustry = structure.primaryIndustry
301:   
302:   const primaryRoles = structure.roles.filter((role: ResumeRole) => role.industry === primaryIndustry)
303:   const keywordInPrimary = primaryRoles.some((role: ResumeRole) => 
304:     role.description.toLowerCase().includes(keyword.toLowerCase()) ||
305:     role.title.toLowerCase().includes(keyword.toLowerCase())
306:   )
307:   
308:   return keywordInPrimary ? 1.25 : 1.0
309: }
310: 
311: /**
312:  * Calculate seniority multiplier
313:  */
314: function calculateSeniorityMultiplier(keyword: string, structure: ResumeStructure): number {
315:   const rolesWithKeyword = structure.roles.filter((role: ResumeRole) => 
316:     role.description.toLowerCase().includes(keyword.toLowerCase()) ||
317:     role.title.toLowerCase().includes(keyword.toLowerCase())
318:   )
319:   
320:   const hasSeniorRole = rolesWithKeyword.some((role: ResumeRole) => 
321:     /senior|lead|manager|director|vp|ceo|cto|head|principal|chief/i.test(role.title)
322:   )
323:   
324:   const hasJuniorRole = rolesWithKeyword.some((role: ResumeRole) => 
325:     /junior|entry|associate|intern|assistant/i.test(role.title)
326:   )
327:   
328:   if (hasSeniorRole) return 1.2
329:   if (hasJuniorRole) return 0.9
330:   return 1.0
331: }
332: 
333: // Helper functions
334: function parseDate(dateStr: string): Date {
335:   const monthMap: Record<string, number> = {
336:     jan: 0, january: 0, feb: 1, february: 1, mar: 2, march: 2,
337:     apr: 3, april: 3, may: 4, jun: 5, june: 5, jul: 6, july: 6,
338:     aug: 7, august: 7, sep: 8, september: 8, oct: 9, october: 9,
339:     nov: 10, november: 10, dec: 11, december: 11
340:   }
341:   
342:   // Try "Jan 2020" format
343:   const monthYearMatch = dateStr.match(/(\w+)\s+(\d{4})/i)
344:   if (monthYearMatch) {
345:     const month = monthMap[monthYearMatch[1].toLowerCase()] ?? 0
346:     const year = parseInt(monthYearMatch[2])
347:     return new Date(year, month, 1)
348:   }
349:   
350:   // Try "2020" format
351:   const yearMatch = dateStr.match(/(\d{4})/)
352:   if (yearMatch) {
353:     return new Date(parseInt(yearMatch[1]), 0, 1)
354:   }
355:   
356:   return new Date()
357: }
358: 
359: function calculateYearsBetween(start: Date, end: Date): number {
360:   const diffMs = end.getTime() - start.getTime()
361:   const diffYears = diffMs / (1000 * 60 * 60 * 24 * 365.25)
362:   return Math.max(0, Math.round(diffYears * 10) / 10)
363: }
364: 
365: function inferIndustry(company: string, description: string): string {
366:   const text = (company + ' ' + description).toLowerCase()
367:   
368:   const industryKeywords: Record<string, string[]> = {
369:     'Finance/Commercial Lending': ['loan', 'lending', 'credit', 'finance', 'bank', 'mortgage', 'commercial lending'],
370:     'Technology/Software': ['software', 'code', 'developer', 'engineering', 'tech', 'api', 'cloud', 'saas'],
371:     'Sales/Business Development': ['sales', 'business development', 'account', 'client', 'revenue', 'bd'],
372:     'Automotive': ['car', 'vehicle', 'auto', 'dealership', 'automotive'],
373:     'Construction': ['construction', 'contractor', 'building', 'renovation', 'electrical'],
374:     'Nonprofit': ['nonprofit', 'charity', 'foundation', 'fundraising', 'volunteer']
375:   }
376:   
377:   for (const [industry, keywords] of Object.entries(industryKeywords)) {
378:     if (keywords.some(kw => text.includes(kw))) {
379:       return industry
380:     }
381:   }
382:   
383:   return 'General'
384: }
385: 
386: function findKeywordSources(keyword: string, structure: ResumeStructure): string[] {
387:   return structure.roles
388:     .filter((role: ResumeRole) => 
389:       role.description.toLowerCase().includes(keyword.toLowerCase()) ||
390:       role.title.toLowerCase().includes(keyword.toLowerCase())
391:     )
392:     .map((role: ResumeRole) => role.company)
393: }
394: 
395: function calculateKeywordTenure(keyword: string, structure: ResumeStructure): number {
396:   const rolesWithKeyword = structure.roles.filter((role: ResumeRole) => 
397:     role.description.toLowerCase().includes(keyword.toLowerCase()) ||
398:     role.title.toLowerCase().includes(keyword.toLowerCase())
399:   )
400:   
401:   return rolesWithKeyword.reduce((sum: number, role: ResumeRole) => sum + role.duration, 0)
402: }
</file>

<file path="src/lib/profile-mapper.ts">
  1: /**
  2:  * Profile Mapper Service
  3:  * 
  4:  * Maps resume data to UserProfile for:
  5:  * - Job search (location, keywords)
  6:  * - Resume optimization (work history, education, skills)
  7:  * - Cover letter generation (experience, psychology)
  8:  * - Application tracking (preferences)
  9:  */
 10: 
 11: import UserProfile, { IUserProfile } from '@/models/UserProfile'
 12: import Resume from '@/models/Resume'
 13: import { EnhancedResumeExtractor } from './enhanced-resume-extractor'
 14: 
 15: export interface ProfileMappingResult {
 16:   success: boolean
 17:   profile?: IUserProfile
 18:   errors?: string[]
 19:   warnings?: string[]
 20: }
 21: 
 22: export class ProfileMapper {
 23:   /**
 24:    * Create or update user profile from resume
 25:    */
 26:   static async mapResumeToProfile(
 27:     userId: string,
 28:     resumeId: string
 29:   ): Promise<ProfileMappingResult> {
 30:     const errors: string[] = []
 31:     const warnings: string[] = []
 32: 
 33:     try {
 34:       // Get resume
 35:       const resume = await Resume.findOne({ _id: resumeId, userId })
 36:       if (!resume) {
 37:         return { success: false, errors: ['Resume not found'] }
 38:       }
 39: 
 40:       // Use enhanced extractor for better weighting and accuracy
 41:       console.log('[PROFILE_MAPPER] Using enhanced extractor...')
 42:       const extracted = await EnhancedResumeExtractor.extract(resume.extractedText)
 43: 
 44:       // Add extraction warnings
 45:       if (extracted.warnings.length > 0) {
 46:         warnings.push(...extracted.warnings)
 47:       }
 48: 
 49:       console.log('[PROFILE_MAPPER] Extraction quality:', Math.round(extracted.extractionQuality * 100) + '%')
 50: 
 51:       // Get or create profile
 52:       let profile = await UserProfile.findOne({ userId })
 53:       const isNew = !profile
 54: 
 55:       if (!profile) {
 56:         profile = new UserProfile({ userId })
 57:       }
 58: 
 59:       // Map personal information
 60:       if (extracted.name) {
 61:         const nameParts = extracted.name.split(' ')
 62:         profile.firstName = nameParts[0] || ''
 63:         profile.lastName = nameParts.slice(1).join(' ') || ''
 64:       } else {
 65:         warnings.push('Name not found in resume')
 66:       }
 67: 
 68:       if (extracted.email) {
 69:         profile.email = extracted.email
 70:       } else {
 71:         warnings.push('Email not found in resume')
 72:       }
 73: 
 74:       if (extracted.phone) {
 75:         profile.phone = extracted.phone
 76:       }
 77: 
 78:       if (extracted.linkedin) {
 79:         profile.linkedinUrl = extracted.linkedin
 80:       }
 81: 
 82:       // Map location (CRITICAL for job search) - with confidence
 83:       if (extracted.location && extracted.location.confidence > 0.5) {
 84:         profile.location = {
 85:           city: extracted.location.city,
 86:           province: extracted.location.province,
 87:           country: extracted.location.country
 88:         }
 89:         console.log('[PROFILE_MAPPER] Location confidence:', Math.round(extracted.location.confidence * 100) + '%')
 90:       } else {
 91:         warnings.push('Location not found or low confidence')
 92:       }
 93: 
 94:       // Map years of experience
 95:       profile.yearsExperience = extracted.totalYearsExperience
 96: 
 97:       // Map work experience (already scored and sorted by recency)
 98:       if (extracted.workExperience.length > 0) {
 99:         profile.workExperience = extracted.workExperience.map(exp => ({
100:           company: exp.company,
101:           title: exp.title,
102:           location: exp.location,
103:           startDate: exp.startDate,
104:           endDate: exp.endDate,
105:           isCurrent: exp.isCurrent,
106:           description: exp.description,
107:           achievements: exp.achievements,
108:           skills: exp.skills,
109:           industry: undefined // Will be inferred later
110:         }))
111:       } else {
112:         warnings.push('No work experience found in resume')
113:       }
114: 
115:       // Map education (already scored by relevance)
116:       if (extracted.education.length > 0) {
117:         profile.education = extracted.education.map(edu => ({
118:           institution: edu.institution,
119:           degree: edu.degree,
120:           field: edu.field,
121:           location: undefined,
122:           startDate: edu.startDate,
123:           endDate: edu.endDate,
124:           gpa: undefined,
125:           achievements: []
126:         }))
127:       } else {
128:         warnings.push('No education found in resume')
129:       }
130: 
131:       // Map skills (WEIGHTED by importance)
132:       if (extracted.topSkills.length > 0) {
133:         // Use top skills categorized by the extractor
134:         const categorized = this.categorizeSkills(extracted.topSkills)
135:         profile.skills = categorized
136:         
137:         console.log('[PROFILE_MAPPER] Top skills:', extracted.topSkills.slice(0, 10))
138:       } else {
139:         warnings.push('No skills/keywords found in resume')
140:       }
141: 
142:       // Map career preferences from extracted data
143:       if (extracted.targetRoles.length > 0) {
144:         if (!profile.careerPreferences) {
145:           profile.careerPreferences = {
146:             targetRoles: [],
147:             targetIndustries: [],
148:             targetCompanies: [],
149:             workType: [],
150:             willingToRelocate: false,
151:             preferredLocations: [],
152:             jobSearchRadius: 70
153:           }
154:         }
155:         profile.careerPreferences.targetRoles = extracted.targetRoles
156:       }
157: 
158:       // Map psychology profile if available
159:       if (resume.comprehensiveResearch?.psychology) {
160:         const psych = resume.comprehensiveResearch.psychology as any
161:         profile.psychologyProfile = {
162:           workStyle: psych.workStyle || [],
163:           motivators: psych.motivators || [],
164:           strengths: psych.strengths || [],
165:           communicationStyle: psych.communicationStyle || 'Unknown',
166:           leadershipStyle: psych.leadershipStyle,
167:           teamDynamics: psych.teamDynamics || [],
168:           generatedAt: new Date()
169:         }
170:       }
171: 
172:       // Set resume reference
173:       profile.currentResumeId = resume._id
174: 
175:       // Save profile
176:       await profile.save()
177: 
178:       console.log('[PROFILE_MAPPER] Profile mapped successfully:', {
179:         userId,
180:         isNew,
181:         completeness: profile.profileCompleteness,
182:         location: profile.location,
183:         workExperience: profile.workExperience.length,
184:         education: profile.education.length,
185:         skills: Object.values(profile.skills).flat().length
186:       })
187: 
188:       return {
189:         success: true,
190:         profile,
191:         warnings: warnings.length > 0 ? warnings : undefined
192:       }
193: 
194:     } catch (error) {
195:       console.error('[PROFILE_MAPPER] Error:', error)
196:       return {
197:         success: false,
198:         errors: [error instanceof Error ? error.message : 'Unknown error']
199:       }
200:     }
201:   }
202: 
203:   /**
204:    * Parse location string into structured format
205:    */
206:   private static parseLocation(locationStr: string): {
207:     city: string
208:     province: string
209:     country: string
210:   } | null {
211:     // Try "City, PROVINCE" format
212:     const match = locationStr.match(/^([^,]+),\s*([A-Z]{2})$/i)
213:     if (match) {
214:       return {
215:         city: match[1].trim(),
216:         province: match[2].toUpperCase(),
217:         country: 'Canada' // Default, can be improved
218:       }
219:     }
220: 
221:     // Try "City, Province, Country" format
222:     const match2 = locationStr.match(/^([^,]+),\s*([^,]+),\s*([^,]+)$/i)
223:     if (match2) {
224:       return {
225:         city: match2[1].trim(),
226:         province: match2[2].trim(),
227:         country: match2[3].trim()
228:       }
229:     }
230: 
231:     // If just province/state
232:     if (locationStr.length === 2) {
233:       return {
234:         city: 'Unknown',
235:         province: locationStr.toUpperCase(),
236:         country: 'Canada'
237:       }
238:     }
239: 
240:     return null
241:   }
242: 
243:   /**
244:    * Categorize skills into technical, soft, languages, tools
245:    */
246:   private static categorizeSkills(keywords: string[]): {
247:     technical: string[]
248:     soft: string[]
249:     languages: string[]
250:     tools: string[]
251:   } {
252:     const technical: string[] = []
253:     const soft: string[] = []
254:     const languages: string[] = []
255:     const tools: string[] = []
256: 
257:     // Programming languages
258:     const programmingLanguages = [
259:       'javascript', 'typescript', 'python', 'java', 'c#', 'c++', 'ruby', 'php',
260:       'go', 'rust', 'swift', 'kotlin', 'scala', 'r', 'matlab', 'sql'
261:     ]
262: 
263:     // Soft skills
264:     const softSkills = [
265:       'leadership', 'communication', 'teamwork', 'problem solving', 'critical thinking',
266:       'time management', 'project management', 'collaboration', 'adaptability',
267:       'creativity', 'negotiation', 'presentation', 'mentoring', 'coaching'
268:     ]
269: 
270:     // Tools/Technologies
271:     const toolsKeywords = [
272:       'react', 'angular', 'vue', 'node', 'express', 'django', 'flask', 'spring',
273:       'docker', 'kubernetes', 'aws', 'azure', 'gcp', 'git', 'jenkins', 'terraform',
274:       'mongodb', 'postgresql', 'mysql', 'redis', 'elasticsearch', 'kafka'
275:     ]
276: 
277:     for (const keyword of keywords) {
278:       const lower = keyword.toLowerCase()
279: 
280:       if (programmingLanguages.some(lang => lower.includes(lang))) {
281:         languages.push(keyword)
282:       } else if (softSkills.some(skill => lower.includes(skill))) {
283:         soft.push(keyword)
284:       } else if (toolsKeywords.some(tool => lower.includes(tool))) {
285:         tools.push(keyword)
286:       } else {
287:         // Default to technical
288:         technical.push(keyword)
289:       }
290:     }
291: 
292:     return { technical, soft, languages, tools }
293:   }
294: 
295:   /**
296:    * Get profile for job search
297:    */
298:   static async getProfileForJobSearch(userId: string): Promise<{
299:     location: string
300:     keywords: string[]
301:     workType?: ('remote' | 'hybrid' | 'onsite')[]
302:     salaryMin?: number
303:     experienceLevel?: 'entry' | 'mid' | 'senior' | 'executive'
304:   } | null> {
305:     const profile = await UserProfile.findOne({ userId })
306:     if (!profile) return null
307: 
308:     // Determine experience level
309:     let experienceLevel: 'entry' | 'mid' | 'senior' | 'executive' = 'mid'
310:     if (profile.yearsExperience < 2) experienceLevel = 'entry'
311:     else if (profile.yearsExperience >= 2 && profile.yearsExperience < 5) experienceLevel = 'mid'
312:     else if (profile.yearsExperience >= 5 && profile.yearsExperience < 10) experienceLevel = 'senior'
313:     else if (profile.yearsExperience >= 10) experienceLevel = 'executive'
314: 
315:     // Build location string
316:     const location = profile.location?.city && profile.location?.province
317:       ? `${profile.location.city}, ${profile.location.province}`
318:       : 'Canada'
319: 
320:     // Get all skills as keywords
321:     const keywords = [
322:       ...profile.skills.technical,
323:       ...profile.skills.languages,
324:       ...profile.skills.tools
325:     ].filter(Boolean)
326: 
327:     return {
328:       location,
329:       keywords,
330:       workType: profile.careerPreferences?.workType,
331:       salaryMin: profile.careerPreferences?.salaryMin,
332:       experienceLevel
333:     }
334:   }
335: 
336:   /**
337:    * Get profile for resume optimization
338:    */
339:   static async getProfileForOptimization(userId: string) {
340:     const profile = await UserProfile.findOne({ userId })
341:     if (!profile) return null
342: 
343:     return {
344:       personalInfo: {
345:         name: `${profile.firstName} ${profile.lastName}`,
346:         email: profile.email,
347:         phone: profile.phone,
348:         location: profile.location,
349:         linkedin: profile.linkedinUrl,
350:         portfolio: profile.portfolioUrl
351:       },
352:       summary: profile.summary,
353:       workExperience: profile.workExperience,
354:       education: profile.education,
355:       skills: profile.skills,
356:       certifications: profile.certifications,
357:       psychologyProfile: profile.psychologyProfile
358:     }
359:   }
360: }
361: 
362: export default ProfileMapper
</file>

<file path="src/models/Application.ts">
 1: import mongoose, { Schema, Document } from 'mongoose'
 2: 
 3: export interface IApplication extends Document {
 4:   userId: mongoose.Types.ObjectId
 5:   jobId?: string
 6:   company: string
 7:   jobTitle: string
 8:   location?: string
 9:   salary?: string
10:   recipient: string
11:   status: 'applied' | 'interview_scheduled' | 'interviewed' | 'offer_received' | 'accepted' | 'rejected' | 'withdrawn'
12:   appliedAt: Date
13:   interviewDate?: Date
14:   attachments: string[]
15:   
16:   // Interview Prep Data
17:   interviewPrep?: {
18:     questions: string[]
19:     companyInsights: string
20:     talkingPoints: string[]
21:     preparedAt: Date
22:   }
23:   
24:   // Salary Negotiation Data
25:   salaryData?: {
26:     marketMin: number
27:     marketMedian: number
28:     marketMax: number
29:     userTarget: number
30:     negotiationTips: string[]
31:     preparedAt: Date
32:   }
33:   
34:   metadata: any
35: }
36: 
37: const ApplicationSchema = new Schema<IApplication>({
38:   userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
39:   jobId: { type: String },
40:   company: { type: String, required: true },
41:   jobTitle: { type: String, required: true },
42:   location: { type: String },
43:   salary: { type: String },
44:   recipient: { type: String, required: true },
45:   status: { 
46:     type: String, 
47:     enum: ['applied', 'interview_scheduled', 'interviewed', 'offer_received', 'accepted', 'rejected', 'withdrawn'], 
48:     default: 'applied' 
49:   },
50:   appliedAt: { type: Date, default: Date.now },
51:   interviewDate: { type: Date },
52:   attachments: [{ type: String }],
53:   
54:   // Interview Prep Data
55:   interviewPrep: {
56:     questions: [{ type: String }],
57:     companyInsights: { type: String },
58:     talkingPoints: [{ type: String }],
59:     preparedAt: { type: Date }
60:   },
61:   
62:   // Salary Negotiation Data
63:   salaryData: {
64:     marketMin: { type: Number },
65:     marketMedian: { type: Number },
66:     marketMax: { type: Number },
67:     userTarget: { type: Number },
68:     negotiationTips: [{ type: String }],
69:     preparedAt: { type: Date }
70:   },
71:   
72:   metadata: { type: Schema.Types.Mixed }
73: }, {
74:   timestamps: true
75: })
76: 
77: // Add indexes for performance
78: ApplicationSchema.index({ userId: 1, appliedAt: -1 })
79: ApplicationSchema.index({ userId: 1, status: 1 })
80: ApplicationSchema.index({ company: 1 })
81: 
82: export default mongoose.models.Application || mongoose.model('Application', ApplicationSchema)
</file>

<file path="src/app/career-finder/search/page.tsx">
  1: 'use client'
  2: 
  3: // Note: force-dynamic doesn't work on client components, removed
  4: 
  5: import { useState, useEffect } from 'react'
  6: import { MagnifyingGlassIcon, FunnelIcon, MapPinIcon, SparklesIcon } from '@heroicons/react/24/outline'
  7: import { JobCard } from '@/components/job-card'
  8: import { JobStatusBar, type JobStatus } from '@/components/job-status-bar'
  9: import { ModernJobCard } from '@/components/modern-job-card'
 10: import { useSession } from 'next-auth/react'
 11: import { useRouter } from 'next/navigation'
 12: import { CareerFinderBackButton } from '@/components/career-finder-back-button'
 13: import { normalizeSalary, getSalaryDisplayString } from '@/lib/utils/salary-normalizer'
 14: import CareerFinderStorage from '@/lib/career-finder-storage'
 15: import { deduplicateJobs } from '@/lib/job-deduplication'
 16: import { JobCardSkeleton } from '@/components/skeleton-loader'
 17: 
 18: interface JobListing {
 19:   id?: string
 20:   title: string
 21:   company: string
 22:   location: string
 23:   salary?: string
 24:   skills?: string[]
 25:   skillMatchPercent?: number
 26:   aiScore?: number
 27:   url?: string
 28:   source?: string
 29:   [key: string]: unknown
 30: }
 31: 
 32: export default function SearchPage() {
 33:   const router = useRouter()
 34:   const [jobs, setJobs] = useState<JobListing[]>([])
 35:   
 36:   // CRITICAL FIX: Location MUST come from resume extraction (saved in cf:location)
 37:   // This is set when resume is uploaded/processed and contains extracted location
 38:   const savedLocation = typeof window !== 'undefined' ? localStorage.getItem('cf:location') || '' : ''
 39:   
 40:   const [filters, setFilters] = useState({ 
 41:     location: savedLocation, // Always use location extracted from resume
 42:     salaryMin: '', 
 43:     salaryMax: '', 
 44:     workType: 'all' as 'all' | 'remote' | 'hybrid' | 'onsite' | 'part-time',
 45:     experienceLevel: '' as '' | 'entry' | 'mid' | 'senior' | 'executive'
 46:   })
 47:   const [sidebarOpen, setSidebarOpen] = useState(false)
 48:   const [searchQuery, setSearchQuery] = useState('')
 49:   const [loading, setLoading] = useState(false)
 50:   const [error, setError] = useState('')
 51:   const [showSearchPrompt, setShowSearchPrompt] = useState(false)
 52:   // CRITICAL FIX: Always use AI matching for better results
 53:   const [useResumeMatching, setUseResumeMatching] = useState(true)
 54:   const [activeStatus, setActiveStatus] = useState<JobStatus>('discover')
 55:   const [useModernCards] = useState(true) // Always use modern cards
 56:   const [metadata, setMetadata] = useState<{
 57:     useResumeMatching?: boolean
 58:     searchedBoards?: number
 59:     canadianPriority?: boolean
 60:     cachedResults?: number
 61:     newResults?: number
 62:   } | null>(null)
 63:   const [loadingJobId, setLoadingJobId] = useState<string | null>(null)
 64:   
 65:   const { data: session, status } = useSession()
 66: 
 67:   // ENTERPRISE FIX: Cache job results for 20 minutes
 68:   useEffect(() => {
 69:     // Try to load cached results on mount
 70:     try {
 71:       const cached = localStorage.getItem('cf:jobResults')
 72:       const cacheTime = localStorage.getItem('cf:jobResultsTime')
 73:       
 74:       if (cached && cacheTime) {
 75:         const age = Date.now() - parseInt(cacheTime)
 76:         const TWENTY_MINUTES = 20 * 60 * 1000
 77:         
 78:         if (age < TWENTY_MINUTES) {
 79:           const cachedData = JSON.parse(cached)
 80:           setJobs(cachedData)
 81:           console.log('[CACHE] Loaded', cachedData.length, 'cached jobs, age:', Math.round(age / 60000), 'minutes')
 82:         } else {
 83:           console.log('[CACHE] Expired, clearing cache')
 84:           localStorage.removeItem('cf:jobResults')
 85:           localStorage.removeItem('cf:jobResultsTime')
 86:         }
 87:       }
 88:     } catch (e) {
 89:       console.error('[CACHE] Failed to load:', e)
 90:     }
 91:   }, [])
 92: 
 93:   // Handler for job selection - stores job and navigates to analysis
 94:   const handleJobSelection = async (job: JobListing, jobId: string) => {
 95:     try {
 96:       // Set loading state for this job
 97:       setLoadingJobId(jobId)
 98:       console.log('[SEARCH] 🔄 Loading state set for job:', jobId)
 99:       
100:       // Store in localStorage with correct key
101:       const jobData = {
102:         ...job,
103:         selectedAt: Date.now()
104:       }
105:       
106:       // CRITICAL: Save to localStorage FIRST before navigation
107:       localStorage.setItem('cf:selectedJob', JSON.stringify(jobData))
108:       console.log('[SEARCH] 💾 Saved job to localStorage:', job.title, '@', job.company)
109:       
110:       // VERIFY it was saved
111:       const verify = localStorage.getItem('cf:selectedJob')
112:       console.log('[SEARCH] ✅ Verification - job in storage:', verify ? 'YES' : 'NO')
113:       
114:       // 🔒 CRITICAL: Clear autopilot flag to prevent re-triggering search on redirect
115:       localStorage.removeItem('cf:autopilotReady')
116:       console.log('[SEARCH] 🚫 Cleared autopilot flag to prevent redirect loop')
117:       
118:       // 🚀 ONE-SHOT COMPREHENSIVE RESEARCH: Call it NOW to reduce costs
119:       console.log('[SEARCH] 🔬 Starting comprehensive research...')
120:       try {
121:         // Get resume from localStorage
122:         const resume = CareerFinderStorage.getResume()
123:         if (resume && resume.extractedText) {
124:           // Call comprehensive research endpoint
125:           const researchResponse = await fetch('/api/v2/career-finder/comprehensive-research', {
126:             method: 'POST',
127:             headers: { 'Content-Type': 'application/json' },
128:             body: JSON.stringify({
129:               jobTitle: job.title,
130:               company: job.company,
131:               jobDescription: job.description || job.summary || '',
132:               location: job.location,
133:               resumeText: resume.extractedText,
134:               resumeSkills: resume.personalInfo?.skills || []
135:             })
136:           })
137:           
138:           if (researchResponse.ok) {
139:             const research = await researchResponse.json()
140:             if (research.success && research.data) {
141:               console.log('[SEARCH] ✅ Comprehensive research complete:', {
142:                 matchScore: research.data.jobAnalysis.matchScore,
143:                 contacts: research.data.hiringContacts.length,
144:                 news: research.data.news.length,
145:                 reviews: research.data.reviews.length
146:               })
147:               
148:               // Store comprehensive research with timestamp
149:               const comprehensiveData = {
150:                 ...research.data.companyIntel,
151:                 psychology: research.data.companyPsychology.culture,
152:                 values: research.data.companyPsychology.values,
153:                 marketIntelligence: research.data.marketIntelligence,
154:                 hiringContacts: research.data.hiringContacts,
155:                 news: research.data.news,
156:                 reviews: research.data.reviews,
157:                 sources: research.data.sources,
158:                 confidence: research.data.confidenceLevel,
159:                 timestamp: Date.now(),
160:                 // Also embed job analysis
161:                 jobAnalysis: research.data.jobAnalysis
162:               }
163:               
164:               CareerFinderStorage.setCompanyResearch(comprehensiveData)
165:               console.log('[SEARCH] 💾 Cached comprehensive research for instant page loads')
166:             }
167:           } else {
168:             console.warn('[SEARCH] ⚠️ Comprehensive research failed, pages will fall back to individual calls')
169:           }
170:         }
171:       } catch (researchError) {
172:         console.warn('[SEARCH] ⚠️ Comprehensive research error (non-blocking):', researchError)
173:       }
174:       
175:       // Store in database for history (don't wait for this)
176:       fetch('/api/jobs/store', {
177:         method: 'POST',
178:         headers: { 'Content-Type': 'application/json' },
179:         body: JSON.stringify(job)
180:       }).catch(err => console.error('[SEARCH] Failed to store in DB:', err))
181:       
182:       // Navigate to job analysis page
183:       console.log('[SEARCH] 🚀 Navigating to job-analysis...')
184:       router.push('/career-finder/job-analysis')
185:     } catch (error) {
186:       console.error('Failed to store job:', error)
187:       // Still navigate even if storage fails
188:       router.push('/career-finder/job-analysis')
189:     } finally {
190:       // Clear loading state after navigation
191:       // Note: This will execute before navigation completes, but that's okay
192:       // The loading state serves to show feedback during the async operations
193:       setTimeout(() => setLoadingJobId(null), 500)
194:     }
195:   }
196: 
197:   // ENTERPRISE FIX: Auto-search on mount if query params exist OR autopilot is ready
198:   useEffect(() => {
199:     const params = new URLSearchParams(window.location.search)
200:     const keywords = params.get('keywords')
201:     const location = params.get('location')
202:     
203:     // PERPLEXITY FIX: Read standardized localStorage keys
204:     const autopilotReady = localStorage.getItem('cf:autopilotReady') === '1'
205:     const savedLocation = localStorage.getItem('cf:location') || ''
206:     const savedKeywords = localStorage.getItem('cf:keywords') || ''
207:     const resumeData = localStorage.getItem('cf:resume')
208:     
209:     console.log('[PERPLEXITY AUDIT FIX] Autopilot check:')
210:     console.log('  - autopilotReady:', autopilotReady)
211:     console.log('  - savedLocation:', savedLocation)
212:     console.log('  - savedKeywords:', savedKeywords)
213:     console.log('  - hasResume:', !!resumeData)
214:     console.log('  - hasKeywords:', !!savedKeywords)
215:     
216:     // CRITICAL FIX: Always use saved location from resume extraction
217:     // This location was extracted when resume was uploaded and cached
218:     if (savedLocation && savedLocation !== filters.location) {
219:       console.log('[LOCATION] Using location from resume extraction:', savedLocation)
220:       setFilters(prev => ({ ...prev, location: savedLocation }))
221:     }
222:     
223:     // ✅ FIX #6: Show search prompt if cached resume exists but no search performed
224:     if (resumeData && !autopilotReady && jobs.length === 0) {
225:       setShowSearchPrompt(true)
226:     }
227:     
228:     if (keywords || autopilotReady) {
229:       if (keywords) {
230:         setSearchQuery(keywords)
231:       }
232:       if (location) setFilters(prev => ({ ...prev, location }))
233:       
234:       // Perform search
235:       const performInitialSearch = async () => {
236:         let query = keywords
237:         // CRITICAL FIX: Use savedLocation as fallback, not filters.location (state might not be updated yet)
238:         const loc = location || savedLocation || filters.location
239: 
240:         // CRITICAL FIX: Use cached keywords from localStorage (already extracted by autopilot)
241:         if (!query && autopilotReady) {
242:           if (savedKeywords) {
243:             query = savedKeywords
244:             setSearchQuery(savedKeywords)
245:             setUseResumeMatching(true)
246:             console.log('[AUTOPILOT] ✅ Using cached keywords:', savedKeywords)
247:           } else {
248:             console.warn('[AUTOPILOT] ⚠️ autopilotReady but no keywords in localStorage')
249:           }
250:         }
251: 
252:         if (!query || query.trim().length < 2) {
253:           console.log('[AUTOPILOT] No valid query, skipping search')
254:           return
255:         }
256:         if (status === 'unauthenticated') return
257: 
258:         setLoading(true)
259:         setError('')
260:         
261:         try {
262:           // CRITICAL DEBUG: Log exactly what we're sending
263:           const searchPayload = {
264:             keywords: query,
265:             location: loc,
266:             limit: 50,
267:             useResumeMatching: autopilotReady && useResumeMatching
268:           }
269:           console.log('[AUTOPILOT] Performing search with payload:', searchPayload)
270:           console.log('[AUTOPILOT] Location debug:', {
271:             urlParam: location,
272:             savedInLocalStorage: savedLocation,
273:             currentFilterState: filters.location,
274:             finalValue: loc,
275:             isEmpty: !loc || loc.length === 0
276:           })
277:           
278:           const response = await fetch('/api/jobs/search', {
279:             method: 'POST',
280:             headers: { 'Content-Type': 'application/json' },
281:             body: JSON.stringify(searchPayload)
282:           })
283: 
284:           const data = await response.json()
285:           if (response.ok) {
286:             const jobResults = data.jobs || []
287:             setJobs(jobResults)
288:             setMetadata(data.metadata || {})
289:             
290:             // CRITICAL: Show NEW jobs found vs cached jobs
291:             const newJobsCount = data.metadata?.newResults || 0
292:             const cachedJobsCount = data.metadata?.cachedResults || 0
293:             console.log('[AUTOPILOT] Search completed:', newJobsCount, 'NEW jobs found,', cachedJobsCount, 'cached jobs,', jobResults.length, 'total displayed')
294:             
295:             // ENTERPRISE FIX: Cache results for 20 minutes
296:             try {
297:               localStorage.setItem('cf:jobResults', JSON.stringify(jobResults))
298:               localStorage.setItem('cf:jobResultsTime', Date.now().toString())
299:               console.log('[CACHE] Stored', jobResults.length, 'jobs')
300:             } catch (e) {
301:               console.error('[CACHE] Failed to store:', e)
302:             }
303:           }
304:         } catch (err) {
305:           console.error('[SEARCH] Error:', err)
306:         } finally {
307:           setLoading(false)
308:         }
309:       }
310: 
311:       performInitialSearch()
312:     }
313:     // eslint-disable-next-line react-hooks/exhaustive-deps
314:   }, [])
315: 
316:   const handleFilterChange = (key: string, value: string | boolean | number) => {
317:     setFilters(prev => ({ ...prev, [key]: value }))
318:   }
319: 
320:   const performSearch = async (keywords?: string, location?: string) => {
321:     const query = keywords || searchQuery
322:     const loc = location || filters.location
323: 
324:     if (!query || query.trim().length < 2) {
325:       setError('Please enter at least 2 characters')
326:       return
327:     }
328: 
329:     if (status === 'unauthenticated') {
330:       router.push('/auth/signin?callbackUrl=/career-finder/search')
331:       return
332:     }
333: 
334:     setLoading(true)
335:     setError('')
336:     
337:     try {
338:       console.log(`[SEARCH] Searching for "${query}" in "${loc}" (Resume: ${useResumeMatching})`)
339: 
340:       const response = await fetch('/api/jobs/search', {
341:         method: 'POST',
342:         headers: { 'Content-Type': 'application/json' },
343:         body: JSON.stringify({
344:           keywords: query,
345:           location: loc,
346:           salaryMin: filters.salaryMin ? parseInt(filters.salaryMin) : undefined,
347:           experienceLevel: filters.experienceLevel || undefined,
348:           workType: filters.workType === 'all' ? 'any' : filters.workType,
349:           limit: 50,
350:           useResumeMatching
351:         })
352:       })
353: 
354:       const data = await response.json()
355: 
356:       if (!response.ok) {
357:         throw new Error(data.error || 'Search failed')
358:       }
359: 
360:       // CRITICAL: Show NEW jobs found vs cached jobs
361:       const newJobsCount = data.metadata?.newResults || 0
362:       const cachedJobsCount = data.metadata?.cachedResults || 0
363:       console.log(`[SEARCH] ✅ ${newJobsCount} NEW jobs found, ${cachedJobsCount} cached jobs, ${data.jobs.length} total from ${data.sources?.length || 0} sources`)
364: 
365:       // ✅ FIX #1: DEDUPLICATE JOBS to prevent infinite loop
366:       const rawJobs = data.jobs || []
367:       const jobResults = deduplicateJobs(rawJobs)
368:       console.log(`[SEARCH] After deduplication: ${jobResults.length} unique jobs`)
369:       
370:       setJobs(jobResults)
371:       setMetadata(data.metadata || {})
372:       
373:       // ENTERPRISE FIX: Cache results for 20 minutes
374:       try {
375:         localStorage.setItem('cf:jobResults', JSON.stringify(jobResults))
376:         localStorage.setItem('cf:jobResultsTime', Date.now().toString())
377:         console.log('[CACHE] Stored', jobResults.length, 'jobs')
378:       } catch (e) {
379:         console.error('[CACHE] Failed to store:', e)
380:       }
381: 
382:       // Show board recommendations
383:       if (data.recommendations) {
384:         console.log(`[SEARCH] Recommended boards: ${data.recommendations.priorityBoards.join(', ')}`)
385:       }
386: 
387:     } catch (err) {
388:       console.error('[SEARCH] Error:', err)
389:       setError((err as Error).message || 'Failed to search jobs')
390:       setJobs([])
391:     } finally {
392:       setLoading(false)
393:     }
394:   }
395: 
396:   const handleSearch = (e: React.FormEvent) => {
397:     e.preventDefault()
398:     performSearch()
399:   }
400: 
401:   const toggleSidebar = () => {
402:     setSidebarOpen(!sidebarOpen)
403:     if (!sidebarOpen) document.body.classList.add('sidebar-open')
404:     else document.body.classList.remove('sidebar-open')
405:   }
406: 
407:   return (
408:     <div className="min-h-screen bg-background">
409:       {/* Hero Search Section */}
410:       <section className="gradient-hero px-4 py-16 rounded-b-[3rem] shadow-2xl relative overflow-hidden">
411:         {/* Animated background blobs */}
412:         <div className="absolute top-0 left-0 w-72 h-72 bg-card/10 rounded-full blur-3xl -translate-x-1/2 -translate-y-1/2"></div>
413:         <div className="absolute bottom-0 right-0 w-96 h-96 bg-card/10 rounded-full blur-3xl translate-x-1/2 translate-y-1/2"></div>
414:         
415:         <div className="max-w-4xl mx-auto relative z-10">
416:           <div className="mb-4">
417:             <CareerFinderBackButton />
418:           </div>
419:           <h1 className="text-4xl md:text-6xl font-bold mb-4 text-foreground text-center drop-shadow-lg">
420:             🚀 Find Your Dream Job
421:           </h1>
422:           <p className="text-foreground/95 text-xl mb-8 text-center font-medium">
423:             Discover opportunities that match your skills and passion
424:           </p>
425:           
426:           <form onSubmit={handleSearch} className="flex flex-col gap-4">
427:             <div className="flex flex-col sm:flex-row gap-3">
428:               <div className="relative flex-1">
429:                 <MagnifyingGlassIcon className="absolute left-4 top-1/2 -translate-y-1/2 w-6 h-6 text-muted-foreground" />
430:                 <input
431:                   type="text"
432:                   placeholder="Search jobs by title, company, or keywords..."
433:                   value={searchQuery}
434:                   onChange={(e) => setSearchQuery(e.target.value)}
435:                   className="modern-input w-full pl-12 pr-4 py-4 text-lg font-medium shadow-xl"
436:                   disabled={loading}
437:                 />
438:               </div>
439:               <div className="flex gap-2">
440:                 <button 
441:                   type="submit" 
442:                   className="btn btn-primary"
443:                   disabled={loading}
444:                 >
445:                   {loading ? (
446:                     <>
447:                       <span className="inline-block animate-spin mr-2">⏳</span>
448:                       <span>Searching...</span>
449:                     </>
450:                   ) : (
451:                     <>
452:                       <MagnifyingGlassIcon className="w-6 h-6 inline mr-2" />
453:                       <span>Search</span>
454:                     </>
455:                   )}
456:                 </button>
457:                 {jobs.length > 0 && (
458:                   <button
459:                     type="button"
460:                     onClick={() => {
461:                       // Clear cache and reset
462:                       localStorage.removeItem('cf:jobResults')
463:                       localStorage.removeItem('cf:jobResultsTime')
464:                       setJobs([])
465:                       setSearchQuery('')
466:                       console.log('[SEARCH] Cache cleared, ready for new search')
467:                     }}
468:                     className="btn btn-secondary bg-white/20 hover:bg-card/30 text-white border-white/30"
469:                     disabled={loading}
470:                   >
471:                     🔄 New Search
472:                   </button>
473:                 )}
474:               </div>
475:             </div>
476:             
477:             {/* AI Matching Always Active Indicator */}
478:             {session && (
479:               <div className="flex items-center gap-3 justify-center">
480:                 <div className="flex items-center gap-2 bg-gradient-to-r from-blue-500/20 to-purple-500/20 backdrop-blur-sm px-6 py-3 rounded-full border border-blue-500/30">
481:                   <SparklesIcon className="w-5 h-5 text-blue-400 animate-pulse" />
482:                   <span className="text-foreground font-semibold text-sm">
483:                     ✨ AI Resume Matching Active
484:                   </span>
485:                   <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
486:                 </div>
487:               </div>
488:             )}
489: 
490:             {/* Error Display */}
491:             {error && (
492:               <div className="bg-red-500/20 border border-red-500 text-foreground px-4 py-2 rounded-xl text-center">
493:                 {error}
494:               </div>
495:             )}
496:           </form>
497:         </div>
498:       </section>
499: 
500:       {/* ✅ FIX #6: Search Prompt Banner for Cached Resume */}
501:       {showSearchPrompt && (
502:         <div className="container mx-auto px-4 sm:px-6 py-4 sm:py-8 max-w-7xl">
503:           <div className="bg-gradient-to-r from-blue-500/10 to-purple-500/10 border-2 border-blue-500/30 rounded-2xl p-6 flex items-center gap-4">
504:             <div className="text-4xl">💡</div>
505:             <div className="flex-1">
506:               <h1 className="text-2xl sm:text-3xl font-bold text-foreground mb-2">Find Your Perfect Job</h1>
507:               <p className="text-sm text-muted-foreground">
508:                 We found your resume. Enter keywords above and click Search to find matching jobs, or let AI analyze your resume automatically.
509:               </p>
510:             </div>
511:             <button
512:               onClick={() => setShowSearchPrompt(false)}
513:               className="text-muted-foreground hover:text-foreground transition-colors"
514:             >
515:               ✕
516:             </button>
517:           </div>
518:         </div>
519:       )}
520: 
521:       <div className="flex flex-col lg:flex-row gap-8 max-w-7xl mx-auto px-4 lg:px-8 py-8">
522:         {/* Main Content: Job Grid */}
523:         <main className="flex-1">
524:           <div className="mb-8">
525:             <div className="flex items-center justify-between mb-4">
526:               <div>
527:                 <h2 className="text-3xl font-bold gradient-text">
528:                   {loading ? 'Searching...' : `${jobs.length} Jobs Found`}
529:                 </h2>
530:                 <p className="text-muted-foreground mt-1">
531:                   {loading ? 'Searching 25+ job boards...' : 
532:                    metadata?.useResumeMatching ? 'Ranked by skill match from your resume' :
533:                    metadata?.canadianPriority ? 'Prioritized Canadian sources' :
534:                    'Curated opportunities just for you'}
535:                 </p>
536:               </div>
537:               <div className="flex items-center gap-2">
538:                 <button
539:                   onClick={() => {
540:                     // Clear all cache
541:                     localStorage.removeItem('cf:jobResults')
542:                     localStorage.removeItem('cf:jobResultsTime')
543:                     localStorage.removeItem('cf:location')
544:                     localStorage.removeItem('cf:keywords')
545:                     localStorage.removeItem('cf:autopilotReady')
546:                     setJobs([])
547:                     setSearchQuery('')
548:                     setFilters({ location: '', salaryMin: '', salaryMax: '', workType: 'all', experienceLevel: '' })
549:                     console.log('[CACHE] All cache cleared')
550:                     window.location.reload()
551:                   }}
552:                   className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm font-medium"
553:                 >
554:                   🗑️ Clear Cache
555:                 </button>
556:                 <button 
557:                   onClick={toggleSidebar} 
558:                   className="lg:hidden btn-primary flex items-center gap-2"
559:                 >
560:                   <FunnelIcon className="w-5 h-5" />
561:                   Filters
562:                 </button>
563:               </div>
564:             </div>
565: 
566:             {/* Search Metadata */}
567:             {metadata && jobs.length > 0 && (
568:               <div className="bg-card/50 backdrop-blur-sm border border-border rounded-xl p-4 mb-6">
569:                 <div className="flex flex-wrap gap-4 text-sm">
570:                   {metadata.searchedBoards && (
571:                     <div className="flex items-center gap-2">
572:                       <span className="font-bold">📊</span>
573:                       <span>{metadata.searchedBoards} boards searched</span>
574:                     </div>
575:                   )}
576:                   {metadata.useResumeMatching && (
577:                     <div className="flex items-center gap-2">
578:                       <SparklesIcon className="w-4 h-4 text-primary" />
579:                       <span className="font-bold text-primary">AI Skill Matching Active</span>
580:                     </div>
581:                   )}
582:                   {metadata.cachedResults && (
583:                     <div className="flex items-center gap-2">
584:                       <span className="font-bold">⚡</span>
585:                       <span>Cached results (instant)</span>
586:                     </div>
587:                   )}
588:                 </div>
589:               </div>
590:             )}
591:           </div>
592: 
593:           {/* Job Status Bar - Figma Design */}
594:           {jobs.length > 0 && (
595:             <>
596:               {/* NEW: Show job discovery stats */}
597:               {metadata?.newResults !== undefined && (
598:                 <div className="mb-4 flex items-center justify-center gap-2 sm:gap-4 text-xs sm:text-sm flex-wrap">
599:                   <div className="flex items-center gap-1 sm:gap-2 px-2 sm:px-4 py-1.5 sm:py-2 bg-green-500/10 rounded-full border border-green-500/20">
600:                     <span className="text-green-600 dark:text-green-400 font-semibold whitespace-nowrap">✨ {metadata.newResults} New</span>
601:                   </div>
602:                   {(metadata.cachedResults || 0) > 0 && (
603:                     <div className="flex items-center gap-1 sm:gap-2 px-2 sm:px-4 py-1.5 sm:py-2 bg-blue-500/10 rounded-full border border-blue-500/20">
604:                       <span className="text-blue-600 dark:text-blue-400 font-semibold whitespace-nowrap">💾 {metadata.cachedResults} Cached</span>
605:                     </div>
606:                   )}
607:                   <div className="flex items-center gap-1 sm:gap-2 px-2 sm:px-4 py-1.5 sm:py-2 bg-purple-500/10 rounded-full border border-purple-500/20">
608:                     <span className="text-purple-600 dark:text-purple-400 font-semibold whitespace-nowrap">📊 {jobs.length} Total</span>
609:                   </div>
610:                 </div>
611:               )}
612:               
613:               <div className="mb-8">
614:                 <JobStatusBar
615:                   activeStatus={activeStatus}
616:                   onStatusChange={setActiveStatus}
617:                   counts={{
618:                     discover: jobs.length,
619:                     saved: 0,
620:                     applied: 0,
621:                     closed: 0,
622:                     discarded: 0
623:                   }}
624:                 />
625:               </div>
626:             </>
627:           )}
628: 
629:           {loading ? (
630:             <div className="space-y-6">
631:               {/* Loading Animation Header */}
632:               <div className="text-center py-8">
633:                 <div className="inline-flex items-center gap-3 px-6 py-3 bg-primary/10 rounded-full">
634:                   <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary"></div>
635:                   <span className="text-primary font-semibold">Finding the best opportunities for you...</span>
636:                 </div>
637:               </div>
638:               
639:               {/* Skeleton Cards */}
640:               <div className="grid grid-cols-1 gap-6 max-w-md mx-auto">
641:                 {[...Array(6)].map((_, i) => (
642:                   <JobCardSkeleton key={i} />
643:                 ))}
644:               </div>
645:             </div>
646:           ) : jobs.length === 0 ? (
647:             <div className="text-center py-12">
648:               <div className="text-6xl mb-4">🔍</div>
649:               <h3 className="text-2xl font-bold mb-2">No jobs found</h3>
650:               <p className="text-muted-foreground">Try adjusting your search or filters</p>
651:             </div>
652:           ) : useModernCards ? (
653:             /* Modern Figma-Inspired Job Cards */
654:             <div className="grid grid-cols-1 gap-6 max-w-md mx-auto">
655:               {jobs.map((job, index) => {
656:                 const colorThemes: Array<'purple' | 'red' | 'yellow'> = ['purple', 'red', 'yellow']
657:                 const colorTheme = colorThemes[index % 3]
658:                 
659:                 // Normalize salary for consistent display
660:                 const normalizedSalary = normalizeSalary(job.salary)
661:                 const salaryDisplay = normalizedSalary 
662:                   ? getSalaryDisplayString(normalizedSalary) 
663:                   : 'Salary not disclosed'
664:                 
665:                 const jobId = job.id || `job-${index}`
666:                 const isJobLoading = loadingJobId === jobId
667:                 
668:                 return (
669:                   <ModernJobCard
670:                     key={jobId}
671:                     id={jobId}
672:                     title={job.title}
673:                     company={job.company}
674:                     location={job.location}
675:                     experience={filters.experienceLevel || 'All levels'}
676:                     workType={filters.workType === 'all' ? 'onsite' : (filters.workType as 'remote' | 'hybrid' | 'onsite' | 'part-time')}
677:                     salary={salaryDisplay}
678:                     description={`AI Score: ${job.aiScore || 'N/A'}${job.skillMatchPercent ? ` | Skill Match: ${job.skillMatchPercent}%` : ''}`}
679:                     postedDate="Posted recently"
680:                     colorTheme={colorTheme}
681:                     onView={() => handleJobSelection(job, jobId)}
682:                     isLoading={isJobLoading}
683:                   />
684:                 )
685:               })}
686:             </div>
687:           ) : (
688:             /* Legacy Job Cards */
689:             <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
690:               {jobs.map((job, index) => {
691:                 // Normalize salary for consistent display
692:                 const normalizedSalary = normalizeSalary(job.salary)
693:                 const salaryDisplay = normalizedSalary 
694:                   ? getSalaryDisplayString(normalizedSalary) 
695:                   : job.salary || 'Salary not disclosed'
696:                 
697:                 return (
698:                   <JobCard 
699:                     key={job.id || `job-${index}`} 
700:                     job={{...job, id: job.id || `job-${index}`, url: job.url || '#', salary: salaryDisplay}} 
701:                   />
702:                 )
703:               })}
704:             </div>
705:           )}
706:         </main>
707: 
708:         {/* Sidebar: Filters */}
709:         <aside className={`hidden lg:block w-80 sticky top-8 self-start`}>
710:           <div className="gradient-border-card">
711:             <div className="flex justify-between items-center mb-6">
712:               <h2 className="text-2xl font-bold gradient-text">
713:                 🎯 Filters
714:               </h2>
715:               <button 
716:                 onClick={() => setFilters({ location: '', salaryMin: '', salaryMax: '', workType: 'all', experienceLevel: '' })}
717:                 className="text-sm text-secondary hover:text-primary font-bold transition-colors"
718:               >
719:                 Clear All
720:               </button>
721:             </div>
722:             
723:             <div className="space-y-6">
724:               {/* Work Type Filter */}
725:               <div>
726:                 <label className="block text-sm font-bold mb-3">💼 Work Type</label>
727:                 <select
728:                   value={filters.workType}
729:                   onChange={(e) => handleFilterChange('workType', e.target.value)}
730:                   className="modern-input w-full"
731:                 >
732:                   <option value="all">All Types</option>
733:                   <option value="remote">🏡 Remote</option>
734:                   <option value="hybrid">🔄 Hybrid</option>
735:                   <option value="onsite">🏢 At Location</option>
736:                   <option value="part-time">⏰ Part-time</option>
737:                 </select>
738:               </div>
739: 
740:               {/* Location Filter */}
741:               <div>
742:                 <label className="block text-sm font-bold mb-3">
743:                   <MapPinIcon className="w-5 h-5 inline mr-1 text-secondary" />
744:                   Location
745:                 </label>
746:                 <input
747:                   type="text"
748:                   placeholder="e.g., Edmonton, AB"
749:                   value={filters.location}
750:                   onChange={(e) => handleFilterChange('location', e.target.value)}
751:                   className="modern-input w-full"
752:                 />
753:               </div>
754: 
755:               {/* Salary Range Filter */}
756:               <div>
757:                 <label className="block text-sm font-bold mb-3">💰 Salary Range</label>
758:                 <input
759:                   type="number"
760:                   placeholder="Min Salary"
761:                   value={filters.salaryMin}
762:                   onChange={(e) => handleFilterChange('salaryMin', e.target.value)}
763:                   className="modern-input w-full mb-3"
764:                 />
765:                 <input
766:                   type="number"
767:                   placeholder="Max Salary"
768:                   value={filters.salaryMax}
769:                   onChange={(e) => handleFilterChange('salaryMax', e.target.value)}
770:                   className="modern-input w-full"
771:                 />
772:               </div>
773: 
774:               {/* Experience Level Filter */}
775:               <div>
776:                 <label className="block text-sm font-bold mb-3">📈 Experience Level</label>
777:                 <select
778:                   value={filters.experienceLevel}
779:                   onChange={(e) => handleFilterChange('experienceLevel', e.target.value)}
780:                   className="modern-input w-full"
781:                 >
782:                   <option value="">Any Level</option>
783:                   <option value="entry">Entry Level</option>
784:                   <option value="mid">Mid Level</option>
785:                   <option value="senior">Senior Level</option>
786:                   <option value="executive">Executive</option>
787:                 </select>
788:               </div>
789:             </div>
790:           </div>
791:         </aside>
792:       </div>
793: 
794:       {/* Mobile Filter Modal */}
795:       {sidebarOpen && (
796:         <>
797:           <div 
798:             className="fixed inset-0 bg-black/50 z-40 lg:hidden" 
799:             onClick={toggleSidebar}
800:           />
801:           <div className="fixed inset-y-0 left-0 w-80 bg-card z-50 lg:hidden overflow-y-auto p-6 shadow-2xl">
802:             <div className="flex justify-between items-center mb-6">
803:               <h2 className="text-xl font-bold">Filters</h2>
804:               <button 
805:                 onClick={toggleSidebar}
806:                 className="p-2 hover:bg-muted rounded-lg transition-colors"
807:               >
808:                 ✕
809:               </button>
810:             </div>
811:             
812:             <div className="space-y-6">
813:               <div className="filter-group">
814:                 <label className="block text-sm font-semibold mb-3">💼 Work Type</label>
815:                 <select
816:                   value={filters.workType}
817:                   onChange={(e) => handleFilterChange('workType', e.target.value)}
818:                   className="modern-input w-full"
819:                 >
820:                   <option value="all">All Types</option>
821:                   <option value="remote">🏡 Remote</option>
822:                   <option value="hybrid">🔄 Hybrid</option>
823:                   <option value="onsite">🏢 At Location</option>
824:                   <option value="part-time">⏰ Part-time</option>
825:                 </select>
826:               </div>
827: 
828:               <div className="filter-group">
829:                 <label className="block text-sm font-semibold mb-3">
830:                   <MapPinIcon className="w-4 h-4 inline mr-1" />
831:                   Location
832:                 </label>
833:                 <input
834:                   type="text"
835:                   placeholder="e.g., Edmonton, AB"
836:                   value={filters.location}
837:                   onChange={(e) => handleFilterChange('location', e.target.value)}
838:                   className="modern-input w-full"
839:                 />
840:               </div>
841: 
842:               <div className="filter-group">
843:                 <label className="block text-sm font-semibold mb-3">Salary Range</label>
844:                 <input
845:                   type="number"
846:                   placeholder="Min Salary"
847:                   value={filters.salaryMin}
848:                   onChange={(e) => handleFilterChange('salaryMin', e.target.value)}
849:                   className="modern-input w-full mb-3"
850:                 />
851:                 <input
852:                   type="number"
853:                   placeholder="Max Salary"
854:                   value={filters.salaryMax}
855:                   onChange={(e) => handleFilterChange('salaryMax', e.target.value)}
856:                   className="modern-input w-full"
857:                 />
858:               </div>
859: 
860:               <button 
861:                 onClick={toggleSidebar}
862:                 className="w-full btn-primary py-3 rounded-xl font-semibold"
863:               >
864:                 Apply Filters
865:               </button>
866:             </div>
867:           </div>
868:         </>
869:       )}
870:     </div>
871:   )
872: }
</file>

<file path="src/models/UserProfile.ts">
  1: /**
  2:  * Comprehensive User Profile Model
  3:  * 
  4:  * Central source of truth for all user data:
  5:  * - Personal information
  6:  * - Location (for job search)
  7:  * - Work experience
  8:  * - Education
  9:  * - Skills & keywords
 10:  * - Career preferences
 11:  */
 12: 
 13: import mongoose, { Schema, Document } from 'mongoose'
 14: 
 15: export interface IWorkExperience {
 16:   company: string
 17:   title: string
 18:   location?: string
 19:   startDate: Date
 20:   endDate?: Date // null = current position
 21:   isCurrent: boolean
 22:   description: string
 23:   achievements: string[]
 24:   skills: string[]
 25:   industry?: string
 26: }
 27: 
 28: export interface IEducation {
 29:   institution: string
 30:   degree: string
 31:   field: string
 32:   location?: string
 33:   startDate: Date
 34:   endDate?: Date
 35:   gpa?: number
 36:   achievements: string[]
 37: }
 38: 
 39: export interface ICertification {
 40:   name: string
 41:   issuer: string
 42:   issueDate: Date
 43:   expiryDate?: Date
 44:   credentialId?: string
 45:   url?: string
 46: }
 47: 
 48: export interface ICareerPreferences {
 49:   targetRoles: string[]
 50:   targetIndustries: string[]
 51:   targetCompanies: string[]
 52:   workType: ('remote' | 'hybrid' | 'onsite')[]
 53:   salaryMin?: number
 54:   salaryMax?: number
 55:   willingToRelocate: boolean
 56:   preferredLocations: string[]
 57:   jobSearchRadius: number // km
 58:   availableStartDate?: Date
 59: }
 60: 
 61: export interface IUserProfile extends Document {
 62:   userId: Schema.Types.ObjectId
 63:   
 64:   // Personal Information
 65:   firstName: string
 66:   lastName: string
 67:   email: string
 68:   phone?: string
 69:   linkedinUrl?: string
 70:   portfolioUrl?: string
 71:   githubUrl?: string
 72:   
 73:   // Location (PRIMARY for job search)
 74:   location: {
 75:     city: string
 76:     province: string // or state
 77:     country: string
 78:     fullAddress?: string
 79:     coordinates?: {
 80:       lat: number
 81:       lng: number
 82:     }
 83:   }
 84:   
 85:   // Professional Summary
 86:   headline?: string // e.g., "Senior Software Developer"
 87:   summary?: string // Professional bio
 88:   yearsExperience: number
 89:   
 90:   // Work Experience (MAPPED from resume)
 91:   workExperience: IWorkExperience[]
 92:   
 93:   // Education (MAPPED from resume)
 94:   education: IEducation[]
 95:   
 96:   // Certifications
 97:   certifications: ICertification[]
 98:   
 99:   // Skills & Keywords (EXTRACTED from resume + manual)
100:   skills: {
101:     technical: string[]
102:     soft: string[]
103:     languages: string[]
104:     tools: string[]
105:     
106:     // NEW: Weighted skills from Perplexity analysis
107:     weighted?: {
108:       primarySkills: Array<{
109:         skill: string
110:         weight: number
111:         years?: number | null
112:         category: string
113:         extractedAt?: Date
114:       }>
115:       secondarySkills: Array<{
116:         skill: string
117:         weight: number
118:         years?: number | null
119:         category: string
120:         extractedAt?: Date
121:       }>
122:       lastAnalyzedAt?: Date
123:     }
124:   }
125:   
126:   // Career Preferences
127:   careerPreferences: ICareerPreferences
128:   
129:   // Psychology Profile (from resume analysis)
130:   psychologyProfile?: {
131:     workStyle: string[]
132:     motivators: string[]
133:     strengths: string[]
134:     communicationStyle: string
135:     leadershipStyle?: string
136:     teamDynamics: string[]
137:     generatedAt: Date
138:   }
139:   
140:   // Resume Reference
141:   currentResumeId?: Schema.Types.ObjectId
142:   
143:   // Metadata
144:   profileCompleteness: number // 0-100
145:   lastUpdated: Date
146:   createdAt: Date
147:   
148:   // Methods
149:   calculateCompleteness(): number
150: }
151: 
152: const WorkExperienceSchema = new Schema({
153:   company: { type: String, required: true },
154:   title: { type: String, required: true },
155:   location: String,
156:   startDate: { type: Date, required: true },
157:   endDate: Date,
158:   isCurrent: { type: Boolean, default: false },
159:   description: { type: String, required: true },
160:   achievements: [String],
161:   skills: [String],
162:   industry: String
163: })
164: 
165: const EducationSchema = new Schema({
166:   institution: { type: String, required: true },
167:   degree: { type: String, required: true },
168:   field: { type: String, required: true },
169:   location: String,
170:   startDate: { type: Date, required: true },
171:   endDate: Date,
172:   gpa: Number,
173:   achievements: [String]
174: })
175: 
176: const CertificationSchema = new Schema({
177:   name: { type: String, required: true },
178:   issuer: { type: String, required: true },
179:   issueDate: { type: Date, required: true },
180:   expiryDate: Date,
181:   credentialId: String,
182:   url: String
183: })
184: 
185: const UserProfileSchema = new Schema<IUserProfile>({
186:   userId: {
187:     type: Schema.Types.ObjectId,
188:     ref: 'User',
189:     required: true,
190:     unique: true
191:   },
192:   
193:   // Personal Information
194:   firstName: { type: String, required: true },
195:   lastName: { type: String, required: true },
196:   email: { type: String, required: true },
197:   phone: String,
198:   linkedinUrl: String,
199:   portfolioUrl: String,
200:   githubUrl: String,
201:   
202:   // Location
203:   location: {
204:     city: { type: String, required: true },
205:     province: { type: String, required: true },
206:     country: { type: String, required: true, default: 'Canada' },
207:     fullAddress: String,
208:     coordinates: {
209:       lat: Number,
210:       lng: Number
211:     }
212:   },
213:   
214:   // Professional Summary
215:   headline: String,
216:   summary: String,
217:   yearsExperience: { type: Number, default: 0 },
218:   
219:   // Work Experience
220:   workExperience: [WorkExperienceSchema],
221:   
222:   // Education
223:   education: [EducationSchema],
224:   
225:   // Certifications
226:   certifications: [CertificationSchema],
227:   
228:   // Skills
229:   skills: {
230:     technical: [String],
231:     soft: [String],
232:     languages: [String],
233:     tools: [String],
234:     
235:     // NEW: Weighted skills from Perplexity analysis
236:     weighted: {
237:       primarySkills: [{
238:         skill: String,
239:         weight: Number,
240:         years: Number,
241:         category: String,
242:         extractedAt: Date
243:       }],
244:       secondarySkills: [{
245:         skill: String,
246:         weight: Number,
247:         years: Number,
248:         category: String,
249:         extractedAt: Date
250:       }],
251:       lastAnalyzedAt: Date
252:     }
253:   },
254:   
255:   // Career Preferences
256:   careerPreferences: {
257:     targetRoles: [String],
258:     targetIndustries: [String],
259:     targetCompanies: [String],
260:     workType: [{ type: String, enum: ['remote', 'hybrid', 'onsite'] }],
261:     salaryMin: Number,
262:     salaryMax: Number,
263:     willingToRelocate: { type: Boolean, default: false },
264:     preferredLocations: [String],
265:     jobSearchRadius: { type: Number, default: 70 }, // km
266:     availableStartDate: Date
267:   },
268:   
269:   // Psychology Profile
270:   psychologyProfile: {
271:     workStyle: [String],
272:     motivators: [String],
273:     strengths: [String],
274:     communicationStyle: String,
275:     leadershipStyle: String,
276:     teamDynamics: [String],
277:     generatedAt: Date
278:   },
279:   
280:   // Resume Reference
281:   currentResumeId: {
282:     type: Schema.Types.ObjectId,
283:     ref: 'Resume'
284:   },
285:   
286:   // Metadata
287:   profileCompleteness: { type: Number, default: 0, min: 0, max: 100 },
288:   lastUpdated: { type: Date, default: Date.now }
289: }, {
290:   timestamps: true
291: })
292: 
293: // Indexes
294: // Note: userId already indexed via unique: true
295: UserProfileSchema.index({ email: 1 })
296: UserProfileSchema.index({ 'location.city': 1, 'location.province': 1 })
297: UserProfileSchema.index({ 'skills.technical': 1 })
298: UserProfileSchema.index({ 'careerPreferences.targetRoles': 1 })
299: 
300: // Calculate profile completeness
301: UserProfileSchema.methods.calculateCompleteness = function(): number {
302:   let score = 0
303:   const weights = {
304:     personalInfo: 15, // firstName, lastName, email, phone
305:     location: 15,
306:     workExperience: 25,
307:     education: 15,
308:     skills: 15,
309:     careerPreferences: 10,
310:     summary: 5
311:   }
312:   
313:   // Personal info
314:   if (this.firstName && this.lastName && this.email) score += weights.personalInfo * 0.75
315:   if (this.phone) score += weights.personalInfo * 0.25
316:   
317:   // Location
318:   if (this.location?.city && this.location?.province) score += weights.location
319:   
320:   // Work experience
321:   if (this.workExperience?.length > 0) {
322:     score += weights.workExperience * Math.min(this.workExperience.length / 3, 1)
323:   }
324:   
325:   // Education
326:   if (this.education?.length > 0) score += weights.education
327:   
328:   // Skills
329:   const totalSkills = (this.skills?.technical?.length || 0) + (this.skills?.soft?.length || 0)
330:   if (totalSkills > 0) {
331:     score += weights.skills * Math.min(totalSkills / 10, 1)
332:   }
333:   
334:   // Career preferences
335:   if (this.careerPreferences?.targetRoles?.length > 0) score += weights.careerPreferences
336:   
337:   // Summary
338:   if (this.summary && this.summary.length > 50) score += weights.summary
339:   
340:   return Math.round(score)
341: }
342: 
343: // Update completeness before save
344: UserProfileSchema.pre('save', function(next) {
345:   this.profileCompleteness = this.calculateCompleteness()
346:   this.lastUpdated = new Date()
347:   next()
348: })
349: 
350: export default mongoose.models.UserProfile || mongoose.model<IUserProfile>('UserProfile', UserProfileSchema)
</file>

<file path="src/types/supabase.ts">
  1: /**
  2:  * Supabase Database Types
  3:  * Auto-generated from your Supabase schema
  4:  */
  5: 
  6: export interface Job {
  7:   id: string
  8:   title: string
  9:   company: string
 10:   location: string
 11:   description?: string
 12:   description_html?: string
 13:   salary_min?: number
 14:   salary_max?: number
 15:   salary_type?: string
 16:   salary_currency?: string
 17:   job_type?: string
 18:   experience_level?: string
 19:   remote_type?: string
 20:   url: string
 21:   external_id?: string
 22:   source: 'active-jobs-db' | 'google-jobs' | 'jsearch' | 'adzuna' | 'indeed' | 'linkedin' | 'civicjobs' | 'job-bank' | 'company-pages' | 'ats-direct'
 23:   apply_link?: string
 24:   company_size?: string
 25:   company_industry?: string
 26:   city?: string
 27:   state?: string
 28:   country?: string
 29:   keywords?: string[]
 30:   posted_date?: string
 31:   scraped_at?: string
 32:   expires_at?: string
 33:   raw_data?: any
 34:   created_at?: string
 35:   updated_at?: string
 36: }
 37: 
 38: export interface Company {
 39:   id: string
 40:   name: string
 41:   normalized_name?: string
 42:   website?: string
 43:   description?: string
 44:   employee_count?: string
 45:   founded_year?: number
 46:   linkedin_url?: string
 47:   linkedin_slug?: string
 48:   linkedin_followers?: number
 49:   linkedin_industry?: string
 50:   linkedin_specialties?: string[]
 51:   glassdoor_url?: string
 52:   glassdoor_rating?: number
 53:   glassdoor_review_count?: number
 54:   headquarters_city?: string
 55:   headquarters_state?: string
 56:   headquarters_country?: string
 57:   raw_data?: any
 58:   created_at?: string
 59:   updated_at?: string
 60: }
 61: 
 62: export interface SalaryData {
 63:   id: string
 64:   job_title: string
 65:   company?: string
 66:   location?: string
 67:   location_type?: string
 68:   years_of_experience?: string
 69:   min_salary?: number
 70:   max_salary?: number
 71:   median_salary?: number
 72:   min_base_salary?: number
 73:   max_base_salary?: number
 74:   median_base_salary?: number
 75:   min_additional_pay?: number
 76:   max_additional_pay?: number
 77:   median_additional_pay?: number
 78:   salary_period?: string
 79:   salary_currency?: string
 80:   confidence?: string
 81:   salary_count?: number
 82:   created_at?: string
 83:   expires_at?: string
 84: }
 85: 
 86: export interface DownloadHistory {
 87:   id: string
 88:   source: string
 89:   search_query?: string
 90:   location?: string
 91:   jobs_downloaded: number
 92:   unique_jobs: number
 93:   duplicates_found?: number
 94:   duration_seconds?: number
 95:   success: boolean
 96:   error_message?: string
 97:   started_at?: string
 98:   completed_at?: string
 99: }
100: 
101: // Search parameters
102: export interface JobSearchParams {
103:   query?: string
104:   location?: string
105:   source?: string[]
106:   job_type?: string
107:   remote_type?: string
108:   salary_min?: number
109:   limit?: number
110:   offset?: number
111: }
112: 
113: // Search results
114: export interface JobSearchResult {
115:   jobs: Job[]
116:   total: number
117:   page: number
118:   limit: number
119: }
</file>

<file path="src/app/api/jobs/search/route.ts">
  1: /**
  2:  * Unified Job Search API - Enhanced with JobAggregator
  3:  * 
  4:  * NOW USES: JobAggregator with Supabase-first search strategy
  5:  * 
  6:  * Search Order:
  7:  * 1. Redis Cache (instant)
  8:  * 2. MongoDB Cache (fast)
  9:  * 3. Supabase (1,249 jobs, <100ms)
 10:  * 4. Cheerio/Puppeteer scrapers (if < 10 jobs, TOP 3 keywords)
 11:  * 5. Perplexity (last resort, if still < 10 jobs)
 12:  */
 13: 
 14: import { NextRequest, NextResponse } from 'next/server'
 15: import { getServerSession } from 'next-auth/next'
 16: import { authOptions } from '@/lib/auth'
 17: import { dbService } from '@/lib/database'
 18: import { JobAggregator } from '@/lib/job-aggregator'
 19: import { PerplexityIntelligenceService } from '@/lib/perplexity-intelligence'
 20: import { isRateLimited } from '@/lib/rate-limit'
 21: import Resume from '@/models/Resume'
 22: import { jobSearchCacheService } from '@/services/job-search-cache.service'
 23: import { validateJob } from '@/lib/validators/job-validator'
 24: import { DataSanitizer } from '@/lib/validators/data-sanitizer'
 25: import { deduplicateJobs } from '@/lib/job-deduplication'
 26: 
 27: export const dynamic = 'force-dynamic'
 28: export const runtime = 'nodejs'
 29: export const maxDuration = 60 // Increased to handle Perplexity API calls which can take longer
 30: 
 31: interface JobSearchRequest {
 32:   keywords: string
 33:   location?: string
 34:   sources?: string[] // Specific boards to search
 35:   limit?: number
 36:   remote?: boolean
 37:   salaryMin?: number
 38:   experienceLevel?: 'entry' | 'mid' | 'senior' | 'executive'
 39:   workType?: 'remote' | 'hybrid' | 'onsite' | 'any'
 40:   useResumeMatching?: boolean // Use resume for skill matching
 41:   targetIndustry?: string // ENTERPRISE: User wants to switch industries (e.g., "Technology", "Healthcare")
 42:   disableIndustryWeighting?: boolean // ENTERPRISE: User wants equal weight across all industries
 43: }
 44: 
 45: export async function POST(request: NextRequest) {
 46:   try {
 47:     // CRITICAL FIX: Parse body and validate location BEFORE authentication
 48:     // This allows testing location validation without auth
 49:     const body: JobSearchRequest = await request.json()
 50:     let { 
 51:       keywords, 
 52:       location, 
 53:       sources, 
 54:       limit = 25, 
 55:       remote,
 56:       salaryMin,
 57:       experienceLevel,
 58:       workType,
 59:       targetIndustry,
 60:       disableIndustryWeighting
 61:     } = body
 62:     
 63:     console.log('═══════════════════════════════════════════════════════')
 64:     console.log('[JOB_SEARCH] NEW SEARCH REQUEST')
 65:     console.log('═══════════════════════════════════════════════════════')
 66:     console.log('[JOB_SEARCH] Job Title:', keywords)
 67:     console.log('[JOB_SEARCH] Location:', location || 'UNDEFINED')
 68:     console.log('[JOB_SEARCH] Max Results:', limit)
 69:     console.log('[JOB_SEARCH] Work Type:', workType || 'any')
 70:     console.log('─────────────────────────────────────────────────────────')
 71: 
 72:     // CRITICAL: Validate location BEFORE authentication check
 73:     if (!location || location.trim().length < 2) {
 74:       console.error('[JOB_SEARCH] ❌ MISSING LOCATION')
 75:       return NextResponse.json({
 76:         success: false,
 77:         error: 'Location is required for job search',
 78:         suggestion: 'Upload your resume to extract location, or manually enter city and state/province',
 79:         errorCode: 'LOCATION_REQUIRED'
 80:       }, { status: 400 })
 81:     }
 82: 
 83:     // Reject "Canada" or "United States" (too broad)
 84:     const normalizedLocation = location.toLowerCase().trim()
 85:     if (['canada', 'united states', 'usa', 'us'].includes(normalizedLocation)) {
 86:       console.error('[JOB_SEARCH] ❌ LOCATION TOO BROAD:', location)
 87:       return NextResponse.json({
 88:         success: false,
 89:         error: 'Location is too broad. Please specify a city and state/province.',
 90:         example: 'Examples: Seattle, WA or Toronto, ON or Vancouver, BC',
 91:         errorCode: 'LOCATION_TOO_BROAD'
 92:       }, { status: 400 })
 93:     }
 94: 
 95:     console.log('[JOB_SEARCH] ✅ Location valid, proceeding with authentication...')
 96: 
 97:     // NOW check authentication after location validation passes
 98:     const session = await getServerSession(authOptions)
 99:     if (!session?.user?.id) {
100:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
101:     }
102: 
103:     // Rate limiting
104:     if (await isRateLimited(session.user.id, 'job-search')) {
105:       return NextResponse.json({ 
106:         error: 'Too many searches. Please wait a moment.' 
107:       }, { status: 429 })
108:     }
109: 
110:     await dbService.connect()
111: 
112:     let useResumeMatching = body.useResumeMatching || false
113: 
114:     if (!keywords || keywords.trim().length < 2) {
115:       return NextResponse.json({ 
116:         error: 'Please provide valid search keywords' 
117:       }, { status: 400 })
118:     }
119: 
120:     console.log(`[JOB_SEARCH] User ${session.user.id} searching: "${keywords}" in ${location} (Resume matching: ${useResumeMatching})`)
121: 
122:     // CRITICAL FIX: Get cached jobs but ALWAYS search for new ones too
123:     const cachedJobs = await jobSearchCacheService.getCachedJobs({
124:       keywords,
125:       location,
126:       workType,
127:       experienceLevel,
128:       userId: session.user.id
129:     });
130: 
131:     if (cachedJobs && cachedJobs.length > 0) {
132:       console.log(`[JOB_CACHE] Found ${cachedJobs.length} cached jobs - will merge with NEW search results`);
133:     } else {
134:       console.log(`[JOB_CACHE] No cached jobs found - performing fresh search`);
135:     }
136: 
137:     let result: any
138:     let jobs: any[] = []
139:     let metadata: any = {}
140: 
141:     // Option 1: Resume-matched search with INDUSTRY WEIGHTING (most powerful)
142:     if (useResumeMatching) {
143:       try {
144:         // Get user's resume
145:         const resumeDoc = await Resume.findOne({ userId: session.user.id })
146:           .sort({ createdAt: -1 })
147:           .lean()
148:         
149:         const extractedText = (resumeDoc as any)?.extractedText
150:         
151:         if (!resumeDoc || !extractedText) {
152:           return NextResponse.json({ 
153:             error: 'Please upload a resume first to use resume matching' 
154:           }, { status: 400 })
155:         }
156: 
157:         console.log(`[JOB_SEARCH] Using resume matching with industry weighting for user ${session.user.id}`)
158: 
159:         // ENTERPRISE FEATURE: Analyze career timeline for industry weighting
160:         let careerTimeline: any = null
161:         let effectivePrimaryIndustry: any = null
162:         
163:         // Skip industry analysis if user explicitly disabled it
164:         if (!disableIndustryWeighting) {
165:           try {
166:             careerTimeline = await PerplexityIntelligenceService.extractCareerTimeline(extractedText)
167:             console.log('[JOB_SEARCH] Career timeline:', {
168:               industries: careerTimeline.industries.map((i: any) => `${i.name} (${i.percentage}%)`).join(', '),
169:               primaryIndustry: careerTimeline.industries[0]?.name,
170:               hasTransition: !!careerTimeline.careerTransition,
171:               userTargetIndustry: targetIndustry || 'none'
172:             })
173:             
174:             // ENTERPRISE: User wants to switch industries
175:             if (targetIndustry && targetIndustry.trim()) {
176:               // Find matching industry from resume, or create synthetic one
177:               const normalizedTarget = targetIndustry.toLowerCase()
178:               effectivePrimaryIndustry = careerTimeline.industries.find(
179:                 (i: any) => i?.name?.toLowerCase()?.includes(normalizedTarget)
180:               )
181: 
182:               if (effectivePrimaryIndustry) {
183:                 console.log(`[JOB_SEARCH] User targeting industry switch TO: ${effectivePrimaryIndustry.name}`)
184:               } else {
185:                 // User wants to switch to an entirely new industry not in their history
186:                 console.log(`[JOB_SEARCH] User switching to NEW industry: ${targetIndustry} (no prior experience)`)
187:                 effectivePrimaryIndustry = {
188:                   name: targetIndustry,
189:                   yearsOfExperience: 0,
190:                   keywords: keywords
191:                     .split(',')
192:                     .map((k: string) => k.trim())
193:                     .filter(Boolean),
194:                   percentage: 100 // Give full weight to target industry
195:                 }
196:               }
197:             } else {
198:               // Default: Use longest-tenure industry
199:               effectivePrimaryIndustry = careerTimeline.industries[0]
200:             }
201:           } catch (err) {
202:             console.warn('[JOB_SEARCH] Career timeline extraction failed, using standard matching:', err)
203:           }
204:         } else {
205:           console.log('[JOB_SEARCH] Industry weighting DISABLED by user preference')
206:         }
207: 
208:         // CRITICAL: If career timeline exists, weight job results by industry tenure
209:         let industryWeightedLimit = limit
210:         
211:         if (effectivePrimaryIndustry) {
212:           // Calculate industry-based search distribution
213:           const primaryPercentage = effectivePrimaryIndustry.percentage / 100
214:           
215:           // EXAMPLE: If 95% of career in Transportation, show 95% transport jobs
216:           // UNLESS user is switching industries, then show 100% of new industry
217:           industryWeightedLimit = targetIndustry ? limit : Math.ceil(limit * primaryPercentage)
218:           
219:           console.log('[JOB_SEARCH] Industry weighting:', {
220:             primaryIndustry: effectivePrimaryIndustry.name,
221:             primaryPercentage: `${effectivePrimaryIndustry.percentage}%`,
222:             adjustedLimit: industryWeightedLimit,
223:             keywords: effectivePrimaryIndustry.keywords?.join(', ') || 'none',
224:             isSwitching: !!targetIndustry
225:           })
226:           
227:           // Boost keywords from target/primary industry (if available)
228:           if (effectivePrimaryIndustry.keywords && Array.isArray(effectivePrimaryIndustry.keywords) && effectivePrimaryIndustry.keywords.length > 0) {
229:             const industryKeywords = effectivePrimaryIndustry.keywords.slice(0, 5).join(', ')
230:             keywords = `${industryKeywords}, ${keywords}`.trim()
231:           }
232:         }
233: 
234:         // Use JobAggregator (Supabase → Scrapers → Perplexity fallback)
235:         console.log('[JOB_SEARCH] Using JobAggregator (Supabase first):', {
236:           keywords: Array.isArray(keywords) ? keywords : [keywords],
237:           location,
238:           workType: workType || 'any',
239:           maxResults: limit
240:         })
241:         
242:         const aggregator = JobAggregator.getInstance()
243:         const aggregatorResult = await aggregator.searchJobs({
244:           keywords: Array.isArray(keywords) ? keywords : keywords.split(',').map((k: string) => k.trim()),
245:           location,
246:           workType: workType || 'any',
247:           maxResults: limit
248:         })
249: 
250:         console.log('[JOB_SEARCH] 🎯 JobAggregator result:', {
251:           jobsFound: aggregatorResult.jobs.length,
252:           source: aggregatorResult.source,
253:           cached: aggregatorResult.cached
254:         })
255: 
256:         // Convert JobListing format to expected format with validation
257:         jobs = aggregatorResult.jobs
258:           .filter(job => {
259:             // Validate required fields
260:             if (!job.title || !job.company || !job.url) {
261:               console.warn('[JOB_SEARCH] ⚠️ Skipping job with missing fields')
262:               return false
263:             }
264:             return true
265:           })
266:           .map(job => ({
267:             title: job.title,
268:             company: job.company,
269:             location: job.location || 'Location not specified',
270:             url: job.url,
271:             description: job.description || '',
272:             summary: job.description?.substring(0, 200) || 'No description available',
273:             salary: job.salary || null,
274:             postedDate: job.postedDate?.toISOString().split('T')[0] || new Date().toISOString().split('T')[0],
275:             source: job.source || 'unknown',
276:             skillMatchPercent: job.skillMatchScore || 0,
277:             skills: job.skills || [],
278:             workType: job.workType || 'onsite'
279:           }))
280: 
281:         result = {
282:           success: true,
283:           data: jobs,
284:           cached: aggregatorResult.cached,
285:           metadata: {
286:             source: aggregatorResult.source,
287:             timestamp: aggregatorResult.timestamp
288:           }
289:         }
290:         
291:         // POST-PROCESSING: Re-rank jobs by industry tenure (respects user preferences)
292:         if (effectivePrimaryIndustry && !disableIndustryWeighting && effectivePrimaryIndustry.keywords && Array.isArray(effectivePrimaryIndustry.keywords)) {
293:           const primaryKeywords = effectivePrimaryIndustry.keywords.map((k: string) => k.toLowerCase())
294:           
295:           jobs = jobs.map((job: any) => {
296:             // Calculate industry match score
297:             const jobTitle = (job.title || '').toLowerCase()
298:             const jobDescription = (job.description || '').toLowerCase()
299:             const jobCompany = (job.company || '').toLowerCase()
300:             const fullText = `${jobTitle} ${jobDescription} ${jobCompany}`
301:             
302:             let industryMatchCount = 0
303:             primaryKeywords.forEach((keyword: string) => {
304:               if (fullText.includes(keyword)) industryMatchCount++
305:             })
306:             
307:             const industryMatchScore = industryMatchCount / primaryKeywords.length
308:             
309:             // Boost jobs from primary/target industry
310:             const originalScore = job.skillMatchScore || 0.5
311:             // If user is switching industries, give HIGHER boost (up to 75%)
312:             const boostMultiplier = targetIndustry ? 0.75 : 0.5
313:             const boostedScore = originalScore * (1 + industryMatchScore * boostMultiplier)
314:             
315:             return {
316:               ...job,
317:               skillMatchScore: Math.min(boostedScore, 1.0), // Cap at 1.0
318:               industryMatchScore,
319:               primaryIndustry: effectivePrimaryIndustry.name,
320:               isSwitchingIndustries: !!targetIndustry
321:             }
322:           }).sort((a: any, b: any) => (b.skillMatchScore || 0) - (a.skillMatchScore || 0)) // Re-sort by boosted score
323:           
324:           const matchedJobs = jobs.filter((j: any) => j.industryMatchScore > 0.3).length
325:           console.log(`[JOB_SEARCH] Applied industry weighting boost to ${jobs.length} jobs (${matchedJobs} strong matches)`)
326:         }
327:         
328:         metadata = {
329:           ...result.metadata,
330:           useResumeMatching: true,
331:           skillMatchingEnabled: true,
332:           industryWeighting: effectivePrimaryIndustry ? {
333:             primaryIndustry: effectivePrimaryIndustry.name,
334:             primaryPercentage: effectivePrimaryIndustry.percentage,
335:             careerTransition: careerTimeline?.careerTransition,
336:             userTargetIndustry: targetIndustry || null,
337:             disabledByUser: disableIndustryWeighting || false
338:           } : null
339:         }
340: 
341:         console.log(`[JOB_SEARCH] Resume matching found ${jobs.length} jobs with skill scores and industry weighting`)
342: 
343:       } catch (error) {
344:         console.error('[JOB_SEARCH] Resume matching failed, falling back to standard search:', error)
345:         // Fall back to standard search
346:         useResumeMatching = false
347:       }
348:     }
349: 
350:     // Option 2: Standard job listing search (JobAggregator with Supabase)
351:     if (!useResumeMatching || jobs.length === 0) {
352:       console.log(`[JOB_SEARCH] Using JobAggregator for standard search (Supabase first)`, {
353:         keywords,
354:         location,
355:         limit,
356:         workType: workType || (remote ? 'remote' : undefined)
357:       })
358: 
359:       const aggregator = JobAggregator.getInstance()
360:       const aggregatorResult = await aggregator.searchJobs({
361:         keywords: Array.isArray(keywords) ? keywords : keywords.split(',').map((k: string) => k.trim()),
362:         location,
363:         workType: workType || 'any',
364:         maxResults: limit
365:       })
366: 
367:       console.log(`[JOB_SEARCH] JobAggregator returned:`, {
368:         source: aggregatorResult.source,
369:         cached: aggregatorResult.cached,
370:         jobCount: aggregatorResult.jobs.length,
371:         sample: aggregatorResult.jobs[0] ? {
372:           title: aggregatorResult.jobs[0].title,
373:           company: aggregatorResult.jobs[0].company,
374:           hasUrl: !!aggregatorResult.jobs[0].url
375:         } : null
376:       })
377: 
378:       // Convert JobListing format to expected format with validation
379:       const jobsResult = aggregatorResult.jobs
380:         .filter(job => {
381:           // Validate required fields
382:           if (!job.title || !job.company || !job.url) {
383:             console.warn('[JOB_SEARCH] ⚠️ Skipping job with missing fields')
384:             return false
385:           }
386:           return true
387:         })
388:         .map(job => ({
389:           title: job.title,
390:           company: job.company,
391:           location: job.location || 'Location not specified',
392:           url: job.url,
393:           description: job.description || '',
394:           summary: job.description?.substring(0, 200) || 'No description available',
395:           salary: job.salary || null,
396:           postedDate: job.postedDate?.toISOString().split('T')[0] || new Date().toISOString().split('T')[0],
397:           source: job.source || 'unknown',
398:           skillMatchPercent: job.skillMatchScore || 0,
399:           skills: job.skills || [],
400:           workType: job.workType || 'onsite'
401:         }))
402: 
403:       jobs = Array.isArray(jobsResult) ? jobsResult : []
404:       console.log(`[JOB_SEARCH] Standard search returned type: ${typeof jobsResult}, isArray: ${Array.isArray(jobsResult)}, length: ${jobs.length}`)
405: 
406:       metadata = {
407:         useResumeMatching: false,
408:         searchedBoards: sources?.length || 15,
409:         canadianPriority: location.toLowerCase().includes('canada')
410:       }
411: 
412:       console.log(`[JOB_SEARCH] Standard search found ${jobs.length} jobs`)
413:       if (jobs.length > 0) {
414:         console.log(`[JOB_SEARCH] First job sample:`, JSON.stringify(jobs[0]).substring(0, 200))
415:       }
416:     }
417: 
418:     // Save search history
419:     try {
420:       const { default: SearchHistory } = await import('@/models/SearchHistory')
421:       await SearchHistory.create({
422:         userId: session.user.id,
423:         keywords,
424:         location,
425:         resultsCount: jobs.length,
426:         sources: sources || ['all'],
427:         aiUsed: useResumeMatching,
428:         searchDate: new Date()
429:       })
430:     } catch (error) {
431:       console.error('[JOB_SEARCH] Failed to save search history:', error)
432:       // Non-critical, continue
433:     }
434: 
435:     // IMPROVED: Mark confidential jobs instead of filtering them out
436:     let processedJobs = jobs.map((job: any) => {
437:       const company = (job.company || '').toLowerCase().trim()
438:       const title = (job.title || '').toLowerCase().trim()
439:       
440:       // Only filter out COMPLETELY invalid jobs (empty title/company)
441:       const isCompletelyInvalid = (company === '' && title === '')
442:       
443:       // Mark confidential companies but keep them
444:       const confidentialCompanies = ['confidential', 'confidential company', 'undisclosed', 'private']
445:       const isConfidential = confidentialCompanies.includes(company)
446:       
447:       return {
448:         ...job,
449:         isConfidential,
450:         isCompletelyInvalid,
451:         note: isConfidential ? 'Company name not disclosed in posting' : undefined
452:       }
453:     }).filter((job: any) => !job.isCompletelyInvalid) // Only filter completely invalid
454: 
455:     // 🚫 CRITICAL: REMOVE ALL CONFIDENTIAL JOBS - DO NOT SHOW THEM AT ALL
456:     const confidentialCount = processedJobs.filter((j: any) => j.isConfidential).length
457:     processedJobs = processedJobs.filter((j: any) => {
458:       const isConfidential = j.isConfidential || 
459:         j.title?.toLowerCase().includes('confidential') ||
460:         j.company?.toLowerCase().includes('confidential') ||
461:         j.company?.toLowerCase() === 'confidential'
462:       
463:       if (isConfidential) {
464:         console.log(`[JOB_SEARCH] 🚫 REJECTED CONFIDENTIAL JOB: "${j.title}" at "${j.company}"`)
465:       }
466:       
467:       return !isConfidential
468:     })
469:     
470:     console.log(`[JOB_SEARCH] Processed ${jobs.length} jobs, REJECTED ${confidentialCount} confidential jobs, ${processedJobs.length} valid jobs kept`)
471: 
472:     // CRITICAL FIX: Merge cached jobs with new results (remove duplicates by URL)
473:     let finalJobs = [...processedJobs]
474:     if (cachedJobs && cachedJobs.length > 0) {
475:       const newJobUrls = new Set(processedJobs.map((j: any) => j.url).filter(Boolean))
476:       // Also filter confidential from cached jobs
477:       const uniqueCachedJobs = cachedJobs.filter((cj: any) => {
478:         const isConfidential = cj.isConfidential || 
479:           cj.title?.toLowerCase().includes('confidential') ||
480:           cj.company?.toLowerCase().includes('confidential') ||
481:           cj.company?.toLowerCase() === 'confidential'
482:         return !newJobUrls.has(cj.url) && !isConfidential
483:       })
484:       finalJobs = [...processedJobs, ...uniqueCachedJobs]
485:       console.log(`[JOB_CACHE] Merged ${uniqueCachedJobs.length} unique cached jobs with ${processedJobs.length} new jobs = ${finalJobs.length} total`)
486:     }
487: 
488:     // 🚀 NEW: Cache the search results for 3 weeks
489:     if (processedJobs.length > 0) {
490:       await jobSearchCacheService.cacheSearchResults(
491:         {
492:           keywords,
493:           location,
494:           workType,
495:           experienceLevel,
496:           userId: session.user.id
497:         },
498:         processedJobs
499:       );
500:       console.log(`[JOB_CACHE] ✅ Cached ${processedJobs.length} jobs for future searches`);
501:     }
502: 
503:     // ✅ FIX #4: VALIDATE each job
504:     console.log(`[JOB_SEARCH] Validating ${finalJobs.length} jobs...`)
505:     console.log('[JOB_SEARCH] Sample job data:', finalJobs[0] ? {
506:       title: finalJobs[0].title,
507:       company: finalJobs[0].company,
508:       descLength: finalJobs[0].description?.length || 0,
509:       url: finalJobs[0].url
510:     } : 'No jobs to sample')
511:     
512:     const validatedJobs = finalJobs.filter((job: any) => {
513:       const validation = validateJob(job)
514:       if (!validation.valid) {
515:         console.log('[VALIDATOR] ❌ Rejected:', job.title, 'at', job.company)
516:         if (validation.issues && validation.issues.length > 0) {
517:           console.log('[VALIDATOR] Reasons:', validation.issues.join(', '))
518:         }
519:         console.log('[VALIDATOR] Job data:', {
520:           descLength: job.description?.length || 0,
521:           url: job.url,
522:           location: job.location
523:         })
524:         return false
525:       }
526:       return true
527:     })
528:     console.log(`[JOB_SEARCH] Validation: ${finalJobs.length} → ${validatedJobs.length}`)
529: 
530:     // ✅ FIX #5: DEDUPLICATE jobs
531:     const uniqueJobs = deduplicateJobs(validatedJobs)
532:     console.log(`[JOB_SEARCH] Deduplication: ${validatedJobs.length} → ${uniqueJobs.length}`)
533: 
534:     // ✅ FIX #4: SANITIZE output
535:     const sanitizedJobs = uniqueJobs.map((job: any) => DataSanitizer.sanitizeJobData(job))
536:     console.log(`[JOB_SEARCH] ✅ Final jobs: ${sanitizedJobs.length}`)
537: 
538:     // Get recommended boards for this location
539:     const recommendedBoards = PerplexityIntelligenceService.getRecommendedBoards(location)
540: 
541:     return NextResponse.json({
542:       success: true,
543:       query: { keywords, location, sources },
544:       totalResults: sanitizedJobs.length,
545:       returnedResults: Math.min(sanitizedJobs.length, limit),
546:       jobs: sanitizedJobs.slice(0, limit),
547:       metadata: {
548:         ...metadata,
549:         searchedAt: new Date().toISOString(),
550:         cachedResults: cachedJobs ? cachedJobs.length : 0,
551:         newResults: processedJobs.length,
552:         totalMerged: finalJobs.length,
553:         validated: validatedJobs.length,
554:         unique: uniqueJobs.length,
555:         final: sanitizedJobs.length
556:       },
557:       recommendations: {
558:         priorityBoards: recommendedBoards.slice(0, 5),
559:         reasoning: `Recommended job boards for ${location || 'your location'}`
560:       },
561:       sources: [...new Set(sanitizedJobs.map((j: any) => j.source || 'Unknown'))]
562:     })
563: 
564:   } catch (error: any) {
565:     console.error('❌❌❌ [JOB_SEARCH] CRITICAL ERROR ❌❌❌')
566:     console.error('[JOB_SEARCH] Error type:', error?.constructor?.name)
567:     console.error('[JOB_SEARCH] Error message:', error?.message)
568:     console.error('[JOB_SEARCH] Error stack:', error?.stack)
569:     
570:     // Get session for error logging
571:     const session = await getServerSession(authOptions)
572:     console.error('[JOB_SEARCH] User ID:', session?.user?.id)
573:     
574:     return NextResponse.json({ 
575:       error: 'Job search failed', 
576:       details: error?.message || 'Unknown error',
577:       errorType: error?.constructor?.name,
578:       timestamp: new Date().toISOString()
579:     }, { status: 500 })
580:   }
581: }
582: 
583: /**
584:  * GET endpoint for search history and available job boards
585:  */
586: export async function GET(request: NextRequest) {
587:   try {
588:     const session = await getServerSession(authOptions)
589:     if (!session?.user?.id) {
590:       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
591:     }
592: 
593:     await dbService.connect()
594: 
595:     const url = new URL(request.url)
596:     const action = url.searchParams.get('action')
597: 
598:     // Get available job boards
599:     if (action === 'boards') {
600:       const boards = PerplexityIntelligenceService.getAvailableJobBoards()
601:       return NextResponse.json({
602:         success: true,
603:         boards,
604:         totalBoards: boards.length
605:       })
606:     }
607: 
608:     // Get search history (default)
609:     const { default: SearchHistory } = await import('@/models/SearchHistory')
610:     const history = await SearchHistory.find({ userId: session.user.id })
611:       .sort({ searchDate: -1 })
612:       .limit(20)
613: 
614:     return NextResponse.json({
615:       success: true,
616:       history
617:     })
618: 
619:   } catch (error) {
620:     console.error('[JOB_SEARCH] Failed to fetch data:', error)
621:     return NextResponse.json({ 
622:       error: 'Failed to fetch data' 
623:     }, { status: 500 })
624:   }
625: }
</file>

<file path="src/lib/job-aggregator.ts">
  1: /**
  2:  * Job Aggregator with Multi-Layer Caching
  3:  * 
  4:  * Strategy:
  5:  * 1. Check Redis cache (instant)
  6:  * 2. Check MongoDB JobSearchCache (fast)
  7:  * 3. Search Supabase (1,249 jobs, <100ms)
  8:  * 4. If < 10 jobs: Try Cheerio/Puppeteer scrapers (TOP 3 keywords, ~30s)
  9:  * 5. If still < 10: Try Perplexity (last resort, TOP 3 keywords)
 10:  * 6. Cache all results for future users
 11:  */
 12: 
 13: import { RedisCache } from './redis-cache'
 14: import JobSearchCache, { IJobSearchCache } from '@/models/JobSearchCache'
 15: import { getJobScraper, JobListing } from './job-scraper-service'
 16: import { PerplexityIntelligenceService } from './perplexity-intelligence'
 17: import { getAdzunaClient } from './adzuna-api-client'
 18: import { getJSearchClient } from './jsearch-api-client'
 19: 
 20: const redis = RedisCache.getInstance()
 21: const adzuna = getAdzunaClient()
 22: const jsearch = getJSearchClient()
 23: 
 24: export interface JobSearchParams {
 25:   keywords: string[]
 26:   location: string
 27:   radiusKm?: number
 28:   workType?: 'remote' | 'hybrid' | 'onsite' | 'any'
 29:   experienceLevel?: 'entry' | 'mid' | 'senior' | 'executive'
 30:   maxResults?: number
 31: }
 32: 
 33: export interface JobSearchResult {
 34:   jobs: JobListing[]
 35:   source: 'redis' | 'mongodb' | 'supabase' | 'adzuna' | 'jsearch' | 'perplexity' | 'scraper' | 'hybrid'
 36:   cached: boolean
 37:   timestamp: Date
 38:   searchCount?: number
 39: }
 40: 
 41: export class JobAggregator {
 42:   private static instance: JobAggregator
 43: 
 44:   static getInstance(): JobAggregator {
 45:     if (!JobAggregator.instance) {
 46:       JobAggregator.instance = new JobAggregator()
 47:     }
 48:     return JobAggregator.instance
 49:   }
 50: 
 51:   /**
 52:    * Generate cache key from search params
 53:    */
 54:   private generateCacheKey(params: JobSearchParams): string {
 55:     const normalizedKeywords = params.keywords
 56:       .map(k => k.toLowerCase().trim())
 57:       .sort()
 58:       .join(',')
 59:     
 60:     return `jobs:${normalizedKeywords}:${params.location.toLowerCase()}:${params.workType || 'any'}:${params.radiusKm || 70}`
 61:   }
 62: 
 63:   /**
 64:    * Search jobs with multi-layer caching
 65:    */
 66:   async searchJobs(params: JobSearchParams): Promise<JobSearchResult> {
 67:     const {
 68:       keywords,
 69:       location,
 70:       radiusKm = 70,
 71:       workType = 'any',
 72:       experienceLevel,
 73:       maxResults = 100
 74:     } = params
 75: 
 76:     console.log('[JOB_AGGREGATOR] Starting job search:', {
 77:       keywords: keywords.slice(0, 5),
 78:       location,
 79:       radiusKm,
 80:       maxResults
 81:     })
 82: 
 83:     // LAYER 1: Check Redis cache (instant)
 84:     const redisKey = this.generateCacheKey(params)
 85:     const redisResult = await redis.get<JobListing[]>(redisKey)
 86:     
 87:     if (redisResult && redisResult.length > 0) {
 88:       console.log(`[JOB_AGGREGATOR] ✅ Redis cache HIT: ${redisResult.length} jobs`)
 89:       return {
 90:         jobs: redisResult.slice(0, maxResults),
 91:         source: 'redis',
 92:         cached: true,
 93:         timestamp: new Date()
 94:       }
 95:     }
 96: 
 97:     console.log('[JOB_AGGREGATOR] Redis cache MISS')
 98: 
 99:     // LAYER 2: Check MongoDB JobSearchCache (fast)
100:     const mongoResult = await this.searchMongoCache(keywords, location, workType)
101:     
102:     if (mongoResult && mongoResult.jobs.length > 0) {
103:       console.log(`[JOB_AGGREGATOR] ✅ MongoDB cache HIT: ${mongoResult.jobs.length} jobs`)
104:       
105:       // Convert to JobListing format
106:       const jobs: JobListing[] = mongoResult.jobs.map(job => ({
107:         jobId: job.jobId,
108:         title: job.title,
109:         company: job.company,
110:         location: job.location,
111:         description: job.description || 'No description available',
112:         url: job.url,
113:         source: job.source,
114:         salary: job.salary,
115:         postedDate: job.postedDate,
116:         workType: (job.workType as 'remote' | 'hybrid' | 'onsite') || 'onsite',
117:         skillMatchScore: job.skillMatchScore,
118:         skills: []
119:       }))
120: 
121:       // Cache in Redis for next time
122:       await redis.set(redisKey, jobs, 3600) // 1 hour
123: 
124:       // Update search count
125:       mongoResult.searchCount += 1
126:       mongoResult.lastSearched = new Date()
127:       await mongoResult.save()
128: 
129:       return {
130:         jobs: jobs.slice(0, maxResults),
131:         source: 'mongodb',
132:         cached: true,
133:         timestamp: new Date(),
134:         searchCount: mongoResult.searchCount
135:       }
136:     }
137: 
138:     console.log('[JOB_AGGREGATOR] MongoDB cache MISS')
139: 
140:     // LAYER 3: Search Supabase (1,249 jobs available!) - Use ALL keywords
141:     console.log('[JOB_AGGREGATOR] Searching Supabase with ALL keywords...')
142:     let allJobs: JobListing[] = []
143:     let source: 'supabase' | 'scraper' | 'perplexity' | 'hybrid' = 'supabase'
144: 
145:     try {
146:       const { searchJobs } = await import('./supabase')
147:       const supabaseResult = await searchJobs({
148:         query: keywords.join(' '), // ALL keywords for cache search
149:         location,
150:         limit: maxResults
151:       })
152: 
153:       if (supabaseResult.jobs.length > 0) {
154:         console.log(`[JOB_AGGREGATOR] ✅ Supabase found ${supabaseResult.jobs.length} jobs`)
155:         
156:         // Convert Supabase jobs to JobListing format with validation
157:         allJobs = supabaseResult.jobs
158:           .filter(job => {
159:             // Validate required fields
160:             if (!job.id || !job.title || !job.company || !job.url) {
161:               console.warn('[JOB_AGGREGATOR] ⚠️ Skipping invalid job - missing required fields:', {
162:                 id: job.id,
163:                 hasTitle: !!job.title,
164:                 hasCompany: !!job.company,
165:                 hasUrl: !!job.url
166:               })
167:               return false
168:             }
169:             return true
170:           })
171:           .map(job => ({
172:             jobId: job.id,
173:             title: job.title,
174:             company: job.company,
175:             location: job.location || 'Location not specified',
176:             description: job.description || 'No description available',
177:             url: job.url,
178:             source: job.source,
179:             salary: job.salary_min && job.salary_max ? `$${job.salary_min} - $${job.salary_max}` : undefined,
180:             postedDate: job.scraped_at ? new Date(job.scraped_at) : undefined,
181:             workType: (job.remote_type as 'remote' | 'hybrid' | 'onsite') || 'onsite',
182:             skillMatchScore: 0,
183:             skills: []
184:           } as JobListing))
185: 
186:         // If we got >= 10 jobs from Supabase, cache and return immediately
187:         if (allJobs.length >= 10) {
188:           console.log(`[JOB_AGGREGATOR] ✅ Supabase returned ${allJobs.length} jobs (>= 10), skipping fallbacks`)
189:           await redis.set(redisKey, allJobs, 3600)
190:           
191:           return {
192:             jobs: allJobs.slice(0, maxResults),
193:             source: 'supabase',
194:             cached: false,
195:             timestamp: new Date()
196:           }
197:         }
198:       }
199:     } catch (error) {
200:       console.error('[JOB_AGGREGATOR] Supabase search failed:', error)
201:     }
202: 
203:     console.log(`[JOB_AGGREGATOR] Supabase returned ${allJobs.length} jobs (< 10), triggering fallbacks...`)
204: 
205:     // LAYER 4: If < 10 jobs, use Cheerio/Puppeteer scrapers with TOP 3 keywords
206:     if (allJobs.length < 10) {
207:       console.log('[JOB_AGGREGATOR] Using Cheerio/Puppeteer scrapers with TOP 3 keywords...')
208:       source = 'scraper'
209:       
210:       try {
211:         const top3Keywords = keywords.slice(0, 3)
212:         console.log(`[JOB_AGGREGATOR] Scraping with keywords: ${top3Keywords.join(', ')}`)
213:         
214:         const scrapedJobs = await this.searchWithScrapers(
215:           top3Keywords, // TOP 3 keywords only
216:           location,
217:           10 // Target 10 jobs per keyword = 30 total
218:         )
219: 
220:         if (scrapedJobs.length > 0) {
221:           console.log(`[JOB_AGGREGATOR] ✅ Scrapers found ${scrapedJobs.length} jobs`)
222:           allJobs = [...allJobs, ...scrapedJobs]
223:           source = allJobs.length > scrapedJobs.length ? 'hybrid' : 'scraper'
224:         }
225:       } catch (error) {
226:         console.error('[JOB_AGGREGATOR] Scrapers failed:', error)
227:       }
228:     }
229: 
230:     // LAYER 5: If STILL < 10 jobs, use Perplexity as LAST RESORT with TOP 3 keywords
231:     if (allJobs.length < 10) {
232:       console.log('[JOB_AGGREGATOR] Still < 10 jobs, using Perplexity as last resort with TOP 3 keywords...')
233:       source = 'perplexity'
234:       
235:       try {
236:         const top3Keywords = keywords.slice(0, 3)
237:         console.log(`[JOB_AGGREGATOR] Perplexity with keywords: ${top3Keywords.join(', ')}`)
238:         
239:         const perplexityJobs = await this.searchWithPerplexity(
240:           top3Keywords, // TOP 3 keywords only
241:           location,
242:           10 // Target 10 jobs
243:         )
244: 
245:         if (perplexityJobs.length > 0) {
246:           console.log(`[JOB_AGGREGATOR] ✅ Perplexity found ${perplexityJobs.length} jobs`)
247:           allJobs = [...allJobs, ...perplexityJobs]
248:           source = allJobs.length > perplexityJobs.length ? 'hybrid' : 'perplexity'
249:         }
250:       } catch (error) {
251:         console.error('[JOB_AGGREGATOR] Perplexity failed:', error)
252:       }
253:     }
254: 
255:     // Deduplicate by composite key (company + title + location)
256:     const uniqueJobs = Array.from(
257:       new Map(allJobs.map(job => {
258:         // Create composite key for better deduplication
259:         const key = `${job.company}|${job.title}|${job.location}`.toLowerCase().trim()
260:         return [key, job]
261:       })).values()
262:     )
263: 
264:     console.log(`[JOB_AGGREGATOR] Total unique jobs after deduplication: ${uniqueJobs.length}`)
265: 
266:     // LAYER 6: Cache results for future users
267:     if (uniqueJobs.length > 0) {
268:       await redis.set(redisKey, uniqueJobs, 3600)
269:       console.log(`[JOB_AGGREGATOR] ✅ Cached ${uniqueJobs.length} jobs in Redis`)
270:     }
271: 
272:     return {
273:       jobs: uniqueJobs.slice(0, maxResults),
274:       source,
275:       cached: false,
276:       timestamp: new Date()
277:     }
278:   }
279: 
280:   /**
281:    * Search MongoDB cache
282:    */
283:   private async searchMongoCache(
284:     keywords: string[],
285:     location: string,
286:     workType?: string
287:   ): Promise<IJobSearchCache | null> {
288:     try {
289:       const normalizedKeywords = keywords
290:         .map(k => k.toLowerCase().trim())
291:         .sort()
292: 
293:       // Find matching cache entry
294:       const cache = await JobSearchCache.findOne({
295:         normalizedKeywords: { $all: normalizedKeywords },
296:         location: new RegExp(location, 'i'),
297:         $or: [
298:           { workType: workType },
299:           { workType: 'any' },
300:           { workType: { $exists: false } }
301:         ],
302:         expiresAt: { $gt: new Date() }
303:       }).sort({ lastSearched: -1 })
304: 
305:       return cache
306:     } catch (error) {
307:       console.error('[JOB_AGGREGATOR] MongoDB search error:', error)
308:       return null
309:     }
310:   }
311: 
312:   /**
313:    * Search with Adzuna API (FREE)
314:    */
315:   private async searchWithAdzuna(
316:     keywords: string[],
317:     location: string,
318:     maxResults: number
319:   ): Promise<JobListing[]> {
320:     const jobs: JobListing[] = []
321: 
322:     // Determine country code from location
323:     let country: 'ca' | 'us' | 'gb' = 'ca'
324:     const locationLower = location.toLowerCase()
325:     if (locationLower.includes('usa') || locationLower.includes('united states')) {
326:       country = 'us'
327:     } else if (locationLower.includes('uk') || locationLower.includes('united kingdom')) {
328:       country = 'gb'
329:     }
330: 
331:     // Search for each keyword
332:     for (const keyword of keywords) {
333:       try {
334:         const results = await adzuna.searchJobs({
335:           what: keyword,
336:           where: location,
337:           country,
338:           resultsPerPage: Math.min(50, Math.ceil(maxResults / keywords.length)),
339:           sortBy: 'relevance',
340:           maxDaysOld: 30 // Only jobs from last 30 days
341:         })
342: 
343:         if (results.results.length > 0) {
344:           const converted = results.results.map(job => adzuna.convertToJobListing(job))
345:           jobs.push(...converted)
346:         }
347:       } catch (error) {
348:         console.error(`[JOB_AGGREGATOR] Adzuna error for "${keyword}":`, error)
349:       }
350:     }
351: 
352:     return jobs
353:   }
354: 
355:   /**
356:    * Search with JSearch API (FREE, aggregates Indeed/LinkedIn/Glassdoor)
357:    */
358:   private async searchWithJSearch(
359:     keywords: string[],
360:     location: string,
361:     maxResults: number
362:   ): Promise<JobListing[]> {
363:     const jobs: JobListing[] = []
364: 
365:     // Determine country code from location
366:     let country = 'us'
367:     const locationLower = location.toLowerCase()
368:     if (locationLower.includes('canada') || locationLower.includes('canadian')) {
369:       country = 'ca'
370:     } else if (locationLower.includes('uk') || locationLower.includes('united kingdom')) {
371:       country = 'gb'
372:     }
373: 
374:     // Search for each keyword
375:     for (const keyword of keywords) {
376:       try {
377:         const result = await jsearch.searchJobs({
378:           query: keyword,
379:           location,
380:           page: 1,
381:           numPages: 1,
382:           datePosted: 'month',
383:           country
384:         })
385: 
386:         if (result.data && result.data.length > 0) {
387:           const converted = result.data.map(job => jsearch.convertToJobListing(job))
388:           jobs.push(...converted)
389:         }
390:       } catch (error) {
391:         console.error(`[JOB_AGGREGATOR] JSearch error for "${keyword}":`, error)
392:       }
393:     }
394: 
395:     return jobs
396:   }
397: 
398:   /**
399:    * Search with Perplexity
400:    */
401:   private async searchWithPerplexity(
402:     keywords: string[],
403:     location: string,
404:     maxResults: number
405:   ): Promise<JobListing[]> {
406:     const jobs: JobListing[] = []
407: 
408:     // Search for each keyword
409:     for (const keyword of keywords) {
410:       try {
411:         const result = await PerplexityIntelligenceService.jobMarketAnalysisV2(
412:           location,
413:           keyword, // Use keyword as minimal resume text
414:           {
415:             roleHint: keyword,
416:             maxResults: Math.ceil(maxResults / keywords.length)
417:           }
418:         )
419: 
420:         if (result.data && result.data.length > 0) {
421:           // Convert Perplexity format to scraper format
422:           const convertedJobs: JobListing[] = result.data.map(job => ({
423:             jobId: job.url ? `perplexity_${Buffer.from(job.url).toString('base64').slice(0, 16)}` : `perplexity_${Date.now()}`,
424:             title: job.title,
425:             company: job.company,
426:             location: job.location,
427:             description: job.summary || 'No description available',
428:             url: job.url,
429:             source: job.source || 'perplexity',
430:             salary: job.salary || undefined,
431:             postedDate: job.postedDate ? new Date(job.postedDate) : undefined,
432:             workType: job.workType,
433:             experienceLevel: job.experienceLevel,
434:             skills: job.skills,
435:             skillMatchScore: job.skillMatchPercent
436:           }))
437:           jobs.push(...convertedJobs)
438:         }
439:       } catch (error) {
440:         console.error(`[JOB_AGGREGATOR] Perplexity error for "${keyword}":`, error)
441:       }
442:     }
443: 
444:     return jobs
445:   }
446: 
447:   /**
448:    * Search with Puppeteer scrapers
449:    */
450:   private async searchWithScrapers(
451:     keywords: string[],
452:     location: string,
453:     maxResults: number
454:   ): Promise<JobListing[]> {
455:     const scraper = getJobScraper()
456:     const jobs: JobListing[] = []
457: 
458:     // Search for each keyword
459:     for (const keyword of keywords) {
460:       try {
461:         const result = await scraper.aggregateJobs(keyword, location, {
462:           maxResults: Math.ceil(maxResults / keywords.length)
463:         })
464: 
465:         if (result.length > 0) {
466:           jobs.push(...result)
467:         }
468:       } catch (error) {
469:         console.error(`[JOB_AGGREGATOR] Scraper error for "${keyword}":`, error)
470:       }
471:     }
472: 
473:     return jobs
474:   }
475: 
476:   /**
477:    * Cache results in both Redis and MongoDB
478:    */
479:   private async cacheResults(
480:     params: JobSearchParams,
481:     jobs: JobListing[]
482:   ): Promise<void> {
483:     const { keywords, location, workType } = params
484: 
485:     try {
486:       // Cache in Redis (1 hour)
487:       const redisKey = this.generateCacheKey(params)
488:       await redis.set(redisKey, jobs, 3600)
489:       console.log(`[JOB_AGGREGATOR] Cached ${jobs.length} jobs in Redis`)
490: 
491:       // Cache in MongoDB (3 weeks)
492:       const normalizedKeywords = keywords
493:         .map(k => k.toLowerCase().trim())
494:         .sort()
495: 
496:       const mongoJobs = jobs.map(job => ({
497:         jobId: job.jobId,
498:         title: job.title,
499:         company: job.company,
500:         location: job.location,
501:         description: job.description,
502:         url: job.url,
503:         source: job.source,
504:         salary: job.salary,
505:         postedDate: job.postedDate,
506:         workType: job.workType,
507:         skillMatchScore: job.skillMatchScore,
508:         viewedBy: [],
509:         appliedBy: [],
510:         savedBy: []
511:       }))
512: 
513:       await JobSearchCache.create({
514:         keywords,
515:         normalizedKeywords,
516:         location,
517:         workType: workType || 'any',
518:         jobs: mongoJobs,
519:         searchCount: 1,
520:         lastSearched: new Date(),
521:         expiresAt: new Date(Date.now() + 21 * 24 * 60 * 60 * 1000) // 3 weeks
522:       })
523: 
524:       console.log(`[JOB_AGGREGATOR] Cached ${jobs.length} jobs in MongoDB`)
525:     } catch (error) {
526:       console.error('[JOB_AGGREGATOR] Cache error:', error)
527:     }
528:   }
529: 
530:   /**
531:    * Search jobs by resume keywords (main entry point)
532:    */
533:   async searchByResumeKeywords(
534:     resumeKeywords: string[],
535:     location: string,
536:     radiusKm: number = 70,
537:     maxResults: number = 100
538:   ): Promise<JobSearchResult> {
539:     console.log('[JOB_AGGREGATOR] Searching by resume keywords:', {
540:       keywordCount: resumeKeywords.length,
541:       location,
542:       radiusKm
543:     })
544: 
545:     // Use top 10 keywords
546:     const topKeywords = resumeKeywords.slice(0, 10)
547: 
548:     return this.searchJobs({
549:       keywords: topKeywords,
550:       location,
551:       radiusKm,
552:       maxResults
553:     })
554:   }
555: 
556:   /**
557:    * Get cache statistics
558:    */
559:   async getCacheStats(): Promise<{
560:     redisStats: any
561:     mongoStats: {
562:       totalCaches: number
563:       totalJobs: number
564:       avgJobsPerCache: number
565:     }
566:   }> {
567:     const redisStats = await redis.getStats()
568: 
569:     const mongoCaches = await JobSearchCache.countDocuments()
570:     const mongoAgg = await JobSearchCache.aggregate([
571:       {
572:         $project: {
573:           jobCount: { $size: '$jobs' }
574:         }
575:       },
576:       {
577:         $group: {
578:           _id: null,
579:           totalJobs: { $sum: '$jobCount' },
580:           avgJobs: { $avg: '$jobCount' }
581:         }
582:       }
583:     ])
584: 
585:     return {
586:       redisStats,
587:       mongoStats: {
588:         totalCaches: mongoCaches,
589:         totalJobs: mongoAgg[0]?.totalJobs || 0,
590:         avgJobsPerCache: Math.round(mongoAgg[0]?.avgJobs || 0)
591:       }
592:     }
593:   }
594: }
595: 
596: export default JobAggregator
</file>

</files>
